# 自动内存管理



## 运行时数据区域

1.定义：java在执行程序时内存被划分为不同数据区域

2.特点：有些区域随虚拟机一直存在，有些区域依赖用户线程

![图摘自《码出高效》](https://upload-images.jianshu.io/upload_images/14923529-c0cbbccaa6858ca1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 程序计数器

1.定义：**当前线程**执行字节码的行号指示器

2.特点：每个线程（内核）都有独立的程序计数器，执行时记录java方法的虚拟机字节码指令地址。





### java虚拟机栈

1.定义：方法执行的线程内存模型，是线程私有的

### 栈帧结构：

**局部变量表**

1.定义：存放方法参数和方法内部定义的局部变量。

2.特点：(1)java虚拟机按照索引定位的方式使用局部变量表

​			（2）java虚拟机使用局部变量表完成参数值到参数列表的传递（形参到实参）；第一个变量槽是**对象实例的引用**，下来参数列表，方法局部变量。

​			（3）变量槽可重用,变量超出作用域后变量槽会被重用。

​			（4）变量表中的变量属于GC Roots

**操作栈**

1.定义：**java执行字节码是基于栈的解释执行引擎**（整个运算过程的中间变量都是基于操作数栈的出栈，入栈）

例如：

```java
public int calc() {
	int a = 100;
  int b = 200;
  int c = 300;
  return (a+b)*c;

}
```

先把a，b，c入栈，然后出栈放入局部变量表中，然后将变量槽中的值复制到栈顶，出栈做运算再入栈。

**动态连接**

1.定义：**栈帧指向运行时常量池中栈帧所属方法的引用（符号引用）**，**字节码方法调用指令就是以符号引用为参数。**符号引用在编译时被解析为直接引用是静态解析，符号引用在运行时被解析为直接引用叫动态连接。

**方法返回地址**



### 本地方法栈

为虚拟机使用的本地方法服务



### java堆

1.定义：存放对象实例，虚拟机启动时创建

2.特点：基于分代设计理论，有TALB（线程缓冲区）提高对象分配效率，可以被设置为固定大小，也可以拓展。



### 方法区

定义：存放虚拟机加载的类型信息，常量，静态变量



**运行时常量池**

定义：存放常量池表，存放符号引用和直接引用。



### 直接内存

避免java堆和Native堆来回复制数据？？



问题：java局部变量存放在局部变量表，存放在栈里，java实例变量存放在哪？

分成基本类型和对象讨论，基本类型的局部变量在栈里，基本类型的实例变量在堆里

对象类型的局部变量在栈里（引用），对象类型的实例变量被引用该对象的对象持有，而该对象的对象在堆里。

【但要使用对象的对象时必定会在栈中，该对象引用的引用还是会进入栈中】

**所以对象类型的变量无论是局部变量还是实例变量都在栈里【讨论的是对象的引用】**

所以局部变量在栈里，实例变量（基本类型）在堆里，实例变量（引用类型）在堆里，也在栈里。



### 题外话：java的按值传递

java类型分为基本类型和引用类型，当当前函数栈帧的实参传入新函数栈帧的形参时，都是在复制值，基本类型是复制值，引用类型是复制对象的引用（地址）。当复制的值在新的函数栈帧中改变后不会影响原栈帧中的值

参考https://blog.csdn.net/u013930425/article/details/87801432，https://blog.csdn.net/u013309870/article/details/75499175

成员变量被传递到方法的栈帧时，因为成员变量是在堆上，相当于拿到的是对象（this）引用（地址），修改值后会改变成员变量的值。



## java对象



####对象的创建

**java虚拟机层面**

**1.1.new关键字**：new指令参数是类的符号引用，会检查是否该类已经被加载（可能是在方法区查看有无该类型吗？），解析，初始化。然后会为对象在**堆上分配内存** 【**指针碰撞/空闲列表**：取决于不同算法的垃圾收集器】

分配内存的并发性解决：1.**同步处理CAS**；2.**TLAB** 线程本地缓存



**2.对象内存空间【实例数据】初始化为零值（不包括对象头）保证对象在不赋初始值就可以被访问**



**3.对对象头的信息进行设置**

至此，虚拟机层面的对象已经被创建出来了。





**java程序层面**

**执行构造函数**





####对象的内存布局

堆内存布局：对象头，实例数据，对齐填充

**1.对象头**：运行时数据、类型指针

运行时数据：哈希码，GC分代年龄等

类型指针：对象指向类型元数据的指针，不一定所有虚拟机都会在对象实例中实现【查找对象元数据不一定经过对象本身】



**2.实例数据**：类中所有字段包括从父类继承而来的，父类变量出现在子类之前，由大到小排列。



**3.对其填充**：任何对象都必须是8字节的整数倍，对象头已经被设置成8字节的倍数（1倍或2倍），实例数据没有对齐时用对其填充对齐



#### 对象访问定位

1.句柄访问：java堆中有句柄池，优势在于垃圾清理时，只需改变句柄池不需改变变量表中的引用。

2.直接指针

![image-20200516133828261](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200516133828261.png)





# 垃圾收集器与内存分配策略





## 对象回收判断算法【垃圾判定算法】

###引用计数器法

概述：对象中存在引用计数器，被引用计数器会+1，引用消失计数器-1

优点：简单效率高

缺点：相互循环引用带来的无法回收问题





### 可达性分析算法

概述：从GC roots开始，根据引用图向下搜索，不可达的对象会被回收。

**GC ROOTS**:

虚拟机栈上引用的对象。

方法区类静态属性引用（static）

方法区常量引用（final）



## 对象回收过程

###两次标记筛选

第一次标记：可达性分析被标记为不可达对象的对象被标记

第一次筛选：被标记对象是否有必要执行finalize（）；若有必要，则加入F-Queue队列开始执行。

第二次标记：对F-Queue队列进行标记【可在此阶段拯救对象，只需被其它对象引用即可：将this关键字赋值给其它对象属性】

第二次筛选：F-Queue队列中没有被重新建立引用关系的对象被回收。



## 垃圾收集算法

根据不同的对象回收判断算法，分为不同的垃圾收集算法：直接垃圾收集，间接垃圾收集。

### 分代垃圾收集理论

（1）大部分对象都是朝生夕死。              	 ------------新生代

（2）熬过越多次垃圾收集的对象越难消亡。--------------老年代

以上两条理论奠定分区域收集，因此出现了标记-清除，标记-复制，标记-整理针对不同区域收集的算法

（3）跨代引用相对于同代引用很少数。    	-----------在进行Minor GC时为了解决新生代被老年代跨代引用的问题不需要完全扫描整个老年代，只需在新生代建立记忆集【记录在老年代某一区域存在跨代引用】，进行GC时扫描记忆集，节约了扫描老年代的成本。



**标记就是之前的垃圾判定过程**

####标记-清除算法【新生代】

标记出需要回收的对象，统一回收

缺点：1.可回收对象较多导致清除动作过多。

2.回收后垃圾碎片过多，没有连续空间可能导致无法分配对象而导致新一次垃圾收集。





#### 标记-复制算法【新生代】

为了解决标记-清除算法需要清除的对象过多问题【无法一下清除】

将堆分为两块区域，一块区域用完后，将该区域存活对象复制到另一区域，将该区域全部清除。

缺点：将可用内存缩小了。

Appel式回收：一个Eden两个survivor，

​						逃生门设计：分配担保，当survivor区域无法容纳对象时，直接进入老年代





####标记-整理算法【老年代】

先进行标记，然后将所有存活对象向空间一段移动，再进行清理：清除边界以外区域。

优点：吞吐量增加。

缺点：停顿时间变长，延迟边长。

一种方案：大多时间采用标记-清除算法，内存碎片影响分配对象时采用标记-整理算法收集一次【CMS】



### 根节点枚举

需要时间停顿

无法完全扫描方法区，

1.使用OopMap优化【类加载完成后，将对象内什么偏移量是什么类型计算出来，将引用存入OopMap】，进入安全点【具有程序长时间执行的特征】后扫描OopMap内容加入GC Roots完成根节点枚举。

2.扫描卡表（记忆集）内容加入GC Roots完成根节点枚举，【卡表的每一个元素叫卡页，卡页内对象有跨带指针则卡页变脏】

**使用写后屏障完成卡表更新**



### 并发的可达性分析

使用三色标记算法完成并发的可达性分析。

当并发出现时（标记对象时有新对象的引用变更）采用增量更新，原始快照解决。



对象消失问题条件：【同时满足】

1.插入了一条或多条从黑到白的引用。

2.删除了所有从灰到白的引用



**增量更新**

检查第一个条件，并发扫描结束后，以条件中的黑色对象为根重新扫描一次。





**原始快照**

检查第二个条件，并发扫描结束后，以条件中的灰色对象为根重新扫描一次。





# 类文件结构

定义：class文件是一种以**8字节**为单位的二进制流，超过8字节以Big-Endian方式分成若干个8字节存储。

结构：无符号数，表。

无符号数以u1，u2，u4，u8表示，

表由若干个无符号数组成，以_info结尾。

无论无符号数还是表，使用**一个前置计数器和若干数据项表示的称作集合。**

![image-20200525145810513](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200525145810513.png)

## 魔数与版本号

前四个字节为魔数，作用是确定class文件是否能被java虚拟机接受，**0XCAFEBABE**

后4个字节为版本号，次版本号在前，主版本号在后，**jdk1.1是45，0X0057表示jdk13**



## 常量池

定义：常量池计数器，常量表

常量池计数器从1开始，因为将0空出，class文件中不引用常量池中常量的数据可以设置为0。

**常量表**

组成：字面量，符号引用

字面量是java中的常量final

符号引用是进行动态连接：java类加载中加载过程从常量池中取出【静态分派，也可以称之为编译期】，在类加载解析过程变为直接引用。【动态分派】

常量表有17种常量（字面量和符号引用），每个常量第一位是u1标志位。

![image-20200525162203956](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200525162203956.png)

java方法，字段需要引用constant_utf8_info描述名称，constant_utf8_info长度为u2，最长65535，64kb。



## 访问标志

常量池后2个字节代表访问标志，表示类或者接口，u2



## 类索引，父类索引，接口索引集合

u2类型，类索引表示类的全限定类名，父类索引表示父类的全限定类名，接口索引表示接口。



## 字段表集合








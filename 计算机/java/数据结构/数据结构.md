#  数据结构



数据库和数据结构本质相同，两者都是对数据的存储方式，都有增删改查等功能，数据结构是存储在内存中。



# 数组

定义：把数据码成一排进行存放

```java
int[] arrys = new int[size];
int[] arrys = new int[] {};
```

最大优点：快速查询

最好应用于“索引有语义”的情况【因为可以根据有语义的索引查询元素】

数组也可以用于“索引没有语义”的情况【并非所有索引有语义的情况都适用于数组】



**添加删除操作**

插入位置是一个指针，最后位置是一个指针，需要一个for循环在两者之间遍历。



## 数组时间复杂度

![image-20200602080150833](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200602080150833.png)

![image-20200602075940382](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200602075940382.png)







## 平摊复杂度

每次addlast（e）【O(1)】直到数组填满，然后进行resize操作【O(n)】，2n/n=2,所以addlast（e）平摊复杂度为O(2).



## 复杂度震荡

描述：进行resize时size为1/2，之后每次添加删除都会进行resize，复杂度为O(n)。



![image-20200602081140115](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200602081140115.png)



# 栈

一种线性结构

栈的操作是数组操作的子集，只能从一端进行数据操作【栈是数组的一种特殊实现】

后进先出【LIFO】

## 栈的应用

撤销操作

将栈顶元素删去。



系统栈

子过程调用时系统栈记录程序调用的位置。









### 队列【基于动态数组】

无论哪种方式数组尾肯定作为队尾



**直接实现队列**

没有front，tail标记，

数组尾肯定作为队尾

但是数组首段作为队首删除至少0(n)











**循环队列**

有front，tail标记，数组首作为front，数组尾作为tail，需要循环利用空间，可实现都为O(1)复杂度。







### 链表【真正动态数据结构】

链表是翻过来的数组

**作用**

1.引用和指针为基础

2.递归特性

3.组成其它数据结构

4.最简单的动态数据结构



**特点：**

优点：

1.数据存储在节点中。

2.真正的动态，不需要处理固定容量的问题

缺点：

丧失了随机访问的能力



**与数组相比：**

数组：

最好用于索引有语义，

最大优点：快速查询

链表：

用于索引没有语义

最大优点：动态





**在索引位置添加元素**需要找到前一节点pre，





**虚拟头结点**

为编写逻辑方便而设立，即使链表为空依然存在唯一一个虚拟头结点。

https://blog.csdn.net/qq_37999723/article/details/77376804





**删除操作**

在块内定义的引用被改变没有什么用？？？【改变引用的值只相当于指针的遍历？】



#### 链表时间复杂度分析



**添加操作     O(n)**

addLast(e)      O(n)

addFirst(e)      O(1)

add(index, e)    O(n/2) = O(n)





**删除操作            O(n)**

E removeFirst            O(1)

E removeLast             O(n)

E remove(index)        O(n/2) = O(n)







![image-20200704143221294](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200704143221294.png)





在增加和删除时只对表头操作和数组相比：时间复杂度相同，**但链表是动态数据结构，不会大量浪费内存空间。**





**链表栈**

O(1)

链表适合对链表头进行操作符合栈的特性



与之前（动态）数组栈相比

同一时间复杂度

链表栈在不停new节点，而数组栈则是扩充容量创建新数组转移花费时间，在不同电脑上表现出来的具体快慢可能不同。







**链表队列**

front指向第一个元素，tail指向最后一个元素

O(1)

链表尾只能作为队尾【插入，无法删除】



链表尾作为队尾，链表头作为队首



虚拟节点如何安排？？？



### 递归

将原来问题转化为更小的同一问题

![image-20200705173159077](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200705173159077.png)



注意递归函数的宏观语义

递归函数就是一个函数,完成一个功能



###**递归函数的宏观语义**

###**递归函数的微观过程**

递归函数相当于子过程的调用，使用系统栈记录每次调用的状态，通过子过程的返回值【化为更小同一问题】，返回得到原问题的解

![image-20200705184812777](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200705184812777.png)

觉得递归函数抽象是因为没有深入理解递归其实就是子过程的调用，而**具体的运算其实就是原问题转化为更小问题的运算**，例如递归的加法和转化为更小问题其实就是当前元素+剩余元素和。







**解决递归问题**【递归函数必有返回值】，**一定把握递归的宏观语义，即递归函数是干什么的【参数和返回值分别有什么用，尤其是返回值】，然后利用宏观语义结合最基本问题（最基本问题开始逐渐复杂如何得到问题的解）把原问题转化为更小的问题。**

####理解总结链表的递归

每一部分分为表头和另一部分，关键就在对于另一部分的表头的处理，删除操作是对删除另一部分的表头，添加操作是在另一部分的表头前添加。

链表递归的最小情况是节点为空

链表递归的更小情况是对下一节点进行操作

链表递归的宏观语义是对当前节点为表头的链表进行操作









![image-20200707180320131](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200707180320131.png)





#### 理解总结二分搜索树的递归

二分搜索树递归的最小情况是节点为空

二分搜索树递归的更小情况是对左子树，右子树分别进行操作。

二分搜索树递归的宏观语义是对以节点为根节点的二分搜索树进行(添加，遍历，删除)操作。





### 二分搜索树遍历



#### 前序遍历

![image-20200715105909768](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200715105909768.png)



#### 中序遍历

由小到大顺序排序





#### 后序遍历

利用子节点求解当前节点

为二分搜索树释放内存

树形问题：分治法，动态规划法，回溯法。







#### 深入理解二分搜索树的遍历

![image-20200715114237816](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200715114237816.png)

**三次访问节点的机会，选择在哪次进行真正操作就是各种遍历**



空指针异常在第二行

```java
/**
 * 宏观意义：无返回值删除最右节点
 * @param node
 */
private void removeMax(Node node) {

    

    if (node.right != null && node.right.right == null) {

        node.right = node.right.left;

    }

    size --;

    removeMax(node.right);

}
```



#### 删除节点

![image-20200804201054900](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200804201054900.png)







### 二分搜索树的顺序性



最大值和最小值



中序遍历



前驱和后继





## 集合

存放不重复元素的容器

二分搜索树是非常好的集合的底层结构。





![image-20200822093748349](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200822093748349.png)



满二叉树时【准确说是平衡二叉树时达到logn】，最差时退化成链表。





![image-20200822094002848](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200822094002848.png)





**多重集合**

元素可以重复的二分搜索树包装一层。





**有序集合和无序集合**

有序集合中的元素具有有序性-基于搜索树实现【查找较快】

无序集合中的元素具有无序性-基于哈希表实现【操作时间复杂度较小】











###映射

键和值一一对应的数据结构



非常容易使用二分搜索树和链表实现













![image-20200822092750266](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200822092750266.png)







**有序集合和无序集合**

有序集合中的元素具有有序性-基于搜索树实现【查找较快】

无序集合中的元素具有无序性-基于哈希表实现【操作时间复杂度较小】





**多重映射**

其中键可以重复





集合和映射转换

集合-映射【重定义集合中的元素是键值对，比较时用键比较，但还需添加操作】

映射-集合【值均为空，只考虑键，比较常见与上面相比】

直接在底层树中添加泛型【最常见】









## 优先队列

入队和出队操作和顺序无关，和优先级有关。





普通线性结构实现优先队列：入队O(1),出队O(n)

顺序线性结构实现优先队列：入队O(n),出队O(1)

使用堆结构实现优先队列：入队O(logn),出队O(logn)



## 堆

基本上所有O(logn)都是树的实现

归并排序O(nlogn)是形成了一颗隐形的树







### 二叉堆

二叉堆是一颗完全二叉树

最大堆（父节点大于任一子节点）

数组存储





**Heapfiy**

从最后一个非叶子结点开始进行下沉操作到根节点

【最后一个叶子结点求法：数组最后一个节点的父节点】

时间复杂度为O(n)

从空堆添加构造最大堆时间复杂度为O(n * logn)











**以二叉堆为底层的优先队列**

决定出队顺序的有方面：1.优先队列的优先级；2.优先队列最底层是最大堆还是最小堆





**n叉堆的n取几时效率最高？**





**索引堆**

根据索引检测到元素在堆中的位置





**广义队列**





![image-20200909172615797](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200909172615797.png)









# 线段树【Segment Tree】

适用于动态变化的问题【涂色，统计】例如：2017年注册用户的消费量

1.更新

2.查找

使用数组时间复杂度为n

线段树时间复杂度为logn





**完全二叉树**

线段树不是平衡二叉树



**平衡二叉树**

线段树，堆是平衡二叉树，

二分搜索树不是平衡二叉树





需要建立两个数组：一个是原数组，另一个是区间数组表示线段树

<img src="../images/image-20240520091231375.png" alt="image-20240520091231375" style="zoom:50%;" />





对于满二叉树

h层，一共有2^h-1个节点

最后一层（h-1层）有，有2^(h-1)个节点

最后一层的节点数大致等于前面所有节点之和

![image-20200926202002949](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200926202002949.png)

n代表所有元素之和，一般也就是叶子结点的数量。



很多时候4n空间会有浪费



**线段树的操作总是以l - r的范围内，查找范围为【queryL-queryR】返回统计值。**

```java

    /**
     * 在以treeIndex为根节点范围为【l-r】的线段树中查找范围为【queryL-queryR】返回统计值。
     * l和r其实比较固定，总是每个线段子树的从头到尾
     * @param treeIndex
     * @param l
     * @param r
     * @param queryL
     * @param queryR
     * @return
     */
    private E query(int treeIndex, int l, int r, int queryL, int queryR) {

        if (l == queryL && r == queryR) {
            return tree[treeIndex];
        }


        int mid = l +(r-l) / 2;
        int leftTreeIndex = leftChild(treeIndex);
        int rightTreeIndex = rightChild(treeIndex);

        if (queryR < mid + 1)

            return query(leftTreeIndex, l, mid + 1, queryL, queryR);


        if (queryL > mid + 1)
            return query(rightTreeIndex, mid + 1, r, queryL, queryR);


        return merger.merge(query(leftTreeIndex, l, mid + 1, queryL, queryR), query(rightTreeIndex, mid + 1, r , queryL, queryR));



    }


```





**线段树和后序遍历关系**



区域更新 -------- 懒惰更新【lazy数组记录未更新的节点】

动态区间





# Trie







![image-20200913200821662](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200913200821662.png)







## 并查集

1.一种不一样的树型结构【儿子指向父亲】

2.适合求解节点之间连接问题【数学集合的并集实现】





**QuickFind**[数组实现，每个元素存储的是最终的集合编号]

1.unionElements-------------O(n)

2.isConnected-----------------O(1)     find------------O(1){查找指定索引元素的集合编号}





**QuickUnion**【树形结构，数组实现，每个节点存储的是父亲节点集合编号】

O(h)复杂度，h为树的高度

1.unionElements-------------O(h)

2.isConnected-----------------O(h)     find------------O(logn){查找指定索引元素的集合编号}



在h特别大时，树型不稳定，复杂度变高，可能退化成链表【O(n)】





**基于Rank和路径压缩的并查集**

![image-20200919202003553](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200919202003553.png)





rank是排名，不是深度，不是高度。路径压缩后原来高度高的rank依然大，原来高度低的rank依然小。



find操作向上寻找某个节点的根节点时顺便进行路径压缩，不能在初始化时完成。



并查集一般用于融合的同时进行查找的操作



###并查集时间复杂度



![image-20200919213805477](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200919213805477.png)







**？？？**![image-20200919213855742](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200919213855742.png)







# AVL





**平衡二叉树**



![image-20200920091157459](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200920091157459.png)







### 维护平衡





维护平衡的时间：加入节点后，沿着节点向上维护平衡。【递归是从上到下，回溯时就从下到上，顺便维护平衡】



**都是描述根节点的下两个子节点，**

**两个以上的子节点能转化为两个子节点**



**LL**

**右旋转**

是指根节点的左节点的右节点为根的整棵树作为原先根节点的子树【无论树有多么复杂均适用】



![1600567724648](/Users/haozhipeng/Downloads/1600567724648.jpg)







**RR**

**左旋转**











**LR**

先对左节点进行左旋转，转化成LL，再进行RR旋转。















**RL**

先对右节点进行右旋转，转化成RR，再进行LL旋转。





# 红黑树

和二三树本质是相同的



## 二三树

1.满足二分搜索树的性质

2.绝对平衡的树



**插入节点**（不能插入到空节点）

节点的转换：四节点转换为二节点

插入节点肯定是一个二节点

1.插入节点为二节点：			转变为三节点

2.插入节点为三节点：			转变为三个二节点

3.插入节点为三节点，父节点为二节点：中间节点上移与父亲节点组成三节点

4.插入节点为三节点，父节点为三节点：先转换成三个二节点，然后上移成为四节点，四节点转换为3个二节点





## 红黑树

红节点为二三树的左节点，所有红节点都是向左倾斜的。

黑节点为二节点。

![image-20200921192407272](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200921192407272.png)







红黑树是保持“黑平衡”的二叉树

严格意义上，不是平衡二叉树。			最大高度为2logn(每一层都有红节点时)，最大高度差logn





### 红黑树的添加



每次添加的都是红色节点，对应二三树新添加的节点总是和已有节点融合在一起。











**左旋转**

在二节点中插入比当前节点大的节点，进行左旋转。

```java
Node right = node.right;
Node left = node.left;
right.left = node;
left = node.right;
// 现在根节点的颜色等于以前根节点颜色，
// 以前根节点颜色等于红色。
right = node.color;
node.color = RED;
```

可能出现两个颜色均为红色的节点，但左旋转只是子过程，后续有后续的处理。







**右旋转**

插入比两个节点还小的元素时，进行右旋转，对应二三树的临时四节点，进行颜色翻转

```java
// 现在根节点的颜色等于以前根节点颜色，
// 以前根节点颜色等于红色。
right = node.color;
node.color = RED;
```







**颜色翻转**

对应二三树中临时四节点，拆分成三个二节点【左右节点变为黑色，根节点向上融合变为红色。】



![image-20200922085937753](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200922085937753.png)





第二步的原型是根节点为黑色，右节点为红色，也可以成为图中根节点为红色，右节点为红色

因此进行左旋转



**每次都是并列的if语句，变换到一种形态后可以翻转。**









# 哈希表

键和索引映射  				O(1)查找

键------------索引【哈希函数】

同一个哈希值对应不同键--------------【哈希冲突】

哈希表充分体现了算法设计的经典思想---------------用空间换时间

1的空间 O(n)时间完成各种操作

999999999999的空间 O(1)时间完成各种操作

哈希表是空间和时间的平衡。





**构造哈希函数**

整数： 对素数取模；一般是哈希表的大小



![image-20201010215551313](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20201010215551313.png)

b是有多少个字符，比如字母有26个





**JAVA中的哈希函数**

返回的是一个整数，可正可负，

```java
hashCode(42) = 42;

hashCode(-42) = -42;

```

整数返回的是本身，是因为java也是模一个素数(哈希表长度)默认为1，要在哈希表中实现hashCode到索引的转换。



Object类默认有自己的哈希函数，根据创建对象地址转化成整形。



自己创建的类只覆盖hashcode()方法是不够的，hash值相等的两个类【哈希冲突】还需覆盖equals()方法。



equals方法作用

1.判断产生哈希冲突时【哈希值相同时】两个对象到底相同不相同

2.也可以判断哈希值不同的两个对象是不是相同的









### 链地址法

![image-20200925132448419](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200925132448419.png)





**动态空间处理**



![image-20200925133804086](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200925133804086.png)



固定地址空间不合理，需要resize

平均每个地址承载元素多过一定程度，即扩容 N / M >= upperTol

平均每个地址承载元素少过一定程度，即缩容 N / M <= lowerTol





### **哈希表复杂度分析**

![image-20200925134142372](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200925134142372.png)



**哈希表均摊复杂度为0(1)**

**牺牲了顺序性**



哈希表存在bug，红黑树的可比较性和哈希表的不可比较性

解决方法：java的链表到红黑树的转换。



**开放地址**

以上是封闭地址，每个空间只能包含哈希值相同的元素。

线性探测，平方探测，二次哈希

负载率大于一定时，**开放地址**需要扩容，复杂率合适，时间复杂度为0(1)

**再哈希法**


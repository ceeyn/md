

# 第零章、计算器概论

## 1.计算机硬件的五大单元

可主要分为三部分：输入单元，主机部分，输出单元，主机部分包括cpu（内部控制单元，算数逻辑单元）和主存储器。

![电脑的五大单元](http://linux.vbird.org/linux_basic/0105computers/computer02.gif)

cpu处理的资料完全来自主存储器。

## 2.cpu的架构

两种常见的CPU架构：

### 1.精简指令集（RISC）

精简指令集较为精简，指令的运行时间很短，执行的效能很好，做复杂的事情需要多个指令完成。

### 2.复杂指令集（CISC)

CISC微指令集的每个小指令都可以执行一些低阶硬件操作，指令多且复杂，花费时间长，AMD,Intel的x86架构

### 3.运作流程

![各元件运作](http://linux.vbird.org/linux_basic/0105computers/computer03.gif)

如果要由过去的经验来判断事情时，也要将经验(硬碟)挪到目前的记忆(主记忆体)当中，再交由CPU来判断喔！

### 4.计算机计算单位

- 容量单位

电脑对资料的判断主要依据有没有通电来记录资讯，所以理论上对于每一个纪录单位而言，它只认识0 与1 而已。0/1 这个二进位的的单位我们称为bit。但bit 实在太小了，所以在储存资料时每份简单的资料都会使用到8 个bits 的大小来记录，因此定义出byte 这个单位，他们的关系为：

1 Byte = 8 bits

| 进位制 | Kilo | Mega  | Giga  | Tera  | Peta  | Exa   | Zetta |
| ------ | ---- | ----- | ----- | ----- | ----- | ----- | ----- |
| 二进位 | 1024 | 1024K | 1024M | 1024G | 1024T | 1024P | 1024E |
| 十进位 | 1000 | 1000K | 1000M | 1000G | 1000T | 1000P | 1000E |

- 速度单位

CPU的运算速度常使用MHz 或者是GHz 之类的单位，这个Hz 其实就是秒分之一。而在网路传输方面，由于网路使用的是 bit 为单位，因此网路常使用的单位为Mbps 是Mbits per second，亦即是每秒多少Mbit。举例来说，大家常听到的20M/5M 光世代传输速度，如果转成档案容量的byte 时，其实理论最大传输值为：每秒2.5Mbyte/ 每秒625Kbyte的下载/上传速度喔！

### 5.个人电脑架构及相关元件

![Intel晶片架构](http://linux.vbird.org/linux_basic/0105computers/chipset_z87.jpg)

由于主机板是连结各元件的一个重要项目，因此在主机板上面沟通各部元件的晶片组设计优劣，就会影响效能不少喔！早期的晶片组通常分为两个桥接器来控制各元件的沟通，分别是：**(1)北桥：负责连结速度较快的CPU、主记忆体与显示卡界面等元件；(2)南桥：负责连接速度较慢的装置介面，包括硬碟、USB、网路卡等等。(晶片组的南北桥与三国的大小乔没有关系@_@)。**不过由于北桥最重要的就是CPU与主记忆体之间的桥接，因此目前的主流架构中，大多将北桥记忆体控制器整合到CPU封装当中了。所以上图你只会看到CPU而没有看到以往的北桥晶片喔！



我们前面谈到CPU内部含有微指令集，不同的微指令集会导致CPU工作效率的优劣。除了这点之外， CPU效能的比较还有什么呢？那就是**CPU的时脉了！什么是时脉呢？简单的说， 时脉就是CPU每秒钟可以进行的工作次数。所以时脉越高表示这颗CPU单位时间内可以作更多的事情。**举例来说，Intel的i7-4790 CPU时脉为3.6GHz，表示这颗CPU在一秒内可以进行3.6x10 9次工作，每次工作都可以进行少数的指令运作之意。



### 6.cpu的工作时脉：外频与倍频

早期的CPU 架构主要透过北桥来连结系统最重要的CPU、主记忆体与显示卡装置。因为所有的设备都得掉透过北桥来连结，因此每个设备的工作频率应该要相同。于是就有所谓的前端汇流排(FSB) 这个东西的产生。但因为CPU 的运算速度比其他的设备都要来的快，又为了要满足FSB 的频率，因此厂商就在CPU 内部再进行加速， 于是就有所谓的外频与倍频了。

总结来说，在早期的CPU设计中，所谓的外频指的是CPU与外部元件进行资料传输时的速度，倍频则是CPU内部用来加速工作效能的一个倍数，两者相乘才是CPU的时脉速度。例如Intel Core 2 E8400的内频为3.0GHz，而外频是333MHz，因此倍频就是9倍啰！(3.0G=333Mx9,其中1G=1000M)

超频问题：举例来说，像上述3.0GHz的CPU如果想要超频，可以将他的外频333MHz调整成为400MHz，但如此一来整个主机板的各个元件的运作频率可能都会被增加成原本的1.333倍(4 /3)，虽然CPU可能可以到达3.6GHz，但却因为频率并非正常速度，故可能会造成当机等问题。

但如此一来所有的资料都被北桥卡死了，北桥又不可能比CPU 更快，因此这家伙常常是系统效能的瓶颈。为了解决这个问题，新的CPU 设计中， 已经将记忆体控制器整合到CPU 内部，而连结CPU 与记忆体、显示卡的控制器的设计，在Intel部份使用QPI (Quick Path Interconnect) 与DMI技术，而AMD 部份则使用Hyper Transport 了，这些技术都可以让CPU 直接与主记忆体、显示卡等设备分别进行沟通，而不需要透过外部的连结晶片了。

因为现在没有所谓的北桥了(整合到CPU内)，因此，CPU的时脉设计就无须考虑得要同步的外频，只需要考量整体的频率即可。所以，如果你经常有查阅自己CPU时脉的习惯，当使用cpu-z ( [注9](http://linux.vbird.org/linux_basic/0105computers.php#ps9) )这个软体时，应该会很惊讶的发现到，怎么外频变成100MHz而倍频可以到达30以上！相当有趣呢！

### 7.**32位元与64位元的CPU与汇流排『宽度』**

CPU的各项资料通通得要来自于主记忆体。因此，如果主记忆体能提供给CPU的资料量越大的话，当然整体系统的效能应该也会比较快！那如何知道主记忆体能提供的资料量呢？此时还是得要藉由CPU内的记忆体控制晶片与主记忆体间的传输速度『前端汇流排速度(Front Side Bus, FSB)来说明。

与CPU的时脉类似的，主记忆体也是有其工作的时脉，这个时脉限制还是来自于CPU内的记忆体控制器所决定的。以图[0.2.1](http://linux.vbird.org/linux_basic/0105computers.php#chipset)为例， CPU内建的记忆体控制晶片对主记忆体的工作时脉最高可达到1600MHz。这只是工作时脉(每秒几次)。一般来说，每次时脉能够传输的资料量，大多为64位元，这个64位元就是所谓的『宽度』了！因此，在图[0.2.1](http://linux.vbird.org/linux_basic/0105computers.php#chipset)这个系统中，CPU可以从记忆体中取得的最快频宽就是1600MHz * 64bit = 1600MHz * 8 bytes = 12.8Gbyte/s。

与汇流排宽度相似的，CPU每次能够处理的资料量称为字组大小(word size)，字组大小依据CPU的设计而有32位元与64位元。我们现在所称的电脑是32或64位元主要是依据这个CPU解析的字组大小而来的！早期的32位元CPU中，因为CPU每次能够解析的资料量有限，因此由主记忆体传来的资料量就有所限制了。这也导致32位元的CPU最多只能支援最大到4GBytes的记忆体。

### 8.**超执行绪(Hyper-Threading, HT)**

在每一个CPU 内部将重要的暂存器(register) 分成两群， 而让程序分别使用这两群暂存器。也就是说，可以有两个程序『同时竞争CPU 的运算单元』，而非透过作业系统的多工切换！这一过程就会让CPU 好像『同时有两个核心』的模样！因此，虽然大部分i7 等级的CPU 其实只有四个实体核心，但透过HT 的机制， 则作业系统可以抓到八个核心！并且让每个核心逻辑上分离，就可以同时运作八个程序了。

### 9.记忆体

个人电脑的主记忆体主要元件为动态随机存取记忆体(Dynamic Random Access Memory, DRAM)，随机存取记忆体只有在通电时才能记录与使用，断电后资料就消失了。因此我们也称这种RAM为挥发性记忆体。

DRAM根据技术的更新又分好几代，而使用上较广泛的有所谓的SDRAM与DDR SDRAM两种。这两种记忆体的差别除了在于脚位与工作电压上的不同之外，DDR是所谓的双倍资料传送速度(Double Data Rate)，他可以在一次工作周期中进行两次资料的传送，感觉上就好像是CPU的倍频啦！所以传输频率方面比SDRAM还要好。新一代的PC大多使用DDR记忆体了。下表列出SDRAM与DDR SDRAM的型号与频率及频宽之间的关系。

| SDRAM/DDR | 型号      | 资料宽度(bit) | 内部时脉(MHz) | 频率速度 | 频宽(频率x宽度) |
| --------- | --------- | ------------- | ------------- | -------- | --------------- |
| SDRAM     | PC100     | 64            | 100           | 100      | 800MBytes/sec   |
| SDRAM     | PC133     | 64            | 133           | 133      | 1064MBytes/sec  |
| DDR       | DDR-266   | 64            | 133           | 266      | 2.1GBytes/sec   |
| DDR       | DDR-400   | 64            | 200           | 400      | 3.2GBytes/sec   |
| DDR       | DDR2-800  | 64            | 200           | 800      | 6.4GBytes/sec   |
| DDR       | DDR3-1600 | 64            | 200           | 1600     | 12.8GBytes/sec  |

###10.CPU等级

由于x86架构的CPU在Intel的Pentium系列(1993年)后就有不统一的脚位与设计，为了将不同种类的CPU规范等级， 所以就有i386,i586,i686等名词出现了。基本上，在Intel Pentium MMX与AMD K6年代的CPU称为i586等级， 而Intel Celeron与AMD Athlon(K7)年代之后的32位元CPU就称为i686等级。至于目前的64位元CPU则统称为x86_64等级。

###11.DRAM与SRAM

除了主记忆体之外，事实上整部个人电脑当中还有许许多多的记忆体存在喔！最为我们所知的就是CPU内的第二层快取记忆体。我们现在知道CPU的资料都是由主记忆体提供，但CPU到主记忆体之间还是得要透过记忆体控制器啊！如果某些很常用的程式或资料可以放置到CPU内部的话，那么CPU资料的读取就不需要跑到主记忆体重新读取了！这对于效能来说不就可以大大的提升了？这就是第二层快取的设计概念。第二层快取与主记忆体及CPU的关系如下图所示：

![记忆体相关性](http://linux.vbird.org/linux_basic/0105computers/computer07.gif)

图0.2.3、记忆体相关性

因为第二层快取(L2 cache)整合到CPU内部，因此这个L2记忆体的速度必须要CPU时脉相同。使用DRAM是无法达到这个时脉速度的，此时就需要静态随机存取记忆体(Static Random Access Memory, SRAM)的帮忙了。SRAM在设计上使用的电晶体数量较多，价格较高，且不易做成大容量，不过由于其速度快， 因此整合到CPU内成为快取记忆体以加快资料的存取是个不错的方式喔！新一代的CPU都有内建容量不等的L2快取在CPU内部， 以加快CPU的运作效能。

###12.唯读记忆体(ROM)

主机板上面的元件是非常多的，而每个元件的参数又具有可调整性。举例来说，CPU与记忆体的时脉是可调整的； 而主机板上面如果有内建的网路卡或者是显示卡时，该功能是否要启动与该功能的各项参数， 是被记录到主机板上头的一个称为CMOS的晶片上，这个晶片需要借着额外的电源来发挥记录功能， 这也是为什么你的主机板上面会有一颗电池的缘故。

那CMOS内的资料如何读取与更新呢？还记得你的电脑在开机的时候可以按下[Del]按键来进入一个名为BIOS的画面吧？ BIOS(Basic Input Output System)是一套程式，这套程式是写死到主机板上面的一个记忆体晶片中，这个记忆体晶片在没有通电时也能够将资料记录下来，那就是唯读记忆体(Read Only Memory, ROM)。ROM是一种非挥发性的记忆体。另外，BIOS对于个人电脑来说是非常重要的，因为他是系统在开机的时候首先会去读取的一个小程式喔！

另外，韧体(firmware)( [注12](http://linux.vbird.org/linux_basic/0105computers.php#ps12) )很多也是使用ROM来进行软体的写入的。韧体像软体一样也是一个被电脑所执行的程式，然而他是对于硬体内部而言更加重要的部分。例如BIOS就是一个韧体， BIOS虽然对于我们日常操作电脑系统没有什么太大的关系，但是他却控制着开机时各项硬体参数的取得！所以我们会知道很多的硬体上头都会有ROM来写入韧体这个软体。

BIOS对电脑系统来讲是非常重要的，因为他掌握了系统硬体的详细资讯与开机设备的选择等等。但是电脑发展的速度太快了，因此BIOS程式码也可能需要作适度的修改才行，所以你才会在很多主机板官网找到BIOS的更新程式啊！但是BIOS原本使用的是无法改写的ROM ，因此根本无法修正BIOS程式码！为此，现在的BIOS通常是写入类似快闪记忆体(flash)或EEPROM

### 13.显示卡

显示卡又称为VGA(Video Graphics Array)，他对于图形影像的显示扮演相当关键的角色。一般对于图形影像的显示重点在于解析度与色彩深度，因为每个图像显示的颜色会占用掉记忆体，因此显示卡上面会有一个记忆体的容量，这个显示卡记忆体容量将会影响到你的萤幕解析度与色彩深度的喔！

除了显示卡记忆体之外，现在由于三度空间游戏(3D game)与一些3D动画的流行，因此显示卡的『运算能力』越来越重要。一些3D的运算早期是交给CPU去运作的，但是CPU并非完全针对这些3D来进行设计的，而且CPU平时已经非常忙碌了呢！所以后来显示卡厂商直接在显示卡上面嵌入一个3D加速的晶片，这就是所谓的GPU称谓的由来。

显示卡主要也是透过CPU的控制晶片来与CPU、主记忆体等沟通。如前面提到的，对于图形影像(尤其是3D游戏)来说，显示卡也是需要高速运算的一个元件，所以资料的传输也是越快越好！因此显示卡的规格由早期的PCI导向AGP，近期AGP又被PCI-Express规格所取代了。如前面[华硕主机板](http://linux.vbird.org/linux_basic/0105computers.php#asus_z97_ar)图示当中看到的就是PCI-Express的插槽。这些插槽最大的差异就是在资料传输的频宽了！

| 规格         | 宽度    | 速度     | 频宽          |
| ------------ | ------- | -------- | ------------- |
| PCI          | 32 bits | 33 MHz   | 133 MBytes/s  |
| PCI 2.2      | 64 bits | 66 MHz   | 533 MBytes/s  |
| PCI-X        | 64 bits | 133 MHz  | 1064 MBytes/s |
| AGP 4x       | 32 bits | 66x4 MHz | 1066 MBytes/s |
| AGP 8x       | 32 bits | 66x8 MHz | 2133 MBytes/s |
| PCIe 1.0 x1  | 无      | 无       | 250 MBytes/s  |
| PCIe 1.0 x8  | 无      | 无       | 2 GBytes/s    |
| PCIe 1.0 x16 | 无      | 无       | 4 GBytes/s    |

比较特殊的是，PCIe(PCI-Express)使用的是类似管线的概念来处理，在PCIe第一版(PCIe 1.0)中，每条管线可以具有250MBytes/s的频宽效能，管线越多(通常设计到x16管线)则总频宽越高！另外，为了提升更多的频宽，因此PCIe还有进阶版本，目前主要的版本为第三版，相关的频宽如下：( [注15](http://linux.vbird.org/linux_basic/0105computers.php#ps15) )

| 规格     | 1x频宽     | 16x频宽    |
| -------- | ---------- | ---------- |
| PCIe 1.0 | 250MByte/s | 4GByte/s   |
| PCIe 2.0 | 500MByte/s | 8GByte/s   |
| PCIe 3.0 | ~1GByte/s  | ~16GByte/s |
| PCIe 4.0 | ~2GByte/s  | ~32GByte/s |

## 3.硬盘

### 1.硬盘的物理组成

![硬碟物理构造](http://linux.vbird.org/linux_basic/0105computers/hard_disk01.jpg)

实际运作时，主轴马达让磁碟盘转动，然后机械手臂可伸展让读取头在磁碟盘上头进行读写的动作。

![磁碟盘上的资料格式](http://linux.vbird.org/linux_basic/0105computers/Disktructure.jpg)

这个小区块就是磁碟的最小物理储存单位，称之为磁区(sector)，那同一个同心圆的磁区组合成的圆就是所谓的磁轨(track)。由于磁碟里面可能会有多个磁碟盘，因此在所有磁碟盘上面的同一个磁轨可以组合成所谓的磁柱(cylinder)。

### 2.传输界面

- SATA介面

如同[华硕主机板图示](http://linux.vbird.org/linux_basic/0105computers.php#asus_z97_ar)右下方所示为SATA硬碟的连接介面插槽。这种插槽所使用的排线比较窄小，而且每个装置需要使用掉一条SATA线。因为SATA线比较窄小之故，所以对于安装与机壳内的通风都比较好！因此原本的IDE粗排线界面就被SATA取代了！

前主流都是使用SATA3这个界面速度可达600Mbyte/s的界面！

| 版本     | 频宽(Gbit/s) | 速度(Mbyte/s) |
| -------- | ------------ | ------------- |
| SATA 1.0 | 1.5          | 150           |
| SATA 2.0 | 3            | 300           |
| SATA 3.0 | 6            | 600           |

- SAS介面

早期工作站或大型大脑上面，为了读写速度与稳定度，因此在这样的机器上面，大多使用的是SCSI 这种高阶的连接介面。不过这种介面的速度后来被SATA 打败了！但是SCSI 有其值得开发的功能，因此后来就有串列式SCSI (Serial Attached SCSI, SAS) 的发展。这种介面的速度比SATA 来的快，而且连接的SAS 硬碟的磁碟盘转速与传输的速度也都比SATA 硬碟好！

| 版本  | 频宽(Gbit/s) | 速度(Mbyte/s) |
| ----- | ------------ | ------------- |
| SAS 1 | 3            | 300           |
| SAS 2 | 6            | 600           |
| SAS 3 | 12           | 1200          |

- USB介面

如果你的磁碟是外接式的界面，那么很可能跟主机板连结的就是USB 这种界面了！这也是目前(2015) 最常见到的外接式磁碟界面了。不过传统的USB 速度挺慢的，即使是比较慢的传统硬碟，其传输率大概都还有80~120Mbytes/s ，但传统的USB 2.0 仅有大约60Mbytes/s 的理论传输率， 通常实做在主机板上面的连接口，竟然都仅有30~40 Mbyte/s 而已呢！实在发挥不出磁碟的性能啊！

为了改善USB的传输率，因此新一代的USB 3.0速度就快很多了！据说还有更新的USB 3.1正在发展中！这几代版本的频宽与速度制表如下( [注19](http://linux.vbird.org/linux_basic/0105computers.php#ps19) )：

| 版本    | 频宽(Mbit/s) | 速度(Mbyte/s) |
| ------- | ------------ | ------------- |
| USB 1.0 | 12           | 1.5           |
| USB 2.0 | 480          | 60            |
| USB 3.0 | 5G           | 500           |
| USB 3.1 | 10G          | 1000          |

###3.固态硬碟(Solid State Disk, SSD)

传统硬碟有个很致命的问题，就是需要驱动马达去转动磁碟盘～这会造成很严重的磁碟读取延迟！想想看，你得要知道资料在哪个磁区上面，然后再命令马达开始转， 之后再让读取头去读取正确的资料。另外，如果资料放置的比较离散(磁区分布比较广又不连续)，那么读写的速度就会延迟更明显！速度快不起来。因此， 后来就有厂商拿快闪记忆体去制作成高容量的设备，这些设备的连接界面也是透过SATA 或SAS，而且外型还做的跟传统磁碟一样！所以， 虽然这类的设备已经不能称为是磁碟(因为没有读写头与磁碟盘啊！都是记忆体！)。但是为了方便大家称呼，所以还是称为磁碟！只是跟传统磁碟(Hard Disk Drive, HDD) 不同， 就称为固态硬碟(Solid State Disk 或Solid State Driver, SSD)。

固态硬碟最大的好处是，它没有马达不需要转动，而是透过记忆体直接读写的特性，因此除了没资料延迟且快速之外，还很省电！

## 4.作业系统

###1.作业系统核心(Kernel)

作业系统(Operating System, OS)其实也是一组程式，这

组程式的重点在于管理电脑的所有活动以及驱动系统中的所有硬体。

###2.系统呼叫(System Call)

既然我的硬体都是由核心管理，那么如果我想要开发软体的话，自然就得要去参考这个核心的相关功能！唔！如此一来不是从原本的参考硬体函数变成参考核心功能，还是很麻烦啊！有没有更简单的方法啊！

为了解决这个问题，作业系统通常会提供一整组的开发介面给工程师来开发软体！工程师只要遵守该开发介面那就很容易开发软体了！

![作业系统的角色](http://linux.vbird.org/linux_basic/0105computers/os_01.gif)



# 第一章、linux是什么和如何学习

## 1.linux是什么

linux是操作系统，不包括应用程序（系统呼叫与核心层）



## 2.unix的历史

**1.兼容分时系统（ctss）：**



![早期主機與終端機的相關性圖示](http://linux.vbird.org/linux_basic/0110whatislinux/0110whatislinux_2.jpg)

**2.Ken Thompson以汇编语言写出的核心程序-------unics**

**两个重要概念：**

**（1）所有程序或系统装置都是文件**

**（2）不管建构编译器还是附属文件，所有目的都是有效完成目标**

**3.unics被以c语言改写成unix**（早期的unix仅用于工作站）

**4.x86的minix**，unix不提供给学生，谭宁邦教授开发出来用于教育，收费的。

**5.GNU计划与FSF基金会的成立**

（1）GNU计划推展（rms想建立一个自由，开放的unix操作系统）

GNU C Complier(gcc):rms为gnu打开知名度写的，通过emacs改写的

（2）fsf的成立

gnu c library（glibc）：c函数库

bash shell：操作系统基本接口

**6.gnu通用公共许可证：gpl**

**7.xfree86计划： x window system+free+x86**

**8.linux诞生：参照posix规范（unix软件运行标准）**

**9.linux核心版本**

```
3.10.0-123.el7.x86_64
主版本.次版本.釋出版本-修改版本
```

（1）主线版本，长期维护版本

从3.0开始（之前是奇偶分版本）

（2）linux distrubution

![Linux可完整安裝發佈套件](http://linux.vbird.org/linux_basic/0110whatislinux/distribution.gif)

（2）linux distrubution支持标准：Linux Standard Base (LSB)与File system Hierarchy Standard (FHS)

| RPM 軟體管理 | DPKG 軟體管理                          | 其他未分類              |        |
| ------------ | -------------------------------------- | ----------------------- | ------ |
| 商業公司     | RHEL (Red Hat 公司) SuSE (Micro Focus) | Ubuntu (Canonical Ltd.) |        |
| 社群單位     | Fedora CentOS OpenSuSE                 | Debian B2D              | Gentoo |

社群直接把新功能放入，可能不稳定，商业版测试稳定后才会加入，所以建议使用商业版当服务器，社群版当个人计算机









# 第二章、主机规划与磁碟分割

## 2.1.3 各硬体装置在Linux中的档名

**在Linux系统中，每个装置都被当成一个档案来对待**

| 装置                | 装置在Linux内的档名                                          |
| ------------------- | ------------------------------------------------------------ |
| SCSI/SATA/USB硬碟机 | /dev/sd[ap]                                                  |
| USB快闪碟           | /dev/sd[ap] (与SATA相同)                                     |
| VirtI/O界面         | /dev/vd[ap] (用于虚拟机器内)                                 |
| 软碟机              | /dev/fd[0-1]                                                 |
| 印表机              | /dev/lp[0-2] (25针印表机) /dev/usb/lp[0-15] (USB介面)        |
| 滑鼠                | /dev/input/mouse[0-15] (通用) /dev/psaux (PS/2界面) /dev/mouse (当前滑鼠) |
| CDROM/DVDROM        | /dev/scd[0-1] (通用) /dev/sr[0-1] (通用，CentOS较常见) /dev/cdrom (当前CDROM) |
| 磁带机              | /dev/ht0 (IDE界面) /dev/st0 (SATA/SCSI界面) /dev/tape (当前磁带) |
| IDE硬碟机           | /dev/hd[ad] (旧式系统才有)                                   |



## MSDOS(MBR) 与GPT 磁碟分割表(partition table)

MBR(Master Boot Record, 主要开机纪录区) 的方式来处理开机管理程式与分割表！而开机管理程式纪录区与分割表则通通放在磁碟的第一个磁区， 这个磁区通常是512bytes 的大小(旧的磁碟磁区都是512bytes 喔！)，所以说，第一个磁区512bytes 会有这两个资料：

- 主要开机记录区(Master Boot Record, MBR)：可以安装开机管理程式的地方，有446 bytes
- 分割表(partition table)：记录整颗硬碟分割的状态，有64 bytes

由于分割表所在区块仅有64 bytes容量，因此最多仅能有四组记录区，每组记录区记录了该区段的启始与结束的磁柱号码。

**主要(Primary)或延伸(Extended)分割槽：**

- 其实所谓的『分割』只是针对那个64 bytes的分割表进行设定而已！
- 硬碟预设的分割表仅能写入四组分割资讯
- 这四组分割资讯我们称为主要(Primary)或延伸(Extended)分割槽
- 分割槽的最小单位『通常』为磁柱(cylinder)
- 当系统要写入磁碟时，一定会参考磁碟分割表，才能针对某个分割槽进行资料的处理



**MBR 主要分割、延伸分割与逻辑分割的特性**我们作个简单的定义啰：

- 主要分割与延伸分割最多可以有四笔(硬碟的限制)
- 延伸分割最多只能有一个(作业系统的限制)
- 逻辑分割是由延伸分割持续切割出来的分割槽；
- 能够被格式化后，作为资料存取的分割槽为主要分割与逻辑分割。延伸分割无法格式化；
- 逻辑分割的数量依作业系统而不同，在Linux系统中SATA硬碟已经可以突破63个以上的分割限制；



**GUID partition table, GPT磁碟分割表(**

 GPT使用了34个LBA区块来纪录分割资讯！同时与过去MBR仅有一的区块，被干掉就死光光的情况不同， GPT除了前面34个LBA之外，整个磁碟的最后33个LBA也拿来作为另一个备份！这样或许会比较安全些吧！详细的结构有点像底下的模样





![GPT 分割表的结构示意图](http://linux.vbird.org/linux_basic/0130designlinux/gpt_partition_1.jpg)







- LBA0 (MBR 相容区块)

  与MBR模式相似的，这个相容区块也分为两个部份，一个就是跟之前446 bytes相似的区块，储存了第一阶段的开机管理程式！而在原本的分割表的纪录区内，这个相容模式仅放入一个特殊标志的分割，用来表示此磁碟为GPT格式之意。而不懂GPT分割表的磁碟管理程式，就不会认识这颗磁碟，除非用户有特别要求要处理这颗磁碟，否则该管理软体不能修改此分割资讯，进一步保护了此磁碟喔！

- LBA1 (GPT 表头纪录)

  这个部份纪录了分割表本身的位置与大小，同时纪录了备份用的GPT 分割(就是前面谈到的在最后34 个LBA 区块) 放置的位置， 同时放置了分割表的检验机制码(CRC32 )，作业系统可以根据这个检验码来判断GPT 是否正确。若有错误，还可以透过这个纪录区来取得备份的GPT(磁碟最后的那个备份区块) 来恢复GPT 的正常运作！

- LBA2-33 (实际纪录分割资讯处)

  从LBA2区块开始，每个LBA都可以纪录4笔分割纪录，所以在预设的情况下，总共可以有4*32 = 128笔分割纪录喔！因为每个LBA有512bytes，因此每笔纪录用到128 bytes的空间，除了每笔纪录所需要的识别码与相关的纪录之外，GPT在每笔纪录中分别提供了64bits来记载开始/结束的磁区号码，因此，GPT分割表对于单一分割槽来说，他的最大容量限制就会在『 2 64 * 512bytes = 2 63 * 1Kbytes = 2 33 *TB = 8 ZB 』，要注意1ZB = 2 30 TB啦！你说有没有够大了？







**BIOS 搭配MBR/GPT 的开机流程**



开机流程到作业系统之前的动作应该是这样的：

1. **BIOS**：开机主动执行的韧体，会认识第一个可开机的装置；
2. **MBR**：第一个可开机装置的第一个磁区内的主要开机记录区块，内含开机管理程式；
3. **开机管理程式(boot loader)**：一支可读取核心档案来执行的软体；
4. **核心档案**：开始作业系统的功能...



**UEFI BIOS搭配GPT开机的流程**

| 比较项目               | 传统BIOS                                                   | UEFI               |
| ---------------------- | ---------------------------------------------------------- | ------------------ |
| 使用程式语言           | 组合语言                                                   | C 语言             |
| 硬体资源控制           | 使用中断(IRQ)管理 不可变的记忆体存取 不可变得输入/输出存取 | 使用驱动程式与协定 |
| 处理器运作环境         | 16 位元                                                    | CPU 保护模式       |
| 扩充方式               | 透过IRQ 连结                                               | 直接载入驱动程式   |
| 第三方厂商支援         | 较差                                                       | 较佳且可支援多平台 |
| 图形化能力             | 较差                                                       | 较佳               |
| 内建简化作业系统前环境 | 不支援                                                     | 支援               |

###档案系统与目录树的关系(挂载)

所谓的『挂载』就是利用一个目录当成进入点，将磁碟分割槽的资料放置在该目录下；也就是说，进入该目录就可以读取该分割槽的意思。这个动作我们称为『挂载』，那个进入点的目录我们称为『挂载点』。





# 第三章、安装CentOS7.x

**磁碟分割的配置**



| 所需目录/装置 | 磁碟容量 | 档案系统 | 分割格式 |
| ------------- | -------- | -------- | -------- |
| BIOS boot     | 2MB      | 系统自订 | 主分割   |
| /boot         | 1GB      | xfs      | 主分割   |
| /             | 10GB     | xfs      | LVM 方式 |
| /home         | 5GB      | xfs      | LVM 方式 |
| swap          | 1GB      | swap     | LVM 方式 |



**检查表单：**
最后，你可以使用底下的表格来检查一下，你要安装的资料与实际的硬体是否吻合喔：

| 是与否，或详细资讯 | 细部项目                                                     |
| ------------------ | ------------------------------------------------------------ |
| 是, DVD版          | 01. 是否已下载且烧录所需的Linux distribution？(DVD或CD)      |
| CentOS 7.1, x64    | 02. Linux distribution的版本为何？(如CentOS 7.1 x86_64版本)  |
| x64                | 03. 硬体等级为何(如i386, x86_64, SPARC等等，以及DVD/CD-ROM)  |
| 是, 均为x86_64     | 04. 前三项安装媒体/作业系统/硬体需求，是否吻合？             |
| 是                 | 05. 硬碟资料是否可以全部被删除？                             |
| 已确认分割方式     | 06. Partition是否做好确认(包括/与swap等容量)                 |
|                    | 硬碟数量: 1颗40GB硬碟，并使用GPT分割表 BIOS boot (2MB) /boot (1GB) / (10GB) /home (5GB) swap (1GB) |
| 有，使用VirtI/O    | 07. 是否具有特殊的硬体装置(如SCSI磁碟阵列卡等)               |
| CentOS 已内建      | 08. 若有上述特殊硬体，是否已下载驱动程式？                   |
| grub2, MBR         | 09. 开机管理程式与安装的位置为何？                           |
| 未取得IP参数       | 10. 网路资讯(IP参数等等)是否已取得？                         |
|                    | 未取得IP的情况下，可以套用如下的IP参数： 是否使用DHCP：无 IP:192.168.1.100 子遮罩网路：255.255.255.0 主机名称：study.centos.vbird |
| Server with X      | 11. 所需要的软体有哪些？                                     |





































# 七.linux磁盘与文件管理系统

**磁盘文件名**

![image-20200113173009084](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20200113173009084.png)





## 文件系统特性

windows 98以前的微软作业系统主要利用的档案系统是FAT (或FAT16)，windows 2000以后的版本有所谓的NTFS档案系统，至于Linux的正统档案系统则为Ext2 (Linux second extended file system , ext2fs )这一个。



档案系统通常会将这两部份的资料分别存放在不同的区块，权限与属性放置到inode中，至于实际资料则放置到data block区块中。



- superblock：记录此filesystem 的整体资讯，包括inode/block的总量、使用量、剩余量， 以及档案系统的格式与相关资讯等；
- inode：记录档案的属性，一个档案占用一个inode，同时记录此档案的资料所在的block 号码；
- block：实际记录档案的内容，若档案太大时，会占用多个block 。

###索引式档案系统(indexed allocation)



![inode/block 资料存取示意图](http://linux.vbird.org/linux_basic/0230filesystem/filesystem-1.jpg)







###FAT

![FAT档案系统资料存取示意图](http://linux.vbird.org/linux_basic/0230filesystem/filesystem-2.jpg)

每个block号码都记录在前一个block当中





###EXT2

![ext2档案系统示意图](http://linux.vbird.org/linux_basic/0230filesystem/ext2_filesystem.jpg)



多个区块群组(block group) 的，每个区块群组都有独立的 inode/block/superblock 系统。

档案系统最前面有一个开机磁区(boot sector)，这个开机磁区可以安装开机管理程式，





### block

- 原则上，block 的大小与数量在格式化完就不能够再改变了(除非重新格式化)；
- 每个block 内最多只能够放置一个档案的资料；
- 承上，如果档案大于block 的大小，则一个档案会占用多个block 数量；
- 承上，若档案小于block ，则该block 的剩余容量就不能够再被使用了(磁碟空间会浪费)。





### inode

- 该档案的存取模式(read/write/excute)；
- 该档案的拥有者与群组(owner/group)；
- 该档案的容量；
- 该档案建立或状态改变的时间(ctime)；
- 最近一次的读取时间(atime)；
- 最近修改的时间(mtime)；
- 定义档案特性的旗标(flag)，如SetUID...；
- 该档案真正内容的指向(pointer)；

- 每个inode 大小均固定为128 bytes (新的ext4 与xfs 可设定到256 bytes)；
- 每个档案都仅会占用一个inode 而已；
- 承上，因此档案系统能够建立的档案数量与inode 的数量有关；
- 系统读取档案时需要先找到inode，并分析inode 所记录的权限与使用者是否符合，若符合才能够开始实际读取 block 的内容。

**inode 记录block 号码的区域定义为12个直接，一个间接, 一个双间接与一个三间接记录区。**

![inode 结构示意图](http://linux.vbird.org/linux_basic/0230filesystem/inode.jpg)







### Superblock (超级区块)

- block 与inode 的总量；
- 未使用与已使用的inode / block 数量；
- block 与inode 的大小(block 为1, 2, 4K，inode 为128bytes 或256bytes)；
- filesystem 的挂载时间、最近一次写入资料的时间、最近一次检验磁碟(fsck) 的时间等档案系统的相关资讯；
- 一个valid bit 数值，若此档案系统已被挂载，则valid bit 为0 ，若未被挂载，则valid bit 为1 。



### **block bitmap (区块对照表)**





### **inode bitmap (inode 对照表)**







## 与目录树的关系

目录的内容在记录档名，一般档案才是实际记录资料内容的地方。





- 目录

当我们在Linux下的档案系统建立一个目录时，档案系统会分配一个inode与至少一块block给该目录。其中，inode记录该目录的相关权限与属性，并可记录分配到的那块block号码；而block则是记录在这个目录下的档名与该档名占用的inode号码资料。



**/etc/passwd 有关的目录与档案资料如上表所示，该档案的读取流程为**

1. 的inode：
   透过挂载点的资讯找到inode号码为128的根目录inode，且inode规范的权限让我们可以读取该block的内容(有r与x) ；

   

2. /的block：
   经过上个步骤取得block的号码，并找到该内容有etc/目录的inode号码(33595521)；

   

3. etc/的inode：
   读取33595521号inode得知dmtsai具有r与x的权限，因此可以读取etc/的block内容；

   

4. etc/的block：
   经过上个步骤取得block号码，并找到该内容有passwd档案的inode号码(36628004)；

   

5. passwd的inode：
   读取36628004号inode得知dmtsai具有r的权限，因此可以读取passwd的block内容；

   

6. passwd的block：
   最后将该block内容的资料读出来。





## 7.1.7 挂载点的意义(mount point)



挂载点一定是目录，该目录为进入该档案系统的入口。 因此并不是你有任何档案系统都能使用，必须要『挂载』到目录树的某个目录后，才能够使用该档案系统的。





**Linux VFS (Virtual Filesystem Switch)**

使用者并不需要知道每个partition 上头的 filesystem 是什么～ VFS 会主动的帮我们做好读取的动作呢～

![VFS 档案系统的示意图](http://linux.vbird.org/linux_basic/0230filesystem/centos7_vfs.gif)





## 7.2.2 实体连结与符号连结： ln



**Hard Link (实体连结, 硬式连结或实际连结)**

![实体连结的档案读取示意图](http://linux.vbird.org/linux_basic/0230filesystem/hard_link1.gif)

将任何一个『档名』删除，其实inode与block都还是存在的！ 此时你可以透过另一个『档名』来读取到正确的档案资料喔！此外，不论你使用哪个『档名』来编辑，最终的结果都会写入到相同的inode与block中，因此均能进行资料的修改哩！不会占用掉inode与block

hard link 是有限制的：

- 不能跨Filesystem；
- 不能link 目录。



**Symbolic Link (符号连结，亦即是捷径)**

![符号连结的档案读取示意图](http://linux.vbird.org/linux_basic/0230filesystem/symbolic_link1.gif)

Symbolic Link与Windows的捷径可以给他划上等号，由Symbolic link所建立的档案为一个独立的新的档案，所以会占用掉inode与block



**关于目录的link 数量：**

新的目录的link数为2 ，而上层目录的link数则会增加1





# 第十一章、正规表示法与文件格式化处理

正规表示法就是处理字串的方法，他是以行为单位来进行字串的处理行为， 正规表示法透过一些特殊符号的辅助，可以让使用者轻易的达到『搜寻/删除/取代』某特定字串的处理程序

正规表示法基本上是一种『表示法』，只要工具程式支援这种表示法，那么该工具程式就可以用来作为正规表示法的字串处理之用。 例如vi, grep, awk ,sed等等工具，因为她们有支援正规表示法，所以，这些工具就可以使用正规表示法的特殊字元来进行字串的处理。但例如cp, ls等指令并未支援正规表示法，所以就只能使用[bash自己本身的万用字元](http://linux.vbird.org/linux_basic/0320bash.php#settings_wildcard)而已。





## 11.2 基础正规表示法

不同语系的编码资料并不相同，所以就会造成资料撷取结果的差异了。举例来说，在英文大小写的编码顺序中，zh_TW.big5及C这两种语系的输出结果分别如下：

- LANG=C 时：0 1 2 3 4 ... ABCD ... Z abcd ...z
- LANG=zh_TW 时：0 1 2 3 4 ... a A b B c C d D ... z Z



| 特殊符号   | 代表意义                                                   |
| ---------- | ---------------------------------------------------------- |
| [:alnum:]  | 代表英文大小写字元及数字，亦即0-9, AZ, az                  |
| [:alpha:]  | 代表任何英文大小写字元，亦即AZ, az                         |
| [:blank:]  | 代表空白键与[Tab] 按键两者                                 |
| [:cntrl:]  | 代表键盘上面的控制按键，亦即包括CR, LF, Tab, Del.. 等等    |
| [:digit:]  | 代表数字而已，亦即0-9                                      |
| [:graph:]  | 除了空白字元(空白键与[Tab] 按键) 外的其他所有按键          |
| [:lower:]  | 代表小写字元，亦即az                                       |
| [:print:]  | 代表任何可以被列印出来的字元                               |
| [:punct:]  | 代表标点符号(punctuation symbol)，亦即：" ' ? ! ; : # $... |
| [:upper:]  | 代表大写字元，亦即AZ                                       |
| [:space:]  | 任何会产生空白的字元，包括空白键, [Tab], CR 等等           |
| [:xdigit:] | 代表16 进位的数字类型，因此包括： 0-9, AF, af 的数字与字元 |



###搜寻特定字串

搜寻特定字串很简单吧？假设我们要从刚刚的档案当中取得the 这个特定字串，最简单的方式就是这样：

```
[dmtsai@study ~]$ grep -n 'the' regular_express.txt 
```



『反向选择』呢？也就是说，当该行没有'the'这个字串时才显示在萤幕上，那就直接使用：

```
[dmtsai@study ~]$ grep -vn 'the' regular_express.txt 
```



取得不论大小写的the 这个字串，则：

```
[dmtsai@study ~]$ grep -in 'the' regular_express.txt 
```







### **中括号[] 来搜寻集合字元**

搜寻test 或taste 这两个单字时，可以发现到，其实她们有共通的't?st' 存在～这个时候，我可以这样来搜寻：

```
[dmtsai@study ~]$ grep -n 't[ae]st' regular_express.txt 
```



其实[]里面不论有几个字元，他都仅代表某『一个』字元，所以，上面的例子说明了，我需要的字串是『tast』或『test』两个字串而已！而如果想要搜寻到有oo的字元时，则使用：

```
[dmtsai@study ~]$ grep -n 'oo' regular_express.txt 
```



###**行首与行尾字元^ $**

让the 只在行首列出呢？这个时候就得要使用定位字元了！我们可以这样做：

```
[dmtsai@study ~]$ grep -n '^the' regular_express.txt 
```

**^符号，在字元集合符号(括号[])之内与之外是不同的！在[]内代表『反向选择』，在[]之外则代表定位在行首的意义！**





Windows的断行字元(^M$) ，而正常的Linux应该仅有第10行显示的那样($) 。所以啰，那个.自然就不是紧接在$之前喔！也就捉不到5~9行了！这样可以了解^与$的意义吗？好了，先不要看底下的解答，自己想一想，那么如果我想要找出来，哪一行是『空白行』，也就是说，该行并没有输入任何资料，该如何搜寻？

```
[dmtsai@study ~]$ grep -n '^$' regular_express.txt
```





###**任意一个字元. 与重复字元 \***

[万用字元*](http://linux.vbird.org/linux_basic/0320bash.php#settings_wildcard)可以用来代表任意(0或多个)字元，但是正规表示法并不是万用字元，两者之间是不相同的！至于正规表示法当中的『 . 』则代表『绝对有一个任意字元』的意思！这两个符号在正规表示法的意义如下：

- . (小数点)：代表『一定有一个任意字元』的意思；
- \* (星星号)：代表『重复前一个字元， 0 到无穷多次』的意思，为组合形态



 \* 代表的是『重复0个或多个前面的RE字符』的意义，因此，『o*』代表的是：『拥有空字元或一个o以上的字元』需要『至少两个o 以上的字串』时，就需要ooo*



g....g的需求呢？呵呵！就利用任意一个字元『.』啊！亦即是：『g.*g』的作法，因为*可以是0或多个重复前面的字符，而.是任意字元，所以： 『.*就代表零个或多个任意字元』的意思啦！

```
[dmtsai@study ~]$ grep -n 'g.*g' regular_express.txt 
```



###**限定连续RE 字符范围{}**

根据正规表示法的处理原则，要让{生效，得要加上反斜线，亦即使用\{才能成功的让限定连续RE字符范围的功能生效喔！ 至于{}的语法是这样的，假设我要找到两个o的字串，可以是：

```
[dmtsai@study ~]$ grep -n 'o\{2\}' regular_express.txt 
```



要找出g 后面接2 到5 个o ，然后再接一个g 的字串，他会是这样：

```
[dmtsai@study ~]$ grep -n 'go\{2,5\}g' regular_express.txt 
```





## 基础正规表示法字符汇整(characters)

| RE 字符 | 意义与范例                                                   |
| ------- | ------------------------------------------------------------ |
| ^word   | 意义：待搜寻的字串(word)在行首！ 范例：搜寻行首为#开始的那一行，并列出行号grep -n '^#' regular_express.txt |
| word$   | 意义：待搜寻的字串(word)在行尾！ 范例：将行尾为!的那一行列印出来，并列出行号grep -n '!$' regular_express.txt |
| .       | 意义：代表『一定有一个任意字元』的字符！ 范例：搜寻的字串可以是(eve) (eae) (eee) (ee)，但不能仅有(ee) ！亦即e与e中间『一定』仅有一个字元，而空白字元也是字元！grep -n 'ee' regular_express.txt |
| \       | 意义：透过shell的跳脱字符，将特殊符号的特殊意义去除！ 范例：搜寻含有单引号'的那一行！grep -n \' regular_express.txt |
| *       | 意义：重复零个到无穷多个的前一个RE字符 范例：找出含有(es) (ess) (esss)等等的字串，注意，因为*可以是0个，所以es也是符合带搜寻字串。另外，因为*为重复『前一个RE字符』的符号，因此，在*之前必须要紧接着一个RE字符喔！例如任意字元则为『.*』 ！grep -n 'ess*' regular_express.txt |
| [list]  | 意义：字元集合的RE字符，里面列出想要撷取的字元！ 范例：搜寻含有(gl)或(gd)的那一行，需要特别留意的是，在[]当中『谨代表一个待搜寻的字元』，例如『 a[afl]y 』代表搜寻的字串可以是aay, afy, aly即[afl]代表a或f或l的意思！grep -n 'g[ld]' regular_express.txt |
| [n1-n2] | 意义：字元集合的RE字符，里面列出想要撷取的字元范围！ 范例：搜寻含有任意数字的那一行！需特别留意，在字元集合[]中的减号-是有特殊意义的，他代表两个字元之间的所有连续字元！但这个连续与否与ASCII编码有关，因此，你的编码需要设定正确(在bash当中，需要确定LANG与LANGUAGE的变数是否正确！)例如所有大写字元则为[AZ]grep -n '[AZ]' regular_express.txt |
| [^list] | 意义：字元集合的RE字符，里面列出不要的字串或范围！ 范例：搜寻的字串可以是(oog) (ood)但不能是(oot) ，那个^在[]内时，代表的意义是『反向选择』的意思。例如，我不要大写字元，则为[^AZ]。但是，需要特别注意的是，如果以grep -n [^AZ] regular_express.txt来搜寻，却发现该档案内的所有行都被列出，为什么？因为这个[^AZ]是『非大写字元』的意思，因为每一行均有非大写字元，例如第一行的"Open Source"就有p,e,n,o....等等的小写字grep -n 'oo[^t]' regular_express.txt |
| \{n,m\} | 意义：连续n到m个的『前一个RE字符』 意义：若为\{n\}则是连续n个的前一个RE字符， 意义：若是\{n,\}则是连续n个以上的前一个RE字符！ 范例：在g与g之间有2个到3个的o存在的字串，亦即(goog)(gooog)grep -n 'go\{2,3\}g' regular_express.txt |







## 延伸正规表示法

grep -v '^$' regular_express.txt | grep -v '^#'

需要使用到管线命令来搜寻两次！那么如果使用延伸型的正规表示法，我们可以简化为：

egrep -v '^$|^#' regular_express.txt

延伸型正规表示法可以透过群组功能『 | 』来进行一次搜寻！那个在单引号内的管线意义为『或or』啦！是否变的更简单呢？此外，grep 预设仅支援基础正规表示法，如果要使用延伸型正规表示法，你可以使用grep -E ， 不过更建议直接使用egrep ！直接区分指令比较好记忆！



RE 字符意义与范例+意义：重复『一个或一个以上』的前一个RE字符
范例：搜寻(god) (good) (goood)...等等的字串。那个o+代表『一个以上的o 』所以，底下的执行成果会将第1, 9, 13行列出来。

> egrep -n 'go+d' regular_express.txt

?意义：『零个或一个』的前一个RE字符
范例：搜寻(gd) (god)这两个字串。那个o?代表『空的或1个o 』所以，上面的执行成果会将第13, 14行列出来。有没有发现到，这两个案例( 'go+d'与'go?d' )的结果集合与'go*d'相同？想想看，这是为什么喔！^_^

> egrep -n 'go?d' regular_express.txt

|意义：用或( or )的方式找出数个字串
范例：搜寻gd或good这两个字串，注意，是『或』！所以，第1,9,14这三行都可以被列印出来喔！那如果还想要找出dog呢？

> egrep -n 'gd|good' regular_express.txt
> egrep -n 'gd|good|dog' regular_express.txt

()意义：找出『群组』字串
范例：搜寻(glad)或(good)这两个字串，因为g与d是重复的，所以，我就可以将la与oo列于( )当中，并以|来分隔开来，就可以啦！

> egrep -n 'g(la|oo)d' regular_express.txt

()+意义：多个重复群组的判别
范例：将『AxyzxyzxyzxyzC』用echo叫出，然后再使用如下的方法搜寻一下！

> echo 'AxyzxyzxyzxyzC' | egrep 'A(xyz)+C'

上面的例子意思是说，我要找开头是A 结尾是C ，中间有一个以上的"xyz" 字串的意思～





##文件的格式化与相关处理

### 格式化列印： printf

```
[dmtsai@study ~]$ printf '列印格式'实际内容
选项与参数：
关于格式方面的几个特殊样式：
       \a 警告声音输出
       \b 倒退键(backspace)
       \f 清除萤幕(form feed)
       \n 输出新的一行
       \r 亦即Enter 按键
       \t 水平的[tab] 按键
       \v 垂直的[tab] 按键
       \xNN NN 为两位数的数字，可以转换数字成为字元。
关于C 程式语言内，常见的变数格式
       %ns 那个n 是数字， s 代表string ，亦即多少个字元；
       %ni 那个n 是数字， i 代表integer ，亦即多少整数位数；
       %N.nf 那个n 与N 都是数字， f 代表floating (浮点)，如果有小数位数，
             假设我共要十个位数，但小数点有两位，即为%10.2f 啰！
```



```
范例二：将上述资料关于第二行以后，分别以字串、整数、小数点来显示： 
[dmtsai@study ~]$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt | grep -v Name)
    DmTsai 80 60 92 77.33
     VBird 75 55 80 70.00
       Ken 60 90 70 73.33
```





### awk：好用的资料处理工具

awk 则比较倾向于一行当中分成数个『栏位』来处理。因此，awk 相当的适合处理小型的数据资料处理呢！awk 通常运作的模式是这样的：

```
[dmtsai@study ~]$ awk '条件类型1{动作1}条件类型2{动作2} ...' filename 
```

awk后面接两个单引号并加上大括号{}来设定想要对资料进行的处理动作。awk可以处理后续接的档案，也可以读取来自前个指令的standard output 。但如前面说的，awk主要是处理『每一行的栏位内的资料』，而预设的『栏位的分隔符号为"空白键"或"[tab]键" 』



每一行的每个栏位都是有变数名称的，那就是$1, $2...等变数名称。以上面的例子来说， dmtsai是$1 ，因为他是第一栏嘛！至于192.168.1.100是第三栏，所以他就是$3啦！后面以此类推～呵呵！还有个变数喔！那就是$0 ，$0代表『一整列资料』的意思～以上面的例子来说，第一行的$0代表的就是『dmtsai .... 』那一行啊！由此可知，刚刚上面五行当中，整个awk的处理流程是：

1. 读入第一行，并将第一行的资料填入$0, $1, $2.... 等变数当中；
2. 依据"条件类型" 的限制，判断是否需要进行后面的"动作"；
3. 做完所有的动作与条件类型；
4. 若还有后续的『行』的资料，则重复上面1~3 的步骤，直到所有的资料都读完为止。

经过这样的步骤，你会晓得， awk是『以行为一次处理的单位』，而『以栏位为最小的处理单位』。好了，那么awk怎么知道我到底这个资料有几行？有几栏呢？这就需要awk的内建变数的帮忙啦～

| 变数名称 | 代表意义                         |
| -------- | -------------------------------- |
| NF       | 每一行($0) 拥有的栏位总数        |
| NR       | 目前awk 所处理的是『第几行』资料 |
| FS       | 目前的分隔字元，预设是空白键     |



我们继续以上面last -n 5 的例子来做说明，如果我想要：

- 列出每一行的帐号(就是$1)；
- 列出目前处理的行数(就是awk 内的NR 变数)
- 并且说明，该行有多少栏位(就是awk 内的NF 变数)



**awk 的逻辑运算字元**

| 运算单元 | 代表意义   |
| -------- | ---------- |
| >        | 大于       |
| <        | 小于       |
| >=       | 大于或等于 |
| <=       | 小于或等于 |
| ==       | 等于       |
| !=       | 不等于     |

值得注意的是那个『==』的符号，因为：

- 逻辑运算上面亦即所谓的大于、小于、等于等判断式上面，习惯上是以『==』来表示；
- 如果是直接给予一个值，例如变数设定时，就直接使用= 而已。



- awk 的指令间隔：所有awk 的动作，亦即在{} 内的动作，如果有需要多个指令辅助时，可利用分号『;』间隔， 或者直接以[Enter] 按键来隔开每个指令，例如上面的范例中，鸟哥共按了三次[enter] 喔！
- 逻辑运算当中，如果是『等于』的情况，则务必使用两个等号『==』！
- 格式化输出时，在printf 的格式设定当中，务必加上\n ，才能进行分行！
- 与bash shell 的变数不同，在awk 当中，变数可以直接使用，不需加上$ 符号。





## 档案比对工具

- diff

diff就是用在比对两个档案之间的差异的，并且是以行为单位来比对的！一般是用在ASCII纯文字档的比对上。由于是以行为比对的单位，因此diff通常是用在同一的档案(或软体)的新旧版本差异上！ 



- cmp

相对于diff 的广泛用途， cmp 似乎就用的没有这么多了～ cmp 主要也是在比对两个档案，他主要利用『位元组』单位去比对， 因此，当然也可以比对binary file 啰～(还是要再提醒喔， diff 主要是以『行』为单位比对， cmp 则是以『位元组』为单位去比对，这并不相同！)



- patch

patch这个指令与diff可是有密不可分的关系啊！我们前面提到，diff可以用来分辨两个版本之间的差异，举例来说，刚刚我们所建立的passwd.old及passwd.new之间就是两个不同版本的档案。那么，如果要『升级』呢？就是『将旧的档案升级成为新的档案』时，应该要怎么做呢？其实也不难啦！就是『先比较先旧版本的差异，并将差异档制作成为补丁档，再由补丁档更新旧档案』即可。







# 第十二章、学习Shell Scripts

shell script是利用shell的功能所写的一个『程式(program)』，这个程式是使用纯文字档，将一些shell的语法与指令(含外部指令)写在里面，搭配正规表示法、管线命令与资料流重导向等功能，以达到我们所想要的处理目的。

## 注意事项

shell script的撰写中还需要用到底下的注意事项：

1. 指令的执行是从上而下、从左而右的分析与执行；
2. 指令的下达就如同[第四章](http://linux.vbird.org/linux_basic/0160startlinux.php#cmd_cmd)内提到的：指令、选项与参数间的多个空白都会被忽略掉；
3. 空白行也将被忽略掉，并且[tab] 按键所推开的空白同样视为空白键；
4. 如果读取到一个Enter 符号(CR) ，就尝试开始执行该行(或该串) 命令；
5. 至于如果一行的内容太多，则可以使用『 \[Enter] 』来延伸至下一行；
6. 『 # 』可做为注解！任何加在# 后面的资料将全部被视为注解文字而被忽略！

## 执行方式

如何执行这个档案？很简单，可以有底下几个方法：

- 直接指令下达： shell.sh 档案必须要具备可读与可执行(rx) 的权限，然后：
  - 绝对路径：使用/home/dmtsai/shell.sh 来下达指令；
  - 相对路径：假设工作目录在/home/dmtsai/ ，则使用./shell.sh 来执行
  - 变数『PATH』功能：将shell.sh 放在PATH 指定的目录内，例如： ~/bin/
- 以bash 程式来执行：透过『 bash shell.sh 』或『 sh shell.sh 』来执行



## 组成

1. 第一行#!/bin/bash在宣告这个script使用的shell名称：
   因为我们使用的是bash ，所以，必须要以『**#!/bin/bash**』来宣告这个档案内的语法使用bash的语法！那么当这个程式被执行时，他就能够载入bash的相关环境设定档(一般来说就是[non-login shell的~/.bashrc](http://linux.vbird.org/linux_basic/0320bash.php#settings_bashrc_shell) )，并且执行bash来使我们底下的指令能够执行！这很重要的！(在很多状况中，如果没有设定好这一行，那么该程式很可能会无法执行，因为系统可能无法判断该程式需要使用什么shell来执行啊！)

   

2. 程式内容的说明：
   整个script当中，除了第一行的『 #! 』是用来宣告shell的之外，其他的#都是『注解』用途！所以上面的程式当中，第二行以下就是用来说明整个程式的基本资料。一般来说，建议你一定要养成说明该script的：1.内容与功能； 2.版本资讯； 3.作者与联络方式； 4.建档日期；5.历史纪录等等。这将有助于未来程式的改写与debug呢！

   

3. 主要环境变数的宣告：
   建议务必要将一些重要的环境变数设定好，鸟哥个人认为， PATH与LANG (如果有使用到输出相关的资讯时)是当中最重要的！如此一来，则可让我们这支程式在进行时，可以直接下达一些外部指令，而不必写绝对路径呢！比较方便啦！

   

4. 主要程式部分
   就将主要的程式写好即可！在这个例子当中，就是echo那一行啦！

   

5. 执行成果告知(定义回传值)
   是否记得我们在[第十章](http://linux.vbird.org/linux_basic/0320bash.php)里面要讨论一个指令的执行成功与否，可以使用 [$?](http://linux.vbird.org/linux_basic/0320bash.php#redirect_com)这个变数来观察～ 那么我们也可以利用exit这个指令来让程式中断，并且回传一个数值给系统。在我们这个例子当中，鸟哥使用exit 0 ，这代表离开script并且回传一个0给系统，所以我执行完这个script后，若接着下达echo $?则可得到0的值喔！更聪明的读者应该也知道了，呵呵！利用这个exit n (n是数字)的功能，我们还可以自订错误讯息，让这支程式变得更加的smart呢！



**对谈式脚本：变数内容由使用者决定**

 [read](http://linux.vbird.org/linux_basic/0320bash.php#read)指令

**数值运算：简单的加减乘除**

var=$((运算内容))



### 利用直接执行的方式来执行script

(不论是绝对路径/相对路径还是${PATH}内)，或者是利用bash (或sh)来下达脚本时，该script都会使用一个新的bash环境来执行脚本内的指令！也就是说，使用这种执行方式时，其实script是在子程序的bash内执行的！我们在[第十章BASH](http://linux.vbird.org/linux_basic/0320bash.php)内谈到 [export](http://linux.vbird.org/linux_basic/0320bash.php#export)的功能时，曾经就父程序/子程序谈过一些概念性的问题，重点在于：『当子程序完成后，在子程序内的各项变数或动作将会结束而不会传回到父程序中』

![showname.sh 在子程序當中運作的示意圖](http://linux.vbird.org/linux_basic/0340bashshell-scripts//centos7_non-source.gif)



###利用source 来执行脚本：在父程序中执行**

![showname.sh 在父程序当中运作的示意图](http://linux.vbird.org/linux_basic/0340bashshell-scripts//centos7_source.gif)







## 善用判断式


![463f21f2a0d64e9fa1f42b4756de07d4.png](/Users/giffinhao/Downloads/笔记/pic/463f21f2a0d64e9fa1f42b4756de07d4.png.webp)





![image-20240816201759844](/Users/giffinhao/Library/Application Support/typora-user-images/image-20240816201759844.png)



## 化整为零的G1回收器

​    整个应用基于JDK8开发，因此也就顺理成章用了成熟的**新生代ParNew +老年代CMS回收策略**。最消耗JVM内存的操作是进行设备配置核查，涉及到设备和数据库上所有配置的拉取和比对。整个任务耗时很长，本来是用完即走的大量临时数据，在多次Yong GC后，业务不再使用的对象迁入老年代。如果迁入的数据量过大，老年代没有足够的连续空间，或者整体老年代空间大小达到了阈值，触发Full GC。FullGC采用了基于标志清理算法的CMS回收器，会带来如下问题：

- 全量老年代对象的扫描和标记带来长时间阻塞。
- 垃圾清理的算法会造成内存碎片。

​    早期项目上线，**控制器JVM内存规格配置在32G大小**。采用CMS回收机制，最长的GC卡顿时间在两秒以内，是能满足业务需求。后面随着业务规格的提升，**JVM的内存提升至96G。单台设备的配置核查大概占用近十多个G的内存**，**而且会涉及大对象的连续空间分配。刚才提到CMS清理垃圾的方式易造成内存碎片。如果连续空间不足，触发FULL GC**。**CMS回收器对【全量的老年代做两次扫描和标注】，最终会导致10S左右的GC卡顿。这就会造成【控制器集群分裂，最终导致设备负载切来切去，系统服务的不稳定**】。

​    **在大内存的场景下，CMS回收的粒度太大了**。**G1化整为零，分而治之的回收策略显然更适合。项目改成了G1回收器后， GC 的最大卡顿时间从10秒降到1秒以内**。G1把整个JVM化成多个region，然后通过rememberSet把孤立的region关联起来管理。切分之后，对每个region的使用情况都会依据回收的价值排序，比如说新新配的内存实例很大可能是朝生夕死的临时变量，优先级就高；而经历多轮GC考验的老年代对象，可能是应用长期持有的，回收概率小，优先级则低。这也是G1（Garbage-First）的由来，回收价值越高，就越优先被回收。**G1根据用户设置的最大GC停顿时间（MaxGCPauseMillis），筛选出一定数量的region列表作为GC的执行对象。**这样就能避免CMS全量的老年代清理，大大减少了单次GC耗时。同样划分细粒度的Region后，在内存管理上更便于全局的统筹规划。**G1采用了标志-整理算法，用复制的方式避免了清除垃圾造成的内存碎片，提升了实例空间分配的效率**



那是不是就可以下结论，G1就是优于CMS的回收器？有得必有失。化整为零的策略虽然减少了单次GC的停顿时间，**但是却需要更频繁的GC，降低了系统吞吐率**；未能全盘扫描，更容易存在内存垃圾，降低了空间利用率。打个比方，本来可以关起门来，一次性地彻底把房子打扫干净。如果每次扫地时间有限，就分了一小格一小格的空间清理。每次扫完10小格，到点就走。屋子脏了再进来扫十小格，来来回回，不停折腾。整个屋子也始终清理得不干净，总有卫生死角。

## 并发执行的主动GC

​    GC可以由JVM自身和应用程序触发。第一个比较好理解，当内存到达一定阈值或者影响新对象分配时，jvm自动就会触发。第二个，应用在代码中调用system.gc函数触发。Java不是有垃圾回收，应用不都是甩手掌柜，为何应用还需要触发GC？如果是JVM的内存管理，应用程序不用干预。**但一些程序存在堆外资源的使用，这是显式创建的，也需要自己释放，比如NIO的DirectByteBuffer和RMI的DGC（DistributedGarbageCollector）。这些Java实例通过Java的虚引用，将外部资源与JVM GC回收联动。如果JVM内部实例被回收，则就会触发外部资源的清理动作。当这些程序感知到有必要做外部资源清理，就会触发GC。**

在系统的GC日志中，每个一小时都会执行一次System.gc任务。一开始整体业务量不大，这个GC带来的停顿很小，我们对这个现象不是很敏感。后续，增大业务量后，也就10G内存左右，发现每个小时触发的Full GC 都会耗时10秒以上，这导致了集群每小时分裂一次，造成业务服务的不稳定。但是如果JVM自身触发的Full GC 执行时间就比System.gc触发的小很多。这就带来了两个问题：为何每小时周期会触发System.gc？为何System.gc耗时长？

对于第一个问题，我们的应用代码并没有主动调用System.gc，只能出在框架或者引入的插件里。在梳理整个系统的组件后，猜测是RMI（Remote Method Invocation）触发的。修改RMI 服务的GC周期后，System.gc果然是按照这个周期发起的，也就验证了周期性的GC由RMI服务引起。进一步，为什么RMI需要周期执行GC？背后是一套DGC（DistributedGarbageCollector）机制。

<img src="/Users/giffinhao/Library/Application Support/typora-user-images/image-20240816202613746.png" alt="image-20240816202613746" style="zoom:50%;" />

RMI的本质是通过网络，为业务提供跨JVM的实例创建、管理和调用。同一个JVM内，CMS可以通过可达标志的算法来区分正常使用或者废弃的对象。JVM间的对象有效性，则需要靠DGC提供跨JVM的对象引用依据。为此，DGC提供了两个管理接口：dirty和clean。当客户通过RMI在服务端jvm创建实例后，该实例置为dirty。这个dirty状态过了一定时间则转化为clean，标志为可清除。如果客户端想继续使用该实例，需通过续期的方式重置它的dirty状态。对于clean对象，虽然DGC以不再使用，但是实例依然存在与JVM中，还没被GC回收掉。如果该对象存活时间不长，就很容易被高频的Yong GC回收掉。但是，如果它已经存活足够时间，则会移入老年代。这时候只能靠Full GC来清除了。所以RMI为了尽可能回收躲到老年代里的垃圾对象，就固定周期触发一次system.gc。

​    **system.gc触发的是老年代对象回收，那又为何它的执行会比jvm自身发起的耗时长那么多？JVM有一个很误导人的地方，即使在JAVA_OPS设置了CMS或者G1作为回收器，但是这个策略仅适用于JVM自身发起的Full GC，不会覆盖应用发起的Syetem.gc。如果不指定，【System.gc使用了串行回收的Serial old收集器，导致了它整个回收耗时特别长。】因此，如果业务存在System.gc调用的场景，记得开启【ExplicitGCInvokesConcurrent开关】。打开这个开关后，业务发起的GC也会使用CMS等其它并行垃圾回收器执行。**





所以，外部缓存的清理依赖于JVM的垃圾回收。如果JVM内部的实例一直没清理，则外部缓存就会一直存在。而GC要触发，依赖于JVM的整体使用量。一个directByteBuffer实例就是个冰山对象：它在jvm内可能只是个占用空间不大的引用，但背后会关联外部的大量资源。在我们的场景下，经常从设备中拉取大量配置，意味着会占据着大量的直接内存。而且在我们进行设备的配置核查任务时，又会长时间持有对象实例。这些对象就可能老化了，进而高频的Yong GC也没法处理到。这样就会导致外部缓存一直长时间被占据。**为了防止冰山对象造成的缓存不及时清理，java NIO的directByteBuffer限制了缓存大小，即使内部JVM没达到Full GC的阈值，只要缓存到了上限，就会主动触发FullGC。**

   一开始我们没有设置直接内存的大小，**则它默认与JVM的最大值一样，即96G。但是机器的内存只有128G。当外部缓存把机器剩下内存空间挤满时候，就会造成进程分配内存失败，异常退出的问题。因此不能让堆外空间野蛮成长，后续设置了MaxDirectMemorySize，解决了该问题。**

<img src="/Users/giffinhao/Downloads/笔记/pic/0bf3a2ef034c4965892ee07fc6e7cd83.png.webp" alt="0bf3a2ef034c4965892ee07fc6e7cd83.png" style="zoom:50%;" />

### 1. **直接内存（Direct Memory）和 `DirectByteBuffer`**

- **直接内存** 是指 Java 程序通过 `DirectByteBuffer` 直接从操作系统申请的内存，而不是从 JVM 堆内存中分配。这种方式的优势在于，它可以避免将数据从 JVM 堆内存复制到操作系统内核空间，从而提高 I/O 操作的效率。直接内存通常用于处理大规模的 I/O 操作，例如与设备或网络进行高频数据交换。
- `DirectByteBuffer` 是 Java NIO 中用于管理直接内存的对象。虽然 `DirectByteBuffer` 的实例在 JVM 中仅占用少量堆内存，但它们背后关联着可能占用大量系统内存的直接内存区域。

### 2. **垃圾回收与直接内存**

- **JVM 的垃圾回收（GC）** 主要管理的是堆内存，即 Java 对象的生命周期和内存的回收。然而，直接内存并不在 JVM 管理的堆内存范围内，因此直接内存的释放依赖于 JVM 垃圾回收对 `DirectByteBuffer` 实例的回收。
- **冰山对象（Iceberg Objects）** 是指那些在 JVM 中占用小量内存，但实际上与大量外部资源相关联的对象。`DirectByteBuffer` 就是典型的冰山对象：虽然它在 JVM 中仅占用少量堆内存，但实际控制着大量的直接内存。
- 如果 `DirectByteBuffer` 实例在 JVM 内部长时间没有被清理（例如，在老年代中存留），则其关联的外部直接内存也不会被释放，导致系统内存使用量持续增加。

### 3. **直接内存与 Full GC**

- **Young GC** 主要处理新生代中的对象，但 `DirectByteBuffer` 对象一旦被长时间持有而进入老年代，Young GC 很难触及这些对象。
- 当 JVM 的直接内存使用接近系统内存极限时，可能会触发 `OutOfMemoryError`，尤其是当机器的物理内存接近耗尽时。由于 `DirectByteBuffer` 是堆外内存（非堆内内存），如果没有及时释放，可能导致系统内存不足，从而使整个进程崩溃。
- **为了解决这个问题，Java NIO 实现了一种机制，即在直接内存使用达到某个上限时，即使 JVM 的堆内存尚未触发 Full GC，也会强制执行 Full GC，以释放直接内存。这是为了避免由于内存占用过高而导致的进程崩溃**。

### 4. **`MaxDirectMemorySize` 参数的作用**

- **`MaxDirectMemorySize`** 参数用于限制 JVM 可以分配的最大直接内存量。默认情况下，如果没有设置这个参数，直接内存的上限等同于 JVM 最大堆内存（`-Xmx`），在你的场景中是 96GB。
- 但是，物理机器的总内存为 128GB，直接内存和其他内存（例如 JVM 堆内存、操作系统和其他进程使用的内存）都共享这部分内存空间。如果没有限制直接内存的大小，可能会导致直接内存占满了物理内存，剩余的系统内存不足以支持其他操作，从而引发内存分配失败，导致 JVM 进程崩溃。
- 通过设置 `MaxDirectMemorySize` 参数，可以限制直接内存的最大值，防止其过度使用系统内存。例如，如果你将 `MaxDirectMemorySize` 设置为 64GB，这意味着 JVM 在达到 64GB 的直接内存使用后，将无法再分配更多直接内存，从而避免了系统内存被耗尽的风险。

### 5. **问题的解决**

- 设置 `MaxDirectMemorySize` 后，限制了 `DirectByteBuffer` 的最大直接内存使用量，确保物理内存不会被直接内存过度占用，从而解决了进程因内存分配失败而异常退出的问题。

## 避免内存分配的懒加载策略

​    在测试中，我们在GC日志中偶尔出现Yong GC时间过长，大概三四秒。它出现在：**1）将新生代对象移入老年代阶段，2）为新创建的对象分配Eden空间。这两个问题都出现在为新的对象申请内存阶段**。虽然我们将JVM的Xms（最小内存）和Xmx（最大内存）都配置成一样的，一启动就希望操作系统能按照把固定的内存分配给JVM。但是操作系统是按需分配的懒加载策略：进程真正使用内存时候，才会分配。这策略都导致了JVM内部分配新内存时，都需要去操作系统申请，如果申请时间长，就会导致GC 时间过长。因此我们加上了**AlwaysPreTouch参数，让jvm后续能更快速地创建对象空间**。

​    当然这个参数也会带来一定的副作用，即启动时间会变长。这也可以理解，以前是按需分配，现在是狮子大开口，一次性索取。**但控制系统是个Failover集群，只有等节点完全就绪后，其它节点的负载才会迁移到新节点上。相对于启动时间，我们更在意的是节点正常运行后的稳定性。**

### 4. **为什么晋升会在新对象申请内存阶段发生**

当新生代空间（主要是 Eden 区）不足以分配新对象时，JVM 会执行以下步骤：

1. **检查新生代空间**：JVM 首先检查 Eden 区是否有足够的空间来容纳新的对象。如果空间足够，直接分配。如果空间不足，则会触发 Minor GC。
2. **触发 Minor GC**：Minor GC 会清理 Eden 区，并将存活的对象移动到 Survivor 区或晋升到老年代。
3. **晋升到老年代**：如果在 GC 过程中，Survivor 区无法容纳所有从 Eden 区转移过来的存活对象，这些对象将会被晋升到老年代。
4. **重新分配空间**：在 GC 完成后，JVM 将再次尝试在 Eden 区为新对象分配内存。如果此时 Eden 区仍然没有足够的空间，可能意味着老年代的空间也已接近耗尽。
5. **老年代空间不足的影响**：如果老年代空间不足，晋升过程将无法顺利进行，这将导致进一步的 Full GC（完全垃圾回收），甚至可能导致 OutOfMemoryError（OOM）。

### 5. **为何GC时间长：老年代空间不足**

- **老年代空间不足**：如果老年代空间紧张，每次晋升对象时，JVM 都需要花费更多时间来进行内存管理，这会导致 GC 时间延长。
- **分配新对象时的竞争**：当 JVM 需要为新对象分配内存时，Eden 区可能会因无法及时释放内存而造成分配失败，进一步导致对象晋升到老年代。
- **触发 Full GC**：在极端情况下，如果老年代无法容纳晋升的对象，JVM 可能会触发 Full GC，这会进一步延长 GC 时间。

## 避免乐极生悲的偏向锁

​    随着监控完善，控制节点都会记录JVM GC日志。在日志中，我们发现了高频输出的STW（StopTheWorld，GC停顿）信息，而且绝大部分都不是GC触发的。我们接着增加了PrintSafepointStatistics运行参数，输出STW的详细信息。立马出现了如下满屏的RevokeBias，即取消偏向锁的记录。

​    那什么是偏向锁呢？这是JDK Synchronizied锁背后的优化机制。早期JDK的Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。**但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，导致锁性能较低**。为了尽可能减少对底层Mutex Lock的调用，JDK后续引入了轻量级锁：在对象头上增加轻量级锁的状态，**通过CAS机制去实现互斥资源的控制。在线程交替执行的场景，轻量级锁能有很好的优化。需要注意的是，轻量级锁的粒度是同步方法。多个同步方法调用时，会有多次CAS的系统原语调用。CAS也是需要调用底层操作指令的。因此为了减少CAS的调用，接着又引入了偏向锁。**

​    **偏向锁通过一次CAS操作，把自己的threadId写入对象头，后续再次进入该资源后，发现是自己的id，则会认为自始至终只有它独占资源。通过一次CAS就能实现对互斥资源的安全操作，省去了很多系统原语调用，提升了性能。**

![1d43d3747058440bae4334bda57bb0b3.png](/Users/giffinhao/Downloads/笔记/pic/1d43d3747058440bae4334bda57bb0b3.png.webp)



 **但这种过于乐观的机制，只适合单个线程执行的场景**。在并发的场景下，就会带来很大的性能劣化：如果后续再有线程尝试占有这个对象的偏向锁，即发起CAS的thread id替换就会失败，此**时需要将偏向锁退化为轻量级锁。要实现这种状态转换，需要极高的代价：为了安全地执行状态修改，需要确保整个JVM都进入到安全点（可理解为jvm都处于一个暂态中）**。**这时候JVM才能把对象头和拥有偏向锁的栈，从偏向锁的状态转化为轻量级锁的状态。局部的锁优化，现在却劣化成整个JVM的卡顿事件。在高并发的场景中，可想而知，JVM频繁的停顿，降低了系统的性能。根据我们的并发需求，通过UseBiasedLocking禁用了偏向锁。**





## 业务开发上建议

​    对于GC，是不是配了一通的JVM参数，应用开发就可以高枕无忧？不要忘了所有的内存垃圾都是由业务直接或者间接触发。如果我们在开发时候有更好的习惯，就能让GC更为应用服务，从而提升JVM稳定性和性能。以下是我们在实际开发总结的经验：

- 避免长时间占有临时对象：老年代的回收是耗时长和低频度的，尽量让实例回收暴露在高频的Yong GC阶段。因此根据对象的生命周期，明确它存活的作用域，也可提升回收效率和性能。
- 避免分配大对象：当分配对象过大，若JVM连续内存空间不足，则会触发耗时的Full GC。
- **避免耗时长的循环任务**：每次进行GC都需要所有的线程都处于安全点上，而循环的结束位置也是个安全点。如果应用在循环里做了很耗时的任务，当发起GC后，某个线程还在循环体执行时，其它所有的线程都会等它循环结束。这也会造成了长时间的GC。
- 应用程序状态轻量化：虽然G1的出现一定程度上缓解了大内存下的GC时间，但也存在降低系统吞吐率的代价。**极端情况下，当用户设置的期待卡顿时间过小，G1小步迭代的节奏无法跟上内存的增长速度，则会蜕化成保守低效的series old GC**。同时，JVM进程状态过重，**在Failover的故障转移场景中，需要很复杂和耗时的故障迁移和恢复。为此，最好能把部分状态迁出JVM，如迁到Redis缓存。**





JVM优化经验 

- **Java整个堆大小设置，Xmx 和 Xms设置为老年代存活对象的3-4倍，即FullGC之后的老年代内存占用的3-4倍**。
- 永久代 **PermSize和MaxPermSize(元空间)设置为老年代存活对象的1.2-1.5倍**。
- 年轻代Xmn的设置为老年代存活对象的1-1.5倍。
- 老年代的内存大小设置为老年代存活对象的2-3倍。

**-Xms**

初始堆的大小，也是堆大小的最小值，默认值是总共的物理内存/64（且小于1G），**默认情况下，当堆中可用内存小于40%（这个值可以用-XX: MinHeapFreeRatio 调整，如-X:MinHeapFreeRatio=30）时，堆内存会开始增加，一直增加到-Xmx的大小**

**-Xmx**

堆的最大值，**默认值是总共的物理内存1/4，如果Xms和Xmx都不设置，则两者大小会相同，默认情况下，当堆中可用内存大于70%（这个值可以用-XX: MaxHeapFreeRatio 调整，如-X:MaxHeapFreeRatio=60）时，堆内存会开始减少，一直减小到-Xms的大小**

**-Xmn**

用于设置新生代的大小。设置一个较大的新生代会减少老年代的大小，这个参数堆系统性能以及GC行为有很大的影响。新生代的大小一般设置为整个堆空间的1/3到1/4

**-Xss**

设置每个线程可使用的内存大小，即栈的大小。在相同物理内存下，减小这个值能生成更多的线程，当然操作系统对一个进程内的线程数还是有限制的，不能无限生成。线程栈的大小是个双刃剑，如果设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢出的可能性更大，如果该值设置过大，就有影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的错误。

**-XX:SurvivorRatio**

新生代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：为3，表示Eden：Survivor=3：2，一个Survivor区占整个新生代的1/5 

**-XX:MaxTenuringThreshold**

设置转入老年代的存活次数。如果是0，则直接跳过新生代进入老年代。

**将此值设置为一个较小值对于需要大量常驻内存的应用，这样做可以提高效率。**

**如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。**

可以通过以下命令查看系统默认的InitialHeapSize和MaxHeapSize：

java -XX:+PrintFlagsFinal -version | grep HeapSize

**生产环境中设置-Xms与-Xmx一致以保证程序稳定**

**开发测试环境设置一个比较小的-Xms，以支撑更多的测试程序运行**

实践步骤：

1、运行程序一段时间，查询系统各指标

以开发集成环境为例

 jstat -[-t] [-h]  [ []]

S0C:年轻代第一个survivor的容量（字节）

S1C：年轻代第二个survivor的容量（字节）

S0U：年轻代第一个survivor已使用的容量（字节）

S1U：年轻代第二个survivor已使用的容量（字节）

EC：年轻代中Eden的空间（字节）

EU：年代代中Eden已使用的空间（字节）

OC：老年代的容量（字节）

OU:老年代中已使用的空间（字节）

MC：方法区（元空间）的容量

MU：方法区（元空间）已使用的容量

CCSC: 压缩类的空间容量

CCSU:压缩类已使用的容量

YGC：从应用程序启动到采样时年轻代中GC的次数

YGCT:从应用程序启动到采样时年轻代中GC所使用的时间（单位：S）

FGC：从应用程序启动到采样时老年代中GC（FULL GC）的次数

FGCT：从应用程序启动到采样时老年代中GC所使用的时间（单位：S）

得知：OU老年代所占用的内存为1215418（122M）

**堆大小**

-Xms256m -Xmx512m

新生代

 -Xmn128m

新生代中Eden区与两个Survivor区

-XX:+PrintTenuringDistribution 

表示输出GC之后，survivor区域各年龄段的内存分布情况

Desired survivor size表示survivor区域允许容纳的最大空间大小为34078720bytes。

这里Desired survivor size这行下面并没有各个age对象的分布，那就表示此次gc之后，当前survivor区域并没有age小于max threshold的存活对象。而这里一个都没有输出，表示此次gc回收对象之后，没有存活的对象可以拷贝到新的survivor区。

-XX:SurvivorRatio=8 默认值8

含义：eden/suvivor=8 ,其中survivor包含from、to。

新生代设定128m，那么,from =128m/(8+2)=12.8m, eden=102.4m。也就是说新生代会被分成10分，eden区占8分，survivor占2份，这也能看出比值越大survivor被稀释的越严重。比值越小survivor分到的空间更大。

-XX:+HeapDumpOnOutOfMemoryError

**-XX:HeapDumpPath=./dump.log**

在Java程序运行过程中，如果堆内存不足，则有可能抛出内存溢出错误（OutOfMemory）。一旦发生这类问题，系统将被迫退出，引起严重的业务中断。为了能不断改善系统，需要在发生错误时，保留尽可能多的现场信息，使用该参数可以在内存溢出时导出整个堆信息。

**方法区配置**

 -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M 

**【方法区大小决定系统可以保存多少个类，如果使用动态代理，那设置该值需要更加合理，以确保方法区不发生内存溢出】。**

**栈配置**

-Xss128K

这个参数决定了函数调用的最大深度，通过jclasslib工具可以查看函数的局部变量信息。

设置每个线程的堆栈大小。JDK5.0以后每个线程堆 栈大小为1M，以前每个线程堆栈大小为256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。该应用tomcat线程为500。

**直接内存配置**

-XX:MaxDirectMemorySize不设置

默认值为最大堆空间-Xmx，达到最大量时同样触发GC

直接内存跳过了Java堆，使Java程序可以直接访问原生堆空间，因此从一定程度上加快了内存空间的访问速度。但是直接内存的申请速度远远大于堆空间，**因此直接内存适合于申请次数较少，读写频繁的场合。**

**从Java 1.4开始引入了直接内存。新的I / O（NIO）类引入了一种基于通道和缓冲区执行I / O的新方法。 NIO添加了对直接ByteBuffers的支持，可以直接传递给本机内存而不是Java堆。在某些情况下，由于它们可以避免在Java堆和本机堆之间复制数据，因此可以大大提高它们的速度。**

可以通过调用 allocateDirect $ b创建直接字节缓冲区。 $ b此类的工厂方法。与非直接缓冲区相比，用此方法返回的缓冲区通常具有更高的分配和释放成本。 直接缓冲区的内容可能驻留在正常垃圾回收堆之外的中，因此它们对应用程序内存占用的影响可能并不明显。 因此，建议主要为直接受基础系统本机I / O操作约束的大型大型缓冲区分配直接缓区。 通常，最好仅在直接缓冲区在程序性能中产生可衡量的收益时才分配它们。

estlevent_time=1723808446&event_code=e#hybrid_system_capacity&ev

**垃圾回收器选择**

jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）

jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）

jdk1.9 默认垃圾收 2020/09/21 18:05 集器G1

-XX:+PrintCommandLineFlagsjvm参数可查看默认设置收集器类型

-XX:+PrintGCDetails亦可通过打印的GC日志的新生代、老年代名称判断

*串行回收器（小数据量）不采用*

-XX:+UseSerialGC

设置串行回收器。虚拟机在Client模式下运行时，它是默认的垃圾回收器。

*并行回收器（吞吐量优先）不采用*

-XX:+UseParallelGC

设置为并行回收器。此配置仅对年轻代有效。即年轻代使用并行回收，而年老代仍使用串行回收。

-XX:+UseParallelOldGC 

配置年老代垃圾回收方式为并行回收。JDK6.0开始支持对年老代并行回收。

-XX:ParallelGCThreads=20 

配置并行回收器的线程数，即：同时有多少个线程一起进行垃圾回收。此值建议配置与CPU数目相等。CMS默认启动的并发线程数是(ParallelGCThreads+3)/4。

-XX:MaxGCPauseMillis=100 

设置每次年轻代垃圾回收的最长时间（单位毫秒）。如果无法满足此时间，JVM会自动调整年轻代大小，以满足此时间。该值越小，停顿时间越短，触发GC次数越频繁、总回收时间越长、吞吐量越低。

-XX:+UseAdaptiveSizePolicy

设置此选项后，并行收集器会自动调整年轻代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直打开。

*并发收集器（响应时间优先）*

-XX:+UseConcMarkSweepGC

即CMS收集，设置年老代为并发收集。CMS收集是JDK1.4后期版本开始引入的新GC算法。它的主要适合场景是对响应时间的重要性需求大于对吞吐量的需求，能够承受垃圾回收线程和应用线程共享CPU资源，并且应用中存在比较多的长生命周期对象。CMS收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存。

-XX:+UseParNewGC

设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此参数。

-XX:+UseCMSCompactAtFullCollection

打开内存空间的压缩和整理，在Full GC后执行。可能会影响性能，但可以消除内存碎片。

-XX:CMSFullGCsBeforeCompaction=0 默认0

由于并发收集器不对内存空间进行压缩和整理，所以运行一段时间并行收集以后会产生内存碎片，内存使用效率降低。此参数设置运行0次Full GC后对内存空间进行压缩和整理，即每次Full GC后立刻开始压缩和整理内存。

-XX:+CMSIncrementalMode

设置为增量收集模式。一般适用于单CPU情况。

-XX:CMSInitiatingOccupancyFraction=70

默认值-1

当老年代的空间使用率达到68%时，会执行一次CMS回收。如果内存使用率增长过快，在CMS的执行过程中，已经出现了内存不足的情况，此时，CMS回收就会失败，虚拟机将启用老年代串行回收器进行垃圾回收，应用程序也将完全中断，知道垃圾回收完成。

因此可以根据应用程序的特点，如果内存增长缓慢，则可以设置一个较大的值，有效降低CMS的触发频率，反之若内存增长很快，则应该降低这个值，避免频繁触发老年代串行回收器。

**其它垃圾回收参数**

-XX:+ScavengeBeforeFullGC

年轻代GC优于Full GC执行。

-XX:-DisableExplicitGC

不响应 System.gc() 代码。

-XX:+UseThreadPriorities

启用本地线程优先级API。即使 java.lang.Thread.setPriority() 生效，不启用则无效。

-XX:SoftRefLRUPolicyMSPerMB=0

软引用对象在最后一次被访问后能存活0毫秒（JVM默认为1000毫秒）。

-XX:TargetSurvivorRatio=90

允许90%的Survivor区被占用（JVM默认为50%）。提高对于Survivor区的使用率。

**GC日志**

-XX:+PrintGC

参数-XX:+PrintGC（或者-verbose:gc）开启了简单GC日志模式，为每一次新生代（young generation）的GC和每一次的Full GC打印一行信息。

-XX:+PrintGCDetails

开启了详细GC日志模式。在这种模式下，日志格式和所使用的GC算法有关。

-XX:+PrintGCTimeStamps

-XX:+PrintGCDateStamps

将时间和日期加到GC日志中。

-Xloggc:./gclogs.log

缺省的GC日志时输出到终端的，使用-Xloggc:也可以输出到指定的文件。需要注意这个参数隐式的设置了参数-XX:+PrintGC和-XX:+PrintGCTimeStamps。

-XX:+PrintHeapAtGC

打印GC前后的详细堆栈信息。

-XX:+PrintCommandLineFlags

打印虚拟机默认参数。

-XX:+PrintTenuringDistribution

用于显示每次Minor GC（年轻代GC）时Survivor区中各个年龄段的对象的大小。

-XX:+PrintCompilation

打印Java HotSpot VM动态运行时编译器的详细输出。

因此最终设置JVM参数如下

-Xms256m -Xmx512m -Xmn128m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./dump.log -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -Xss128K -XX:+UseConcMarkSweepGC -XX:PrintHeapAtGC -XX:+PrintGCDateStamps -Xloggc:./gclogs.log




腾讯会议的“秒控”是指在会议过程中，通过快捷方式或快速操作来实现对会议的快速控制和管理。这种功能旨在提升用户体验，使会议主持人和参与者能够迅速响应和处理会议中的各种需求和突发情况。

具体来说，“秒控”可能包括以下几个方面的功能：

### 快速静音/取消静音

- **全员静音**：主持人可以一键将所有参会者设置为静音，避免会议过程中出现杂音或干扰。
- **单独静音**：主持人可以快速静音特定参会者。
- **取消静音**：参会者可以方便地取消自己的静音状态，或者主持人可以取消特定参会者的静音。

### 快速屏幕共享

- **开始/停止共享**：参会者可以通过快捷键或按钮快速开始或停止屏幕共享。
- **切换共享内容**：在共享过程中，可以快速切换共享的窗口或应用程序。

### 快速进入/退出会议

- **快速进入会议**：用户可以通过会议链接、二维码或者会议号迅速加入会议。
- **快速离开会议**：用户可以通过快捷键或按钮快速离开会议，而不影响其他参会者。

### 快速邀请参会者

- **发送邀请**：主持人可以快速生成邀请链接或会议号，并通过邮件、即时通讯工具等方式发送给其他人。

### 快速管理参会者

- **移除参会者**：主持人可以快速移除不遵守会议纪律或无关的参会者。
- **提升/降低权限**：主持人可以快速提升某个参会者为共同主持人，或者降低其权限。

### 快速录制和截图

- **开始/停止录制**：用户可以通过快捷键或按钮快速开始或停止会议录制。
- **截图**：用户可以快速截图保存重要的会议内容或演示文稿。

### 举手发言

- **举手发言**：参会者可以通过快捷方式举手申请发言，主持人可以快速批准或拒绝。

### 快速设置会议参数

- **调整视频设置**：用户可以快速调整摄像头和麦克风的设置，如分辨率、背景虚化等。
- **调整音频设置**：用户可以快速切换音频输入输出设备，调整音量等。

### 秒控的实现技术

“秒控”功能的实现通常依赖于以下技术和机制：

- **快捷键支持**：通过预设的快捷键，用户可以快速执行常用操作。
- **用户界面优化**：通过简洁直观的用户界面，用户可以快速找到并执行需要的操作。
- **后台处理**：优化后台处理逻辑，确保用户的操作能迅速得到响应。
- **网络优化**：通过优化网络传输，减少延迟，确保用户操作能够即时生效。



# 客户端数据上报改造方案

## 背景

目前客户端埋点数据直接上报到灯塔， 当前的方案存在以下问题：

1、客户端的公参上报问题，导致大量重复数据上报，导致流量消耗较大，需要支持长连接，进行对公参进行后端补偿

2、客户端sdk目前对称加密存在安全性问题，密钥key写死在代码中。

3、不能对数据上报做统一管理和扩展

## 项目目标

1. 优化上报协议， 优化流量占用，使用长连接解决频繁建连问题。
2. 解决对称加密的安全问题
3. 使上报通道统一可控。

<img src="/Users/giffinhao/Library/Application Support/typora-user-images/image-20240722144015946.png" alt="image-20240722144015946" style="zoom:50%;" />

1. 优化上报协议。由原来方案的TCP/jce协议改成https/json协议，同时https采用长连接方式减少连接的频繁建立，协议支持批量合并上传
2. 减少上报流量。 公共参数首次上报时和全量更新时上报，其他上报请求的公共参数由后端自行补偿，减少数据重复上报
3. 采用自建的wemeet_log_server便于统一管理。

![数据上报流程图](/Users/giffinhao/Downloads/笔记/pic/数据上报流程图.png)

## 数据上报机制流程图

![数据上报11](/Users/giffinhao/Downloads/笔记/pic/数据上报11.png)



### 全量更新公参请求处理流程

![全量更新公参请求流程](/Users/giffinhao/Downloads/笔记/pic/全量更新公参请求流程.png)





### 不带公参请求处理流程

![不带公参请求处理流程](/Users/giffinhao/Downloads/笔记/pic/不带公参请求处理流程.png)





### 增量更新公参请求处理流程

![更新公参请求处理](/Users/giffinhao/Downloads/笔记/pic/更新公参请求处理.png)





### 透传公参请求处理流程

![透传请求流程](/Users/giffinhao/Downloads/笔记/pic/透传请求流程.png)





## 本地缓存配置

增加Tencent\WeMeet\Global\Database\data_report.db数据库

建表参数如下

```javascript
CREATE TABLE tab_event_report_request(
col_event_seq INTEGER PRIMARY KEY AUTOINCREMENT,//事件序列号
col_event_request_type INTEGER NOT NULL,//事件类型
col_event_content TEXT,//事件内容
col_event_timestamp INTEGER,//保存到数据库时间
);
```

 

## 兼容原有方案及相关模块改动

### 增加能力配置开关

在analysis group中增加能力开关字段beacon-log-report-enable和wemeet-log-report-enable

- 控制灯塔上报通道的开启和关闭 {beacon-log-report-enable:true}
- 控制会议自建上报通道的开启和关闭 {wemeet-log-report-enable:true}
- 在application_model中增加能力配置监控， 通过新增的接口SetBeaconLogEventReportEnable SetWemeetLogEventReportEnable设置相应的开关

```javascript
 BEGIN_SUBSCRIBE_APP_EVENT(WEMEET::ModelType::kModelAbilityConfig)
    SUBSCRIBE_EVENT_NOW(WEMEET::AbilityConfig::kEventAbilityConfigChanged, &this_class::OnEventUiControlConfigChanged);
  END_SUBSCRIBE_EVENT()

void ApplicationModel::OnEventUiControlConfigChanged(FRAMEWORK::Variant* param) {
  bool beacon_log_report_enable = GetAbilityValueAsBool("analysis", "beacon-log-report-enable", true);
  bool wemeet_log_report_enable = GetAbilityValueAsBool("analysis", "wemeet-log-report-enable", true);
  BASE_ANALYTICS::SetBeaconLogEventReportEnable(beacon_log_report_enable);
  BASE_ANALYTICS::SetWemeetLogEventReportEnable(wemeet_log_report_enable);
  log_info << "beacon_log_report_enable = " << beacon_log_report_enable;
  log_info << "wemeet_log_report_enable = " << wemeet_log_report_enable;
}
```

### 增加兼容接口

- base层 analytics.h接口

```javascript
结构体 AnalyticsSettings  
增加会议自建上报通道域名字段 wemeet_log_event_report_host

新增加两个接口初始化和反初始化会议自建上报通道 InitializeWemeetLogEventReport  UninitializeWemeetLogEventReport
BASE_EXPORT void InitializeWemeetLogEventReport(base::shared_ptr<Analyser> analyser);
BASE_EXPORT void UninitializeWemeetLogEventReport();

新增加 SetBeaconLogEventReportEnable  SetWemeetLogEventReportEnable接口设置上报通道开关
BASE_EXPORT void SetBeaconLogEventReportEnable(bool enable);
BASE_EXPORT void SetWemeetLogEventReportEnable(bool enable);

修改LogEventWithProperties的内部实现兼容新老通道
BASE_EXPORT void LogEventWithProperties(const std::string& event_name,
                                        std::map<std::string, std::string>&& event_properties);

//新增数据上报接口
  virtual void LogEventWithProperties(const std::string& event_name,
                                      const std::map<std::string,std::string>& event_properties,
                                      const std::map<std::string, std::string>& default_properties,
                                      bool beacon_enable = false) = 0;

//新增更新公参接口
  virtual void UpdateDefaultParam(const std::map<std::string, std::string>& default_properties,
                                  const std::string& key, 
                                  const std::string& value) = 0;
```

### 新增模块介绍

wemeet_sdk层新增wmp_event_reporter模块来实现自建上报通道的逻辑

- 新增EventReportStorage类用于缓存请求的数据信息。
  提供初始化本地缓存、添加请求缓存、删除请求、获取所有请求缓存等接口。
- 新增EventReportRequest类用于存储请求的全量公共参数，事件参数，事件名称、增量公共参数、请求类型等信息
- 新增EventReportImpl类实现base::analytics::Analyser接口
  用于https长连接管理、上传队列管理、本地缓存管理等

```javascript
class BASE_EXPORT Analyser : public base::enable_shared_from_this<Analyser> {
public:
  virtual ~Analyser() = default;
  
  virtual void Run() = 0;
  
  virtual void SetUserId(const std::string& user_id) = 0;
  virtual void SetSessionId(const std::string& session_id) = 0;
  virtual void SetVipLevel(const std::string& vip_level) = 0;
  virtual void SetAppId(const std::string& app_id) = 0;
  
  virtual void LogEventWithProperties(const std::string& event_name,
                                      const std::map<std::string,
                                      std::string>& event_properties) = 0;
  
  virtual void LogQualityEventWithProperties(int64_t source_id,
                                             const std::string& event_name,
                                             const std::map<std::string, std::string>& properties,
                                             const std::map<std::string, std::string>& default_properties) = 0;

  virtual void LogEventWithProperties(const std::string& event_name,
                                      const std::map<std::string,std::string>& event_properties,
                                      const std::map<std::string, std::string>& default_properties,
                                      bool beacon_enable = false) = 0;//新增接口

  virtual void UpdateDefaultParam(const std::map<std::string, std::string>& default_properties,
                                  const std::string& key, 
                                  const std::string& value) = 0;//新增接口
};
```

## 新旧通道数据对比

| 老通道开关 | 新通道开关 |                          操作(备注)                          |
| ---------- | ---------- | :----------------------------------------------------------: |
| 开启       | 开启       | 1.客户端根据协议字段通知wemeet log srv 上报到不同的灯塔数据源 2. 客户端新增一个验证事件，使用该事件对比新通道上传质量 3. 老通道上报到线上灯塔数据源，新通道上报到测试灯塔数据源 |
| 关闭       | 关闭       |    1. 客户端强制设置开启老通道 ，数据上报到线上灯塔数据源    |
| 开启       | 关闭       | 1. 新通道出现问题时，切换到老通道，数据上报到线上灯塔数据源  |
| 关闭       | 开启       |    1. 新通道没问题，老通道下线，数据上报到线上灯塔数据源     |







腾讯的TDBank（腾讯分布式数据库，Tencent Distributed Database）是腾讯内部广泛使用的一种分布式数据库系统。它主要用于处理腾讯内部各种业务的大规模数据存储和管理需求。以下是对TDBank的详细解释：

### TDBank的特点和功能

1. **高可用性和可靠性**：
   - 通过分布式架构实现高可用性，能够在硬件或网络故障时自动进行故障切换，保证数据的持续可用性。
   - 提供数据备份和恢复功能，确保数据的完整性和安全性。
2. **高性能和扩展性**：
   - 设计为支持大规模数据处理和存储，能够处理高并发的读写请求。
   - 采用水平扩展（sharding）技术，可以根据业务需求动态增加或减少存储节点，提升系统的扩展能力。
3. **灵活的数据模型**：
   - 支持多种数据模型，包括关系型数据模型和非关系型数据模型，满足不同业务场景的需求。
   - 提供灵活的数据查询和处理能力，支持复杂的查询和分析操作。
4. **强一致性和最终一致性**：
   - 通过分布式事务和一致性协议，保证数据在多个节点之间的强一致性。
   - 对于一些业务场景，也可以提供最终一致性，以提升系统的性能和可用性。
5. **多租户支持**：
   - 设计为支持多租户环境，可以为不同业务线和团队提供隔离的数据存储和管理服务。

### TDBank的架构

TDBank通常由以下几个主要组件组成：

1. **数据节点（Data Nodes）**：
   - 存储实际的数据，负责处理数据的读写请求。
   - 通过分片（sharding）技术将数据分布在多个数据节点上，以提升存储和处理能力。
2. **元数据管理（Metadata Management）**：
   - 管理数据库的元数据，包括数据分片信息、节点信息等。
   - 负责协调数据节点之间的通信和数据分布。
3. **查询引擎（Query Engine）**：
   - 负责处理和优化数据查询请求，生成高效的查询执行计划。
   - 支持多种查询语言和接口，满足不同的查询需求。
4. **事务管理（Transaction Management）**：
   - 提供分布式事务支持，保证数据操作的原子性和一致性。
   - 通过事务协调器（Transaction Coordinator）管理跨节点的事务操作。
5. **监控和运维（Monitoring and Operations）**：
   - 提供系统的监控和运维工具，实时监控系统的运行状态和性能指标。
   - 支持自动化的运维操作，包括故障检测、恢复和负载均衡等。





在后台开发和数据处理的上下文中，“公参”和“私参”是指公共参数和私有参数。它们在不同的应用场景下有着不同的定义和用途。

### 公参（公共参数）

公共参数（公参）是指在多种场景中都会用到的通用参数。这些参数通常在每个请求中都需要携带，并且它们的值在同一个请求的多个部分中可能是相同的。公共参数通常包括以下内容：

1. **服务器相关信息**：
   - `server_ip`：服务器的IP地址。
   - `server_time`：服务器的当前时间戳。
2. **请求相关信息**：
   - `event_code`：事件代码，用于标识不同的事件类型。
   - `event_value`：事件值，通常是经过处理和加密后的业务参数。
3. **客户端相关信息**：
   - `client_ip`：客户端的IP地址，用于地理位置识别或用户行为分析。
   - `city`：客户端所在城市，通常根据IP地址解析。

公共参数的特点是它们对于所有请求来说都是通用的，可以在不同的请求和响应中重复使用。

### 私参（私有参数）

私有参数（私参）是指特定于某个业务逻辑或特定请求的参数。它们通常在一个特定的上下文中使用，不会在多个请求之间共享。私有参数的处理往往涉及到更多的业务逻辑和安全措施，如加密和解密操作。私有参数包括：

1. **业务逻辑相关信息**：
   - `user_id`：用户ID，特定于某个用户。
   - `transaction_id`：事务ID，用于标识一个特定的事务。
   - `order_id`：订单ID，用于标识一个特定的订单。
2. **敏感信息**：
   - `password`：用户密码，需要加密处理。
   - `credit_card_number`：信用卡号，需要加密处理。

私有参数的特点是它们在不同的请求之间是独立的，不会在不同请求之间重复使用。

### 代码中公参和私参的使用

在代码中，公参和私参分别存储在不同的 `map` 中，并在不同的阶段进行处理。例如：

```
go
复制代码
destEvent := make(map[string]string)
util.CopyMap(req.EventValue, destEvent) // 私参的处理
EncryptBackendSelfParaData(c, req.GetEventCode(), destEvent)

req.CommParams["event_value"] = url.QueryEscape(eventValue) // 公参的设置
req.CommParams["server_ip"] = util.GetLocalIp()
req.CommParams["server_time"] = strconv.FormatInt(time.Now().Unix(), 10)
req.CommParams["event_code"] = req.GetEventCode()
```

在这段代码中：

- `req.EventValue` 中存储的是私有参数，它们经过复制和加密后存储在 `destEvent` 中。
- `req.CommParams` 中存储的是公共参数，包括 `server_ip`、`server_time`、`event_code` 等。







<img src="/Users/giffinhao/Library/Application Support/typora-user-images/image-20240723164645797.png" alt="image-20240723164645797" style="zoom:50%;" />





OIDB协议（OpenID-Based Database）是一种由腾讯公司设计和实现的协议，用于实现基于OpenID的数据库访问和操作。OIDB协议通常用于大规模分布式系统中的数据查询和管理，尤其在一些需要高并发、高性能的场景下使用。

### 主要特点和功能

1. **高性能和高并发**：
   - 设计用于大规模分布式系统，能够处理大量并发请求，确保高性能的数据访问和操作。
2. **数据一致性**：
   - 采用多种技术手段保证数据的一致性和可靠性，避免数据丢失和错误。
3. **灵活的查询和管理**：
   - 支持复杂的查询操作和灵活的数据管理功能，能够满足多样化的业务需求。
4. **安全性**：
   - 通过OpenID进行身份验证，确保数据访问的安全性，防止未经授权的访问。

### 典型使用场景

1. **用户数据管理**：
   - 在大规模用户数据管理系统中，OIDB协议能够高效地管理和查询用户数据，提供快速的响应时间。
2. **日志和监控数据收集**：
   - 在日志系统和监控系统中，使用OIDB协议可以高效地收集和处理大量的日志和监控数据，帮助及时发现和解决问题。
3. **分布式数据库查询**：
   - 在分布式数据库系统中，OIDB协议能够支持复杂的查询操作，确保数据的高可用性和一致性。

### 例子：OIDB协议在日志系统中的应用

在上面的代码示例中，`log_svr_oidb`服务定义了一些RPC接口，通过OIDB协议处理日志上报请求。这些接口包括`ReportMonitor`用于上报监控数据，`ServerReportMap`用于通过Map形式请求到后端，以及`ServerReportString`用于通过String形式请求到后端等。

### 代码示例解析

```
protobuf
复制代码
//oidb协议定义service
service log_svr_oidb { 
    //秒空的上报
   rpc ReportMonitor(ServerReq) returns (ServerRsp);//@alias=/0x916000/1
}
//oidb协议定义后台的上报
service backend_report_oidb{
   //服务端上报比如tdbank请求
   rpc ServerReportMap(BackendReportMapReq)returns (BackendReportMapRsp);//@alias=/0x916000/2
   //服务端上报比如tdbank请求string 格式
   rpc ServerReportString(BackendReportStringReq)returns (BackendReportStringRsp);//@alias=/0x916000/3
   //服务端上报标准格式
   rpc ServerReport(BackendReportReq)returns (BackendReportRsp);//@alias=/0x916000/4
}
```

上述代码定义了两个服务`log_svr_oidb`和`backend_report_oidb`，分别用于处理日志上报和后台数据上报。每个服务中定义了多个RPC接口，这些接口通过OIDB协议接收客户端或其他服务的请求，执行相应的操作，并返回结果。







### 链路

```


1.// ServerReport ...
func (s *BackendReportHttpServiceImpl) ServerReport(ctx context.Context,
	req *pb.BackendReportReq, rsp *pb.BackendReportRsp) error {
	// implement business logic here ...
	// ...
	head := thttp.Head(ctx).Response.Header()
	head.Set("Content-Type", "application/json; charset=UTF-8")
	log.DebugContextf(ctx, "http.ServerReport :%+v", *req)
	metrics.IncrCounter("BackendReportHttpServiceImpl.ServerReport", 1)
	b := &BackendReportOidbServiceImpl{}
	return b.ServerReport(ctx, req, rsp)
}

2. ServerReport 方法
// 功能：处理接收标准格式的后端报告请求。调用 mtx.HandleStrategyAction 执行策略和动作。

// ServerReport ...标准的格式
func (s *BackendReportOidbServiceImpl) ServerReport(ctx context.Context,
	req *pb.BackendReportReq, rsp *pb.BackendReportRsp) error {
	defer func(startTime time.Time) {
		ms := []*metrics.Metrics{
			metrics.NewMetrics("BackendReportOidb.ServerReport", 1, metrics.PolicySUM),
			metrics.NewMetrics("BackendReportOidb.ServerReport.time", float64(time.Since(startTime).Microseconds()),
				metrics.PolicyAVG),
		}
		metrics.Report(metrics.NewMultiDimensionMetrics(nil, ms))
	}(time.Now())
	newCtx, tMtx := mtx.CreateMtxBackStandard(ctx, pb.REQ_TYPE_REQ_TYPE_BACKEND_STANDARD, req) // 上下文
	ctx = newCtx
	// 执行策略和动作，获取规则，并遍历所有规则。
	mtx.HandleStrategyAction(tMtx, tMtx.Params)
	rsp.RetCode = proto.Int32(0)
	rsp.RetMsg = proto.String("success")

	return nil
}


3.// HandleStrategyAction 请求的处理入口
func HandleStrategyAction(tMtx *TMtxContext, ruleMap map[string]interface{}) (int32, error) {
	// 获取规则，并遍历所有规则。
	rows := rpc.GetRuleRows() // 遍历所有规则
	for _, v := range rows {
		if !CheckRule(v) { // 检查模块灰度参数
			continue
		}
		if ruleMap == nil || len(ruleMap) == 0 {
			ruleMap = tMtx.Params
		}
		DoMtxStrategy(tMtx, v, ruleMap)
	}
	if tMtx.MatchFlag == false {
		log.ErrorContextf(tMtx.Ctx, "Strategy.NoMatch:%v,%+v,%+v,", tMtx.ReqType, ruleMap, ruleMap["Req"])
		// 此处逻辑是屏蔽扫描的
		if tMtx.Req.Channel == "client" {
			isScan := rpc.IsScanRequest(tMtx.Ctx)
			tMtx.IsScan = isScan
			// false表示不是扫描的
			if isScan == false {
				metrics.IncrCounter("HandleReport.Strategy.NoMatch.Error", 1)
			}
		} else {
			// 都加
			metrics.IncrCounter("HandleReport.Strategy.NoMatch.Error", 1)
		}
	}

	if tMtx.SendFlag == false {
		metrics.IncrCounter("HandleReport.SendAction.Error", 1)
		log.ErrorContextf(tMtx.Ctx, "HandleReport.SendAction.Error:%v,%+v", tMtx.ReqType, ruleMap)
	}
	return 0, nil
}

4.// DoMtxStrategy 函数通过解析传入参数、执行规则、生成数据并根据规则中的动作执行相应操作
func DoMtxStrategy(c *TMtxContext, row *rpc.TableRow, params map[string]interface{}) (int32, error) {
	// 增加日志
	log.DebugContextf(c.Ctx, "DoMtxStrategy begin params :%+v", params)
	// 设置上下文的 ID、规则 ID 以及参数。
	c.Id = row.ID
	c.RuleId = row.RuleId
	c.Params = params
	c.curExpr = express.CreateExpress(c.Ctx)                     // 创建表达式
	retCode, retErr := c.curExpr.DoStrategy(row.RulePtr, params) // 执行json规则
	// 创建表达式并执行规则。如果规则执行失败，则返回错误码和错误信息。
	if retCode != int32(pb.RETURN_CODE_SUCCESS) {
		return retCode, retErr
	}
	// 调用 MakeFormatData 函数生成数据。如果生成数据失败，则记录错误日志并返回错误码和错误信息。
	retCode, retErr = MakeFormatData(c, row)
	if retCode != int32(pb.RETURN_CODE_SUCCESS) {
		log.ErrorContextf(c.Ctx, "MakeFormatData error")
		return retCode, retErr
	}
	// 执行action
	if len(row.RulePtr.Action) <= 0 {
		log.ErrorContextf(c.Ctx, "DoMtxAction action is empty")
		return int32(pb.RETURN_CODE_ERR_SYSTEM), fmt.Errorf("strategy is empty")
	}
	c.MatchFlag = true
	// 此处逻辑是屏蔽扫描的
	if c.Req.Channel == "client" {
		isScan := rpc.IsScanRequest(c.Ctx)
		c.IsScan = isScan
		if isScan == true {
			return 0, nil
		}
	}
	// 如果请求类型是客户端请求，增加计数器 GenReportEventTrans.total.after。
	if c.ReqType == pb.REQ_TYPE_REQ_TYPE_CLIENT {
		metrics.IncrCounter("GenReportEventTrans.total.after", 1)
	}
	return SendAction(c, row.RulePtr.Action)
}

5.// SendAction 只用来做发送到其他管道的
// SendAction 目前支持atta/tdbank，未来会支持更多的管道比如kafka，大同等
func SendAction(c *TMtxContext, actArray []*express.Action) (int32, error) {
	// 记录函数开始执行的时间，用于后面计算执行时间
	commBegin := time.Now().UnixNano() / 1000
	if printActionFlag() {
		log.InfoContextf(c.Ctx, "SendAction Params:%+v", c.Params)
	}
	// 遍历每个 Action，依次执行。
	for _, value := range actArray {
		// 如果 Action 的 When 条件不为空，执行条件表达式。如果条件表达式执行失败或结果不为 true，跳过当前 Action
		if len(value.When) > 0 {
			result, err := c.curExpr.DoExpress(value.When, c.Params)
			if err != nil {
				//如果 ConnInfo 不为空，解析其为 url.Values 格式。如果解析失败，记录错误日志并跳过当前 Action。
				log.ErrorContextf(c.Ctx, "(SendAction) DoExpress fail express:%s err:%s",
					value.When, err.Error())
				continue
			}
			rst, ok := result.(bool)
			if !ok {
				log.ErrorContextf(c.Ctx, "(SendAction) DoExpress fail express:%s err:%s",
					value.When, err.Error())
				continue
			}
			if !rst {
				continue
			}
		}

		log.DebugContextf(c.Ctx, "(SendAction) DoExpress success:%+v,req:%+v,action:%+v",
			c.Params, c.Params["Req"], value)
		if printActionFlag() {
			log.InfoContextf(c.Ctx, "SendAction DoExpress value:%+v", value)
		}
		var vMap url.Values
		var vErr error
		// 如果 ConnInfo 不为空，解析其为 url.Values 格式。如果解析失败，记录错误日志并跳过当前 Action。
		if len(value.ConnInfo) > 0 {
			vMap, vErr = url.ParseQuery(value.ConnInfo)
			if vErr != nil {
				log.ErrorContextf(c.Ctx, "(SendAction) ParseQuery error:%v,action:%+v", vErr, value)
				continue
			}
		}
		//如果 SampleRate 大于 0.0，随机采样决定是否继续执行。
		if value.SampleRate > 0.0 {
			if rand.Float64() > value.SampleRate {
				continue
			}
		}

		log.DebugContextf(c.Ctx, "(SendAction) begin send :%+v", value)
		//根据 Action 的 Type 字段，调用不同的发送函数执行具体的发送操作，并设置 SendFlag 为 true。
		if value.Type == int32(pb.CONN_TYPE_TDBANK) {
			c.SendFlag = true
			sendTdbank(c, value, vMap)
			// break
		}
		if value.Type == int32(pb.CONN_TYPE_ATTA) {
			c.SendFlag = true
			sendAtta(c, vMap)
		}
		if value.Type == int32(pb.CONN_TYPE_TDBANK_COMM_MONITOR) {
			c.SendFlag = true
			sendTdbankComm(c, vMap)
		}
		// 1和4，以及本条件其实是一样的，本质上就是tdbank的表字段不一致，根据配置生成不同的配置
		// 但是目前仅支持客户端
		if value.Type == int32(pb.CONN_TYPE_TDBANK_PUBLIC) {
			c.SendFlag = true
			sendTdbankPublic(c, value, vMap)
		}

		if value.Type == int32(pb.CONN_TYPE_KAFKA) {
			c.SendFlag = true
			sendKafka(c, vMap)
		}
		// 只在测试环境生效
		if value.Type == 6 {
			c.SendFlag = true
			sendClickHouse(c)
		}
	}
	commCost := time.Now().UnixNano()/1000 - commBegin
	log.DebugContextf(c.Ctx, "(SendAction)cost time :%v μs", commCost)
	return 0, nil
}

//6.sendAtta 封装发送 ATTA ，默认
func sendAtta(c *TMtxContext, vMap url.Values) error {
	// 定义并初始化 AttaInfo 结构体
	var stAtta rpc.AttaInfo
	stAtta.AttaId = vMap["AttaId"][0]
	stAtta.AttaToken = vMap["AttaToken"][0]
	stAtta.AttaAppKey = vMap["AttaAppKey"][0]
	stAtta.AttaEncode = rpc.ENCODE_GBK // 默认编码为 GBK
	if _, ok := vMap["AttaEncode"]; ok {
		stAtta.AttaEncode = vMap["AttaEncode"][0]
	}

	// 增加 SendAtta 总计数的指标
	metrics.IncrCounter("SendAtta.Total", 1)
	// 生成 ATTA 数据
	sendData := MakeAttaData(c, stAtta.AttaAppKey, stAtta.AttaEncode)
	if len(sendData) <= 0 {
		metrics.IncrCounter("SendAtta.MakeAttaData.empty", 1)
		log.ErrorContextf(c.Ctx, "sendAtta MakeAttaData is empty")
		return fmt.Errorf("atta data is empty")
	}

	// 检查是否需要发送 ATTA 数据
	if c.IsSendAtta == false {
		metrics.IncrCounter("SendAtta.false.total", 1)
		return nil
	}

	// 增加对应 ATTA ID 的计数器
	metrics.IncrCounter("SendAtta."+stAtta.AttaId, 1)
	// 发送 ATTA 数据
	sendErr := rpc.SendBinary(c.Ctx, sendData, stAtta.AttaId, stAtta.AttaToken)
	if sendErr != nil {
		metrics.IncrCounter("SendAtta.SendBatchBinary.error", 1)
		log.ErrorContextf(c.Ctx, "SendBatchBinary error %v", sendErr)
		log.ErrorContextf(c.Ctx, "SendAttaFail|%v|%v|%v|%v|%v",
			c.Req.EventCode, c.Req.DeviceID, stAtta.AttaId, stAtta.AttaToken, string(sendData))
		return sendErr
	}

	// 如果 SampleFlag 为 true，记录成功发送的日志
	if c.SampleFlag {
		log.InfoContextf(c.Ctx, "SendAttaSuccess|%v|%v|%v|%v", c.Req.EventCode, c.Req.DeviceID,
			c.Req.Uid, string(sendData))
	}
	return nil
}
//7.MakeAttaData 创建atta格式的数据
func MakeAttaData(c *TMtxContext, appKey string, encode string) []byte {
	// 检查请求类型是否为客户端请求
	if c.ReqType == pb.REQ_TYPE_REQ_TYPE_CLIENT {
		// 直接走上报处理
		sErr := MakeClientAttaData(c, appKey, encode)
		if sErr != nil {
			// 如果处理出错，增加错误计数器
			metrics.IncrCounter("MakeClientAttaData.error", 1)
		}
		// 增加生成数据的总次数计数器
		metrics.IncrCounter("GenReportEventTrans.total.MakeData", 1)
		// 返回客户端请求生成的atta数据
		return c.AttaResult
	} else if c.ReqType == pb.REQ_TYPE_REQ_TYPE_BACKEND_STANDARD {
		// 初始化dataMap为一个空的map，用于存储公共参数和业务参数
		dataMap := make(map[string]string)
		if _, ok := dataMap["event_code"]; !ok {
			// 如果dataMap中没有event_code，从BackendStandardReq获取事件代码并添加到dataMap中
			dataMap["event_code"] = c.BackendStandardReq.GetEventCode()
		}

		// 加密公参（公共参数）
		util.CopyMap(c.BackendStandardReq.CommParams, dataMap)
		// 记录公参日志
		log.DebugContextf(c.Ctx, "MakeAttaData(CommParams):%+v", dataMap)
		EncryptPublicParaData(c, dataMap["event_code"], dataMap)

		// 加密私参（私有参数）
		eventMap := make(map[string]string)
		util.CopyMap(c.BackendStandardReq.EventValue, eventMap)
		// 记录私参日志
		log.DebugContextf(c.Ctx, "MakeAttaData(EventValue):%+v", c.BackendStandardReq.EventValue)
		EncryptBackendSelfParaData(c, dataMap["event_code"], eventMap)

		// 将加密后的私参从eventMap复制到dataMap
		util.CopyMap(eventMap, dataMap)
		if clientIp, ok := dataMap["client_ip"]; ok {
			// 如果dataMap中包含client_ip，根据client_ip获取城市信息并复制到dataMap中
			cityMap := IpCityByIp(c.Ctx, clientIp)
			util.CopyMap(cityMap, dataMap)
		}
		// 删除dataMap中的event_value，因为已直接复制
		delete(dataMap, "event_value")
		// 生成后台事件数据
		backendResult := GenBackendEvent(c, dataMap, appKey)
		if len(backendResult) <= 0 {
			// 如果生成的后台事件数据为空，记录错误日志
			log.ErrorContextf(c.Ctx, "MakeAttaData BACKEND_STANDARD :%+v,appKey:%+v", dataMap, appKey)
		}
		// 返回生成的数据的字节数组形式
		return []byte(backendResult)
	} else {
		// 如果请求类型既不是客户端请求也不是标准后台请求，增加错误请求类型的计数器并记录错误日志
		metrics.IncrCounter("MakeAttaData.Error.ReqType", 1)
		log.ErrorContextf(c.Ctx, "MakeAttaData error ReqType:%+v", c.ReqType)
	}
	// 返回空字节数组
	return []byte("")
}
//8. EncryptBackendPublicParaData 针对腾讯会议后台的公参数据，进行加密
func EncryptPublicParaData(c *TMtxContext, eventCode string, reqMap map[string]string) {
	// 记录加密前的公参数据日志
	log.InfoContextf(c.Ctx, "Before EncryptBackendPublicParaData (isTxCrop:%v):%+v", c.IsEncrypt, reqMap)

	// 腾讯企业加密则加密
	if c.IsEncrypt == true {
		// 对指定字段（"uid", "meeting_code"）进行加密
		EncryptMutilFiled(c, reqMap, TXGCbcKey, "uid", "meeting_code")
	}
	// 记录加密后的公参数据日志
	log.InfoContextf(c.Ctx, "After EncryptBackendPublicParaData (isTxCrop:%v):%+v", c.IsEncrypt, reqMap)
}
//9. EncryptMutilFiled 针对腾讯会议的数据，进行加密
func EncryptMutilFiled(c *TMtxContext, reqMap map[string]string, key string, fields ...string) {
	for _, field := range fields {
		EncryptField(c, reqMap, field, key)
	}
	log.DebugContextf(c.Ctx, "EncryptMutilFiled:%+v, fields:%+v", reqMap, fields)
}

//10.EncryptTXField 针对单个字段进行加密的
func EncryptField(c *TMtxContext, reqMap map[string]string, field string, enKey string) {
	iv := enKey
	// 从reqMap中获取需要加密的字段值
	tmpField, ok := reqMap[field]
	if ok {
		// 调用CBCEncrypter函数进行加密
		err, enField := util.CBCEncrypter([]byte(tmpField), []byte(enKey), []byte(iv))
		if err != nil {
			log.ErrorContextf(c.Ctx, "EncryptField CBCEncrypter error:%+v,filed:%+v", err, field)
		} else {
			reqMap[field] = string(enField)
		}
		// tmpField：占位符 %+v 的第一个参数，表示原始字段值。
		//string(enField)：占位符 %+v 的第二个参数，表示加密后的字段值。
		//enKey：占位符 %+v 的第三个参数，表示使用的密钥。
		if field == "uid" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [uid]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "meeting_code" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [meeting_code]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "nick_name" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [nick_name]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "nickname" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [nickname]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "nick_name_0" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [nick_name_0]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "old_nick_name_0" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [old_nick_name_0]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "creator_nick_name" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [creator_nick_name]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "src_user_name" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [src_user_name]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "tar_user_name" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [tar_user_name]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "phone" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [phone]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "phone_number" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [phone_number]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "phone-number" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [phone-number]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "tar_phone" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [tar_phone]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "src_phone" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [src_phone]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "phone_id_0" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [phone_id_0]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "email" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [email]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "tar_email" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [tar_email]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "src_email" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [src_email]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "rooms_report_issue_user_emails" {
			log.InfoContextf(c.Ctx,
				"EncryptData-EncryptField [rooms_report_issue_user_emails]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		}
	}
}
```

curl -X POST http://11.160.91.152:39004/api/server-report-standard \
-H "Content-Type: application/json" \
-d '{
  "request_time": 1690214725000,
  "event_code": "e#create_meeting",
  "comm_params": {
    "uid": "user123",
    "meeting_code": "meeting456",
    "corp_id": "1400115281"
  },
  "event_value": {
    "param1": "value1",
    "param2": "value2"
  },
  "client_ip": "192.168.1.1",
  "client_params": {
    "client_param1": "value1"
  },
  "server_params": {
    "server_param1": "value1"
  },
  "version": "1.0"
}'



Calleetrpc.wemeet.log_svr.backend_report_http/api/server-report-standardtraceIDe4366c956c9ee8de0de341f77068c872Message{\"request_time\":1690214725000,\"event_code\":\"e#create_meeting\",\"comm_params\":{\"corp_id\":\"1400115281\",\"meeting_code\":\"meeting456\",\"uid\":\"user123\"},\"event_value\":{\"param1\":\"value1\",\"param2\":\"value2\"},\"client_ip\":\"192.168.1.1\",\"client_params\":{\"client_param1\":\"value1\"},\"server_params\":{\"server_param1\":\"value1\"},\"version\":\"1.0\"}Serverlog_svrRemote11.160.91.152:48292EnvtestTimestamp2024-07-24 18:28:34.221Linelog/filter.go:318spanIDdfbda3d943c77c84TypeRequestCallertrpc.http.upserver.upservice/TraceId523931172472904600LevelINFOsampledfalsetime2024-07-24 18:28:35.011__FILENAME__/logdata/backend_report/trpc.log__SOURCE__11.160.91.152__HOSTNAME__wemeet-backend-report-test-0__INDEXNAME__backend_report__cicd_7e8c9ec4

以下是解释 `traceIDe4366c956c9ee8de0de341f77068c872` 中的日志信息，该日志记录了一个 `BackendReportReq` 请求的详细信息和相关上下文：

### 请求信息

- **Callee**: `trpc.wemeet.log_svr.backend_report_http/api/server-report-standard`

  - 请求的目标接口或服务。

- **Trace ID**: `traceIDe4366c956c9ee8de0de341f77068c872`

  - 用于跟踪请求的唯一标识符，便于调试和监控。

- **Message**: 请求的详细内容

  ```
  json
  复制代码
  {
    "request_time": 1690214725000,
    "event_code": "e#create_meeting",
    "comm_params": {
      "corp_id": "1400115281",
      "meeting_code": "meeting456",
      "uid": "user123"
    },
    "event_value": {
      "param1": "value1",
      "param2": "value2"
    },
    "client_ip": "192.168.1.1",
    "client_params": {
      "client_param1": "value1"
    },
    "server_params": {
      "server_param1": "value1"
    },
    "version": "1.0"
  }
  ```

  - **request_time**: 发送请求的时间戳（以毫秒为单位）。
  - **event_code**: 事件代码，此处为 `e#create_meeting`。
  - **comm_params**: 公共参数，包括 `corp_id`、`meeting_code` 和 `uid`，这些字段可能需要进行加密处理。
  - **event_value**: 业务参数，包含键值对 `param1` 和 `param2`。
  - **client_ip**: 上报的机器 IP 地址。
  - **client_params**: 客户端透传参数。
  - **server_params**: 服务端透传参数。
  - **version**: 请求的版本号。

### 服务器日志信息

- **Server**: `log_svr`
  - 处理请求的服务名称。
- **Remote**: `11.160.91.152:48292`
  - 请求来自的远程地址和端口。
- **Env**: `test`
  - 请求处理环境，此处为测试环境。
- **Timestamp**: `2024-07-24 18:28:34.221`
  - 记录日志的时间戳。
- **Line**: `log/filter.go:318`
  - 代码行数和文件路径，表示日志记录的位置。
- **spanID**: `dfbda3d943c77c84`
  - 该请求的 span ID，用于分布式跟踪。
- **Type**: `Request`
  - 日志类型，此处为请求日志。
- **Caller**: `trpc.http.upserver.upservice/TraceId523931172472904600`
  - 调用者信息，通常是上游服务的名称或标识符。
- **Level**: `INFO`
  - 日志级别，此处为信息级别。
- **sampled**: `false`
  - 是否采样记录，`false` 表示未进行采样。
- **time**: `2024-07-24 18:28:35.011`
  - 处理请求的结束时间。
- ***\*FILENAME\****: `/logdata/backend_report/trpc.log`
  - 日志文件的路径。
- ***\*SOURCE\****: `11.160.91.152`
  - 记录日志的服务器 IP 地址。
- ***\*HOSTNAME\****: `wemeet-backend-report-test-0`
  - 记录日志的主机名称。
- ***\*INDEXNAME\****: `backend_report`
  - 日志索引名称。
- **__cicd_7e8c9ec4**:
  - CI/CD 相关的标识符或标签，用于区分不同的构建或部署版本。



### 创建会议curl

curl -X POST http://11.160.91.152:39004/api/server-report-standard \
    -H "Content-Type: application/json" \
    -d '{
        "request_time": 1690214725000,
        "event_code": "e#create_meeting",
        "comm_params": {
            "corp_id": "1400115281",
            "meeting_code": "meeting456",
            "uid": "user123",
            "product": "meeting",
            "source_id": "2"
        },
        "event_value": {
            "param1": "value1",
            "param2": "value2",
            "creator_corp_id": "creator_corp_id_value"
        },
        "client_ip": "192.168.1.1",
        "client_params": {
            "client_param1": "value1"
        },
        "server_params": {
            "server_param1": "value1"
        },
        "version": "1.0"
    }'

这个protobuf定义文件主要描述了一个用于日志服务器的协议。以下是主要的定义和描述：

1. **REPORT_FLAG 枚举**：定义了几种上报标志。
   - `REPORT_FLAG_DEFAULT`: 默认不带公参的上报。
   - `REPORT_FLAG_INIT`: 需要重新全量公参的情况。
   - `REPORT_FLAG_UPDATE`: 更新公参。
   - `REPORT_FLAG_TRANS`: 透传的能力，不需要读取redis公参。
2. **REQ_TYPE 枚举**：定义了请求结构体的类型。
   - `REQ_TYPE_DEFAULT`: 什么类型都不是。
   - `REQ_TYPE_CLIENT`: 客户端上报来源。
   - `REQ_TYPE_SECOND`: 秒控上报。
   - `REQ_TYPE_BACKEND_MAP`: 服务端map格式上报。
   - `REQ_TYPE_BACKEND_STRING`: 服务端string格式上报。
   - `REQ_TYPE_BACKEND_STANDARD`: 后端上报的标准格式。
3. **CONN_TYPE 枚举**：定义了连接类型。
   - `DEFAULT`: 什么类型都不是。
   - `TDBANK`: TDBANK。
   - `ATTA`: ATTA。
   - `KAFKA`: KAFKA。
   - `TDBANK_COMM_MONITOR`: 发送到监控类的tdbank表。
   - `TDBANK_PUBLIC`: 根据加载的配置表生成公参。
4. **RETURN_CODE 枚举**：定义了返回代码。
   - `SUCCESS`: 成功。
   - `ERR_SYSTEM`: 系统错误。
   - `ERR_PARAMETER`: 错误的上报参数。
   - `ERR_NO_MATCH`: 没有匹配到规则。
   - `ERR_SESSION_ID`: 错误的session_id。
   - `ERR_STORE_SESSION`: session id 没保存。
   - `ERR_UPDATE_COMM`: 更新公参失败。
   - `ERR_SEESION_SEQ`: 错误序列号。
5. **CLIENT_ACTION 枚举**：定义了客户端动作。
   - `ACTION_DEFAULT`: 默认无意义。
   - `UPDATE_COMM`: 强制更新公参。
   - `MUST_TRANS`: 在redis挂掉的情况下，强制透传消息。
6. **PRODUCT_TYPE 枚举**：定义了产品类型。
   - `PRODUCT_DEFAULT`: 无意义。
   - `RRODUCT_MEETING`: 国内会议。
   - `RRODUCT_VOOV`: 海外。
   - `RRODUCT_CALENDAR`: 日历。
7. **MEETING_TYPE 枚举**：定义了会议类型。
   - `MEETING_TYPE_DEFAULT`: 无意义。
   - `MEETING_TYPE_NORMAL`: 普通会议。
   - `MEETING_TYPE_CYCLE`: 周期性会议。
   - `MEETING_TYPE_PMI`: PMI会议。
8. **SCENE_TYPE 枚举**：定义了会议场景。
   - `SCENE_TYPE_DEFAULT`: 无意义。
   - `SCENE_TYPE_NORMAL`: 普通场景会议。
   - `SCENE_TYPE_WEBNIAR`: webniar会议。
   - `SCENE_TYPE_GROUP`: 分组会议。
9. **GetHealthReq 和 GetHealthRsp 消息**：用于健康检查请求和响应。
10. **EventParams 消息**：定义了事件参数，包括事件代码、事件值和事件发生时间。
11. **MessCommParams 消息**：定义了公参结构体，用于设置序列化到redis中。
12. **BasicMessageReq 和 BasicMessageRsp 消息**：定义了基础消息请求和响应，包括报告命令、请求时间、客户端IP、公参列表、事件参数等。
13. **ServerReq 和 ServerRsp 消息**：定义了秒级监控上报协议请求和响应，包括tdbank_bid、tdbank_tid、系统ID、接口ID、日志时间等。
14. **BackendReportMapReq 和 BackendReportMapRsp 消息**：通过map的形式请求到后端，包括请求时间、客户端IP、公参列表和事件参数等。
15. **BackendReportReq 和 BackendReportRsp 消息**：后台标准形式的上报请求和响应，包括请求时间、事件代码、公参列表、事件值、客户端IP等。
16. **BackendReportStringReq 和 BackendReportStringRsp 消息**：通过string的形式请求到后端，包括请求时间、客户端IP、事件代码和事件值等。
17. **Events 和 BeaconReq, BeaconRsp 消息**：用于兼容灯塔协议上报的能力，包括应用版本、SDK ID、SDK版本、公参和业务私参等。





{
  "request_time": 1721836763000,
  "event_code": "security_access_log",
  "comm_params": {
    "access_obj": ".meet.dashboard.real-time-mra-connect-count|",
    "access_time": "2024-07-24 23:59:23",
    "access_type": "未知",
    "ip": "10.64.35.43",
    "log_msg": "",
    "module_name": "https://cowork-test.console.woa.com/meeting-connector",
    "platform_name": "cowork",
    "port": "57771",
    "security_level": "3",
    "user": "forestfu"
  },
  "event_value": {
    "getParams": "[]",
    "postParams": "{\"corp_id\":\"1400143280\"}",
    "response": "{\"mraConnectCount\":\"0\",\"nowSipNum\":0,\"mraVideoConnectCount\":\"0\",\"mraAudioConnectCount\":\"0\"}"
  },
  "client_ip": "11.141.178.92"
}s

### 测试公参

curl -X POST http://11.160.91.152:39004/api/server-report-standard \
     -H "Content-Type: application/json" \
     -d '{
          "request_time": 1721873603000,
          "event_code": "security_access_log",
          "comm_params": {
            "corp_id": "1400115281",
            "access_obj": ".meet.dashboard.real-time-mra-connect-count|",
            "access_time": "2024-07-25 10:13:23",
            "access_type": "未知",
            "ip": "10.64.35.33",
            "log_msg": "",
            "module_name": "https://cowork-test.console.woa.com/meeting-connector",
            "platform_name": "cowork",
            "port": "56424",
            "security_level": "3",
            "server_ip": "11.160.91.152",
            "server_time": "1721873603",
            "user": "forestfu",
            "meeting_code": "meeting789",
            "uid": "123"
          },
          "event_value": {
            "getParams": "[]",
            "postParams": "{\"corp_id\":\"1400143280\"}",
            "response": "{\"mraConnectCount\":\"0\",\"nowSipNum\":0,\"mraVideoConnectCount\":\"0\",\"mraAudioConnectCount\":\"0\"}"
          },
          "client_ip": "11.141.178.92",
          "client_params": {},
          "server_params": {},
          "version": "1.0"
        }'



```


1.// ServerReport ...
func (s *BackendReportHttpServiceImpl) ServerReport(ctx context.Context,
	req *pb.BackendReportReq, rsp *pb.BackendReportRsp) error {
	// implement business logic here ...
	// ...
	head := thttp.Head(ctx).Response.Header()
	head.Set("Content-Type", "application/json; charset=UTF-8")
	log.DebugContextf(ctx, "http.ServerReport :%+v", *req)
	metrics.IncrCounter("BackendReportHttpServiceImpl.ServerReport", 1)
	b := &BackendReportOidbServiceImpl{}
	return b.ServerReport(ctx, req, rsp)
}

2. ServerReport 方法
// 功能：处理接收标准格式的后端报告请求。调用 mtx.HandleStrategyAction 执行策略和动作。

// ServerReport ...标准的格式
func (s *BackendReportOidbServiceImpl) ServerReport(ctx context.Context,
	req *pb.BackendReportReq, rsp *pb.BackendReportRsp) error {
	defer func(startTime time.Time) {
		ms := []*metrics.Metrics{
			metrics.NewMetrics("BackendReportOidb.ServerReport", 1, metrics.PolicySUM),
			metrics.NewMetrics("BackendReportOidb.ServerReport.time", float64(time.Since(startTime).Microseconds()),
				metrics.PolicyAVG),
		}
		metrics.Report(metrics.NewMultiDimensionMetrics(nil, ms))
	}(time.Now())
	newCtx, tMtx := mtx.CreateMtxBackStandard(ctx, pb.REQ_TYPE_REQ_TYPE_BACKEND_STANDARD, req) // 上下文
	ctx = newCtx
	// 执行策略和动作，获取规则，并遍历所有规则。
	mtx.HandleStrategyAction(tMtx, tMtx.Params)
	rsp.RetCode = proto.Int32(0)
	rsp.RetMsg = proto.String("success")

	return nil
}


3.// HandleStrategyAction 请求的处理入口
func HandleStrategyAction(tMtx *TMtxContext, ruleMap map[string]interface{}) (int32, error) {
	// 获取规则，并遍历所有规则。
	rows := rpc.GetRuleRows() // 遍历所有规则
	for _, v := range rows {
		if !CheckRule(v) { // 检查模块灰度参数
			continue
		}
		if ruleMap == nil || len(ruleMap) == 0 {
			ruleMap = tMtx.Params
		}
		DoMtxStrategy(tMtx, v, ruleMap)
	}
	if tMtx.MatchFlag == false {
		log.ErrorContextf(tMtx.Ctx, "Strategy.NoMatch:%v,%+v,%+v,", tMtx.ReqType, ruleMap, ruleMap["Req"])
		// 此处逻辑是屏蔽扫描的
		if tMtx.Req.Channel == "client" {
			isScan := rpc.IsScanRequest(tMtx.Ctx)
			tMtx.IsScan = isScan
			// false表示不是扫描的
			if isScan == false {
				metrics.IncrCounter("HandleReport.Strategy.NoMatch.Error", 1)
			}
		} else {
			// 都加
			metrics.IncrCounter("HandleReport.Strategy.NoMatch.Error", 1)
		}
	}

	if tMtx.SendFlag == false {
		metrics.IncrCounter("HandleReport.SendAction.Error", 1)
		log.ErrorContextf(tMtx.Ctx, "HandleReport.SendAction.Error:%v,%+v", tMtx.ReqType, ruleMap)
	}
	return 0, nil
}

4.// DoMtxStrategy 函数通过解析传入参数、执行规则、生成数据并根据规则中的动作执行相应操作
func DoMtxStrategy(c *TMtxContext, row *rpc.TableRow, params map[string]interface{}) (int32, error) {
	// 增加日志
	log.DebugContextf(c.Ctx, "DoMtxStrategy begin params :%+v", params)
	// 设置上下文的 ID、规则 ID 以及参数。
	c.Id = row.ID
	c.RuleId = row.RuleId
	c.Params = params
	c.curExpr = express.CreateExpress(c.Ctx)                     // 创建表达式
	retCode, retErr := c.curExpr.DoStrategy(row.RulePtr, params) // 执行json规则
	// 创建表达式并执行规则。如果规则执行失败，则返回错误码和错误信息。
	if retCode != int32(pb.RETURN_CODE_SUCCESS) {
		return retCode, retErr
	}
	// 调用 MakeFormatData 函数生成数据。如果生成数据失败，则记录错误日志并返回错误码和错误信息。
	retCode, retErr = MakeFormatData(c, row)
	if retCode != int32(pb.RETURN_CODE_SUCCESS) {
		log.ErrorContextf(c.Ctx, "MakeFormatData error")
		return retCode, retErr
	}
	// 执行action
	if len(row.RulePtr.Action) <= 0 {
		log.ErrorContextf(c.Ctx, "DoMtxAction action is empty")
		return int32(pb.RETURN_CODE_ERR_SYSTEM), fmt.Errorf("strategy is empty")
	}
	c.MatchFlag = true
	// 此处逻辑是屏蔽扫描的
	if c.Req.Channel == "client" {
		isScan := rpc.IsScanRequest(c.Ctx)
		c.IsScan = isScan
		if isScan == true {
			return 0, nil
		}
	}
	// 如果请求类型是客户端请求，增加计数器 GenReportEventTrans.total.after。
	if c.ReqType == pb.REQ_TYPE_REQ_TYPE_CLIENT {
		metrics.IncrCounter("GenReportEventTrans.total.after", 1)
	}
	return SendAction(c, row.RulePtr.Action)
}

5.// SendAction 只用来做发送到其他管道的
// SendAction 目前支持atta/tdbank，未来会支持更多的管道比如kafka，大同等
func SendAction(c *TMtxContext, actArray []*express.Action) (int32, error) {
	// 记录函数开始执行的时间，用于后面计算执行时间
	commBegin := time.Now().UnixNano() / 1000
	if printActionFlag() {
		log.InfoContextf(c.Ctx, "SendAction Params:%+v", c.Params)
	}
	// 遍历每个 Action，依次执行。
	for _, value := range actArray {
		// 如果 Action 的 When 条件不为空，执行条件表达式。如果条件表达式执行失败或结果不为 true，跳过当前 Action
		if len(value.When) > 0 {
			result, err := c.curExpr.DoExpress(value.When, c.Params)
			if err != nil {
				//如果 ConnInfo 不为空，解析其为 url.Values 格式。如果解析失败，记录错误日志并跳过当前 Action。
				log.ErrorContextf(c.Ctx, "(SendAction) DoExpress fail express:%s err:%s",
					value.When, err.Error())
				continue
			}
			rst, ok := result.(bool)
			if !ok {
				log.ErrorContextf(c.Ctx, "(SendAction) DoExpress fail express:%s err:%s",
					value.When, err.Error())
				continue
			}
			if !rst {
				continue
			}
		}

		log.DebugContextf(c.Ctx, "(SendAction) DoExpress success:%+v,req:%+v,action:%+v",
			c.Params, c.Params["Req"], value)
		if printActionFlag() {
			log.InfoContextf(c.Ctx, "SendAction DoExpress value:%+v", value)
		}
		var vMap url.Values
		var vErr error
		// 如果 ConnInfo 不为空，解析其为 url.Values 格式。如果解析失败，记录错误日志并跳过当前 Action。
		if len(value.ConnInfo) > 0 {
			vMap, vErr = url.ParseQuery(value.ConnInfo)
			if vErr != nil {
				log.ErrorContextf(c.Ctx, "(SendAction) ParseQuery error:%v,action:%+v", vErr, value)
				continue
			}
		}
		//如果 SampleRate 大于 0.0，随机采样决定是否继续执行。
		if value.SampleRate > 0.0 {
			if rand.Float64() > value.SampleRate {
				continue
			}
		}

		log.DebugContextf(c.Ctx, "(SendAction) begin send :%+v", value)
		//根据 Action 的 Type 字段，调用不同的发送函数执行具体的发送操作，并设置 SendFlag 为 true。
		if value.Type == int32(pb.CONN_TYPE_TDBANK) {
			c.SendFlag = true
			sendTdbank(c, value, vMap)
			// break
		}
		if value.Type == int32(pb.CONN_TYPE_ATTA) {
			c.SendFlag = true
			sendAtta(c, vMap)
		}
		if value.Type == int32(pb.CONN_TYPE_TDBANK_COMM_MONITOR) {
			c.SendFlag = true
			sendTdbankComm(c, vMap)
		}
		// 1和4，以及本条件其实是一样的，本质上就是tdbank的表字段不一致，根据配置生成不同的配置
		// 但是目前仅支持客户端
		if value.Type == int32(pb.CONN_TYPE_TDBANK_PUBLIC) {
			c.SendFlag = true
			sendTdbankPublic(c, value, vMap)
		}

		if value.Type == int32(pb.CONN_TYPE_KAFKA) {
			c.SendFlag = true
			sendKafka(c, vMap)
		}
		// 只在测试环境生效
		if value.Type == 6 {
			c.SendFlag = true
			sendClickHouse(c)
		}
	}
	commCost := time.Now().UnixNano()/1000 - commBegin
	log.DebugContextf(c.Ctx, "(SendAction)cost time :%v μs", commCost)
	return 0, nil
}

//6.sendAtta 封装发送 ATTA ，默认
func sendAtta(c *TMtxContext, vMap url.Values) error {
	// 定义并初始化 AttaInfo 结构体
	var stAtta rpc.AttaInfo
	stAtta.AttaId = vMap["AttaId"][0]
	stAtta.AttaToken = vMap["AttaToken"][0]
	stAtta.AttaAppKey = vMap["AttaAppKey"][0]
	stAtta.AttaEncode = rpc.ENCODE_GBK // 默认编码为 GBK
	if _, ok := vMap["AttaEncode"]; ok {
		stAtta.AttaEncode = vMap["AttaEncode"][0]
	}

	// 增加 SendAtta 总计数的指标
	metrics.IncrCounter("SendAtta.Total", 1)
	// 生成 ATTA 数据
	sendData := MakeAttaData(c, stAtta.AttaAppKey, stAtta.AttaEncode)
	if len(sendData) <= 0 {
		metrics.IncrCounter("SendAtta.MakeAttaData.empty", 1)
		log.ErrorContextf(c.Ctx, "sendAtta MakeAttaData is empty")
		return fmt.Errorf("atta data is empty")
	}

	// 检查是否需要发送 ATTA 数据
	if c.IsSendAtta == false {
		metrics.IncrCounter("SendAtta.false.total", 1)
		return nil
	}

	// 增加对应 ATTA ID 的计数器
	metrics.IncrCounter("SendAtta."+stAtta.AttaId, 1)
	// 发送 ATTA 数据
	sendErr := rpc.SendBinary(c.Ctx, sendData, stAtta.AttaId, stAtta.AttaToken)
	if sendErr != nil {
		metrics.IncrCounter("SendAtta.SendBatchBinary.error", 1)
		log.ErrorContextf(c.Ctx, "SendBatchBinary error %v", sendErr)
		log.ErrorContextf(c.Ctx, "SendAttaFail|%v|%v|%v|%v|%v",
			c.Req.EventCode, c.Req.DeviceID, stAtta.AttaId, stAtta.AttaToken, string(sendData))
		return sendErr
	}

	// 如果 SampleFlag 为 true，记录成功发送的日志
	if c.SampleFlag {
		log.InfoContextf(c.Ctx, "SendAttaSuccess|%v|%v|%v|%v", c.Req.EventCode, c.Req.DeviceID,
			c.Req.Uid, string(sendData))
	}
	return nil
}
//7.MakeAttaData 创建atta格式的数据
func MakeAttaData(c *TMtxContext, appKey string, encode string) []byte {
	// 检查请求类型是否为客户端请求
	if c.ReqType == pb.REQ_TYPE_REQ_TYPE_CLIENT {
		// 直接走上报处理
		sErr := MakeClientAttaData(c, appKey, encode)
		if sErr != nil {
			// 如果处理出错，增加错误计数器
			metrics.IncrCounter("MakeClientAttaData.error", 1)
		}
		// 增加生成数据的总次数计数器
		metrics.IncrCounter("GenReportEventTrans.total.MakeData", 1)
		// 返回客户端请求生成的atta数据
		return c.AttaResult
	} else if c.ReqType == pb.REQ_TYPE_REQ_TYPE_BACKEND_STANDARD {
		// 初始化dataMap为一个空的map，用于存储公共参数和业务参数
		dataMap := make(map[string]string)
		if _, ok := dataMap["event_code"]; !ok {
			// 如果dataMap中没有event_code，从BackendStandardReq获取事件代码并添加到dataMap中
			dataMap["event_code"] = c.BackendStandardReq.GetEventCode()
		}

		// 加密公参（公共参数）
		util.CopyMap(c.BackendStandardReq.CommParams, dataMap)
		// 记录公参日志
		log.DebugContextf(c.Ctx, "MakeAttaData(CommParams):%+v", dataMap)
		EncryptPublicParaData(c, dataMap["event_code"], dataMap)

		// 加密私参（私有参数）
		eventMap := make(map[string]string)
		util.CopyMap(c.BackendStandardReq.EventValue, eventMap)
		// 记录私参日志
		log.DebugContextf(c.Ctx, "MakeAttaData(EventValue):%+v", c.BackendStandardReq.EventValue)
		EncryptBackendSelfParaData(c, dataMap["event_code"], eventMap)

		// 将加密后的私参从eventMap复制到dataMap
		util.CopyMap(eventMap, dataMap)
		if clientIp, ok := dataMap["client_ip"]; ok {
			// 如果dataMap中包含client_ip，根据client_ip获取城市信息并复制到dataMap中
			cityMap := IpCityByIp(c.Ctx, clientIp)
			util.CopyMap(cityMap, dataMap)
		}
		// 删除dataMap中的event_value，因为已直接复制
		delete(dataMap, "event_value")
		// 生成后台事件数据
		backendResult := GenBackendEvent(c, dataMap, appKey)
		if len(backendResult) <= 0 {
			// 如果生成的后台事件数据为空，记录错误日志
			log.ErrorContextf(c.Ctx, "MakeAttaData BACKEND_STANDARD :%+v,appKey:%+v", dataMap, appKey)
		}
		// 返回生成的数据的字节数组形式
		return []byte(backendResult)
	} else {
		// 如果请求类型既不是客户端请求也不是标准后台请求，增加错误请求类型的计数器并记录错误日志
		metrics.IncrCounter("MakeAttaData.Error.ReqType", 1)
		log.ErrorContextf(c.Ctx, "MakeAttaData error ReqType:%+v", c.ReqType)
	}
	// 返回空字节数组
	return []byte("")
}
//8. EncryptBackendSelfParaData 针对腾讯会议后台的私参数据，进行加密
func EncryptBackendSelfParaData(c *TMtxContext, eventCode string, reqMap map[string]string) {
    log.InfoContextf(c.Ctx, "Before EncryptBackendSelfParaData (isTxCrop:%v):%+v", c.IsEncrypt, reqMap)
    // 腾讯企业加密
    if c.IsEncrypt == true {
       envCorpId := "1400115281"
       // 测试环境好测试，加这个
       namespace := os.Getenv("namespace")
       if namespace == "Test" {
          envCorpId = "1400143280"
       }
       // 如果事件是“e#create_meeting” corp_id为腾讯企业 → 加密uid、会议主题 uid 在公参已经加密
       if strings.EqualFold(eventCode, "e#create_meeting") == true {
          EncryptMutilFiled(c, reqMap, TXGCbcKey, "uid")

          EncryptMutilFiled(c, reqMap, TXGCbcKey, "meeting_subject", "subject", "nick_name", "nickname",
             "src_user_name", "tar_user_name", "nick_name_0", "old_nick_name_0", "creator_nick_name", "phone",
             "phone_number", "phone-number", "tar_phone", "src_phone", "phone_id_0", "email", "tar_email",
             "src_email", "rooms_report_issue_user_emails")
       } else {
          // corp_id为腾讯企业 → 加密uid
          EncryptMutilFiled(c, reqMap, TXGCbcKey, "uid")

          EncryptMutilFiled(c, reqMap, TXGCbcKey, "meeting_subject", "subject", "nick_name", "nickname",
             "src_user_name", "tar_user_name", "nick_name_0", "old_nick_name_0", "creator_nick_name", "phone",
             "phone_number", "phone-number", "tar_phone", "src_phone", "phone_id_0", "email", "tar_email",
             "src_email", "rooms_report_issue_user_emails")
          creatorCorpID, ok := reqMap["creator_corp_id"]
          if ok && creatorCorpID == envCorpId {
             // creator_corp_id为腾讯企业 → 加密creator_uid
             EncryptMutilFiled(c, reqMap, TXGCbcKey, "creator_uid")
          }
       }
    } else {
       EncryptMutilFiled(c, reqMap, GCbcKey, "meeting_subject", "subject", "nick_name", "nickname",
          "src_user_name", "tar_user_name", "nick_name_0", "old_nick_name_0", "creator_nick_name", "phone",
          "phone_number", "phone-number", "tar_phone", "src_phone", "phone_id_0", "email", "tar_email",
          "src_email", "rooms_report_issue_user_emails")
    }
    log.InfoContextf(c.Ctx, "After EncryptBackendSelfParaData (isTxCrop:%v):%+v", c.IsEncrypt, reqMap)
}
// 9.EncryptMutilFiled 针对腾讯会议的数据，进行加密
func EncryptMutilFiled(c *TMtxContext, reqMap map[string]string, key string, fields ...string) {
	for _, field := range fields {
		EncryptField(c, reqMap, field, key)
	}
	log.DebugContextf(c.Ctx, "EncryptMutilFiled:%+v, fields:%+v", reqMap, fields)
}

//10.EncryptTXField 针对单个字段进行加密的
func EncryptField(c *TMtxContext, reqMap map[string]string, field string, enKey string) {
	iv := enKey
	// 从reqMap中获取需要加密的字段值
	tmpField, ok := reqMap[field]
	if ok {
		// 调用CBCEncrypter函数进行加密
		err, enField := util.CBCEncrypter([]byte(tmpField), []byte(enKey), []byte(iv))
		if err != nil {
			log.ErrorContextf(c.Ctx, "EncryptField CBCEncrypter error:%+v,filed:%+v", err, field)
		} else {
			reqMap[field] = string(enField)
		}
		// tmpField：占位符 %+v 的第一个参数，表示原始字段值。
		//string(enField)：占位符 %+v 的第二个参数，表示加密后的字段值。
		//enKey：占位符 %+v 的第三个参数，表示使用的密钥。
		if field == "uid" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [uid]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "meeting_code" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [meeting_code]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "nick_name" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [nick_name]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "nickname" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [nickname]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "nick_name_0" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [nick_name_0]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "old_nick_name_0" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [old_nick_name_0]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "creator_nick_name" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [creator_nick_name]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "src_user_name" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [src_user_name]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "tar_user_name" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [tar_user_name]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "phone" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [phone]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "phone_number" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [phone_number]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "phone-number" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [phone-number]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "tar_phone" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [tar_phone]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "src_phone" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [src_phone]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "phone_id_0" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [phone_id_0]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "email" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [email]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "tar_email" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [tar_email]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "src_email" {
			log.InfoContextf(c.Ctx, "EncryptData-EncryptField [src_email]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		} else if field == "rooms_report_issue_user_emails" {
			log.InfoContextf(c.Ctx,
				"EncryptData-EncryptField [rooms_report_issue_user_emails]:%+v,enField:%+v,GCbcKey:%+v",
				tmpField, string(enField), enKey)
		}
	}
}
```





### 测试腾讯企业 创建会议的私参

curl -X POST http://11.160.91.152:39004/api/server-report-standard \
    -H "Content-Type: application/json" \
    -d '{
        "request_time": 1690214725005,
        **"event_code": "e#create_meeting",**
        "comm_params": {
            **"corp_id": "1400115281",**
            "meeting_code": "meeting456",
            "product": "meeting",
            **"source_id": "2",**
            "user": "forestfu",
            **"uid": "123",**
            "ip": "10.64.35.55",
            "creator_corp_id": "1400143280",
            "creator_uid": "1400143280"
        },
        "event_value": {
            "postParams": "[]",
            "response": "[{\"corp_id\":\"1400115281\",\"status\":1}]",
            "creator_corp_id": "1400143280",
            "creator_uid": "1400143280",
            "uid": "123",
            **"meeting_subject": "aaa",**
            "subject": "test_subject",
            "nick_name": "test_nick_name",
            "nickname": "test_nickname",
            "src_user_name": "test_src_user_name",
            "tar_user_name": "test_tar_user_name",
            "nick_name_0": "test_nick_name_0",
            "old_nick_name_0": "test_old_nick_name_0",
            "creator_nick_name": "test_creator_nick_name",
            "phone": "1234567890",
            "phone_number": "0987654321",
            "phone-number": "1122334455",
            "tar_phone": "2233445566",
            "src_phone": "3344556677",
            "phone_id_0": "4455667788",
            "email": "test@example.com",
            "tar_email": "tar_test@example.com",
            "src_email": "src_test@example.com",
            "rooms_report_issue_user_emails": "issue_report@example.com"
        },
        "client_ip": "192.168.1.1",
        "client_params": {
            "client_param1": "value1"
        },
        "server_params": {
            "server_param1": "value1"
        },
        "version": "1.0"
    }'



测试客户端





### 测试腾讯企业 不创建会议的私参

curl -X POST http://11.160.91.152:39004/api/server-report-standard \
    -H "Content-Type: application/json" \
    -d '{
        "request_time": 1690214725000,
        **"event_code": "security_access_log",**
        "comm_params": {
            **"corp_id": "1400115284",**
            "meeting_code": "meeting456",
            "product": "meeting",
            "ip": "10.64.35.99",
            **"source_id": "2",**
            "user": "forestfu",
            "uid": "123",
            "creator_corp_id": "1400143284",
            "creator_uid": "1400143284"
        },
        "event_value": {
            "postParams": "[]",
            "response": "[{\"corp_id\":\"1400115281\",\"status\":1}]",
            "creator_corp_id": "1400143284",
            **"creator_uid": "1400143284",**
            "uid": "123",
            "meeting_subject": "aaa",
            "subject": "test_subject",
            "nick_name": "test_nick_name",
            "nickname": "test_nickname",
            "src_user_name": "test_src_user_name",
            "tar_user_name": "test_tar_user_name",
            "nick_name_0": "test_nick_name_0",
            "old_nick_name_0": "test_old_nick_name_0",
            "creator_nick_name": "test_creator_nick_name",
            "phone": "1234567890",
            "phone_number": "0987654321",
            "phone-number": "1122334455",
            "tar_phone": "2233445566",
            "src_phone": "3344556677",
            "phone_id_0": "4455667788",
            "email": "test@example.com",
            "tar_email": "tar_test@example.com",
            "src_email": "src_test@example.com",
            "rooms_report_issue_user_emails": "issue_report@example.com"
        },
        "client_ip": "192.168.1.1",
        "client_params": {
            "client_param1": "value1"
        },
        "server_params": {
            "server_param1": "value1"
        },
        "version": "1.0"
    }'



### 测试非腾讯会议后台

curl -X POST http://11.160.91.152:39004/api/server-report-standard \
     -H "Content-Type: application/json" \
     -d '{
          "request_time": 1721873603000,
          **"event_code": "security_access_log",**
          "comm_params": {
            **"corp_id": "1400115984",**
            "access_obj": ".meet.dashboard.real-time-mra-connect-count|",
            "access_time": "2024-07-25 10:13:23",
            "access_type": "未知",
            "ip": "10.64.35.33",
            "log_msg": "",

​	   **"source_id": "2",**

​            "module_name": "https://cowork-test.console.woa.com/meeting-connector",
​            "platform_name": "cowork",
​            "port": "56424",
​            "security_level": "3",
​            "server_ip": "11.160.91.152",
​            "server_time": "1721873603",
​            "user": "forestfu",
​            "meeting_code": "meeting789",
​            "uid": "123"
​          },
​          "event_value": {
​            "getParams": "[]",
​            "postParams": "{\"corp_id\":\"1400143280\"}",
​            "response": "{\"mraConnectCount\":\"0\",\"nowSipNum\":0,\"mraVideoConnectCount\":\"0\",\"mraAudioConnectCount\":\"0\"}"
​          },
​          "client_ip": "11.141.178.92",
​          "client_params": {},
​          "server_params": {},
​          "version": "1.0"
​        }'



### 测试非腾讯企业客户端私参

curl -X POST http://11.160.91.152:39004/api/server-report-standard \
    -H "Content-Type: application/json" \
    -d '{
        "request_time": 1690214725000,
        **"event_code": "security_access_log",**
        "comm_params": {
            **"corp_id": "1400990999",**
            "meeting_code": "meeting456",
            "product": "meeting",
            "ip": "10.64.35.55",
            **"source_id": "1",**
            "user": "forestfu",
            "uid": "123",
            "creator_corp_id": "1400143280",
            "creator_uid": "1400143280"
        },
        "event_value": {
            "getParams": "{\"corp_ids\":\"1400115280\"}",
            "postParams": "[]",
            "response": "[{\"corp_id\":\"1400115281\",\"status\":1}]",
            "creator_corp_id": "1400143280",
            "creator_uid": "1400143280",
            "uid": "123",
            "meeting_subject": "aaa",
            "subject": "test_subject",
            "nick_name": "test_nick_name",
            "nickname": "test_nickname",
            "src_user_name": "test_src_user_name",
            "tar_user_name": "test_tar_user_name",
            "nick_name_0": "test_nick_name_0",
            "old_nick_name_0": "test_old_nick_name_0",
            "creator_nick_name": "test_creator_nick_name",
            "phone": "1234567890",
            "phone_number": "0987654321",
            "phone-number": "1122334455",
            "tar_phone": "2233445566",
            "src_phone": "3344556677",
            "phone_id_0": "4455667788",
            "email": "test@example.com",
            "tar_email": "tar_test@example.com",
            "src_email": "src_test@example.com",
            "rooms_report_issue_user_emails": "issue_report@example.com"
        },
        "client_ip": "192.168.1.1",
        "client_params": {
            "client_param1": "value1"
        },
        "server_params": {
            "server_param1": "value1"
        },
        "version": "1.0"
    }'







### 测试腾讯企业 客户端私参

curl -X POST http://11.160.91.152:39004/api/server-report-standard \
    -H "Content-Type: application/json" \
    -d '{
        "request_time": 1690214725000,
        **"event_code": "security_access_log",**
        "comm_params": {
            **"corp_id": "1400115281",**
            "meeting_code": "meeting456",
            "product": "meeting",
            **"source_id": "1",**
            "user": "forestfu",
            "uid": "123",
            "creator_corp_id": "1400143280",
            "creator_uid": "1400143280"
        },
        "event_value": {
            "getParams": "{\"corp_ids\":\"1400115280\"}",
            "postParams": "[]",
            "response": "[{\"corp_id\":\"1400115281\",\"status\":1}]",
            "creator_corp_id": "1400143280",
            "creator_uid": "1400143280",
            "uid": "123",
            "meeting_subject": "aaa"
        },
        "client_ip": "192.168.1.1",
        "client_params": {
            "client_param1": "value1"
        },
        "server_params": {
            "server_param1": "value1"
        },
        "version": "1.0"
    }'



```
函数的主要目的是从配置中心获取配置信息，解析并将其加载到应用的内存中。过程中会对获取的配置进行解码，并根据规则字符串创建规则对象
	c, err := config.Get("rainbow").Get(trpc.BackgroundContext(), "")
	if err != nil {
		metrics.IncrCounter("loadTable.err", 1) //[rainbow]数据变化
		log.Errorf("get config failed: %s", err.Error())
		return err
	}
从配置中心获取名为 rainbow 的配置项。
如果获取配置失败，增加一个名为 loadTable.err 的计数器，并记录错误日志
//json 解码
	var t TbRows
	if err := json.Unmarshal([]byte(c.Value()), &t); err != nil {
		metrics.IncrCounter("loadTable.error", 1) //[rainbow]数据变化
		log.Errorf("Unmarshal  failed: %s", err.Error())
		return err
	}
将获取到的配置值进行 JSON 解码，并存储到 TbRows 类型的变量 t 中。
如果解码失败，增加一个名为 loadTable.error 的计数器，并记录错误日志。
for _, value := range t {
		log.Infof("config.GEventConf.Store %v,%v", value, value.ReportCmd)
		value.RulePtr, err = express.CreateRule(value.RuleStr)
		if err != nil {
			metrics.IncrCounter("loadTable.CreateRule.error", 1) //[rainbow]CreateRule失败
			log.Errorf("Create Rule fail err:%v v.RuleStr:%v ", err.Error(), value.RuleStr)
			continue
		}
遍历解码后的配置项。
记录每个配置项的 ReportCmd 值。
为每个配置项调用 express.CreateRule 函数，根据其 RuleStr 创建规则对象，并赋值给 RulePtr。
如果创建规则失败，增加一个名为 loadTable.CreateRule.error 的计数器，并记录错误日志。
go
复制代码
		enable, err := strconv.Atoi(value.EnableStr)
		if err != nil {
			metrics.IncrCounter("LoadTable.Atoi.Error", 1)
			log.Errorf("Atoi fail ruleId:%v row.Enable:%v, err:%v", value.ID, value.EnableStr, err.Error())
		}
		if enable == 1 {
			value.Enable = true
		}
将配置项的 EnableStr 字段转换为整数 enable。
如果转换失败，增加一个名为 LoadTable.Atoi.Error 的计数器，并记录错误日志。
如果 enable 等于 1，则将配置项的 Enable 字段设置为 true。
	}
	//加锁
	gMutex.Lock()
	gRuleTable = t
	gMutex.Unlock()
	log.Infof("GRuleTable len:%v ", len(gRuleTable))
	return nil
}
遍历完成后，加锁将配置项赋值给全局变量 gRuleTable。
记录 gRuleTable 的长度。
返回 nil 表示加载配置成功。
```











这条日志的记录说明了在 `rpc/rpc_rainbow.go` 文件第 260 行，有一个名为 `config.GEventConf.Store` 的函数被调用并记录了一条信息。以下是日志信息的详细解释：

### 日志结构和内容

- **Line**: `rpc/rpc_rainbow.go:260`
  - 表示日志记录的代码位置，即文件 `rpc_rainbow.go` 的第 260 行。
- **Message**: `config.GEventConf.Store &{...}`
  - 这是日志的主体部分，包含了 `config.GEventConf.Store` 函数的调用信息和其处理的配置信息。
- **Level**: `INFO`
  - 表示日志的级别是 `INFO`，即一般性的信息，不是错误或警告。
- **Timestamp**: `2024-07-25 16:40:01.809`
  - 表示日志记录的时间戳。
- **time**: `2024-07-25 16:40:02.028`
  - 这是另一个时间字段，可能用于表示操作的完成时间。
- ***\*FILENAME\****: `/logdata/backend_report/trpc.log`
  - 表示日志文件的路径。
- ***\*SOURCE\****: `11.150.246.137`
  - 表示日志来源的 IP 地址。
- ***\*HOSTNAME\****: `wemeet-backend-report-test-1`
  - 表示日志记录所在的主机名。
- ***\*INDEXNAME\****: `backend_report__cicd_7e8c9ec4`
  - 表示日志索引的名称，可能用于日志存储和检索系统。

### 配置信息

```
&{22 ctreewang 0 cmd_27 1 false 0 00000C2AM539PVHX {...} <nil>}
```

这是 `config.GEventConf.Store` 函数存储的配置信息，详细如下：

1. **ID**: `22`
   - 配置的唯一标识符。
2. **Name**: `ctreewang`
   - 配置的名称。
3. **Type**: `0`
   - 配置的类型，具体意义取决于上下文。
4. **Command**: `cmd_27`
   - 配置的命令或操作。
5. **Enable**: `1`
   - 配置是否启用，`1` 表示启用，`0` 表示禁用。
6. **IsDebug**: `false`
   - 是否处于调试模式。
7. **Version**: `0`
   - 配置的版本号。
8. **Key**: `00000C2AM539PVHX`
   - 配置的键。
9. **Rule**: `{\n \"Strategy\": [...],\n \"Action\": [...] }`
   - 配置的规则，包含策略和动作的定义。

### 规则解释

规则部分包含两个主要部分：策略 (`Strategy`) 和动作 (`Action`)。

- **Strategy**: 策略部分定义了配置的条件。

  ```
  json
  复制代码
  [
    {
      "Id": "1",
      "Condition": "Req.Product == 'tencent_oneid'  &&  Req.Channel == 'server'",
      "Name": "这里是分发腾讯oneid产品后台数据"
    }
  ]
  ```

  - **Id**: 策略的唯一标识符。
  - **Condition**: 策略条件，表示当请求的产品为 `tencent_oneid` 且渠道为 `server` 时，策略生效。
  - **Name**: 策略的描述或名称。

- **Action**: 动作部分定义了当策略条件满足时要执行的操作。

  ```
  json
  复制代码
  [
    {
      "Id": "2",
      "Type": 1,
      "ConnInfo": "BID=b_csig_tencent_meeting_dw&TID=oneid_official_server_test"
    }
  ]
  ```

  - **Id**: 动作的唯一标识符。
  - **Type**: 动作的类型，具体意义取决于上下文。
  - **ConnInfo**: 连接信息，包含 `BID` 和 `TID` 参数，表示动作执行时的目标。

### 日志含义总结

这条日志记录了在特定文件和行号调用 `config.GEventConf.Store` 函数时的配置信息。它详细展示了配置的各项参数，包括策略和动作定义。这条日志的级别是 `INFO`，表示这是一次正常的配置存储操作，没有错误或警告。日志中的时间戳和其他元数据提供了记录发生的时间和位置，便于后续的分析和调试。



#### log_svr_trpc.go 相当于Controller

```
// BackendReportHttpService_ServerReport_Handler 是一个处理 BackendReportHttpService 中 ServerReport 方法请求的 handler。
func BackendReportHttpService_ServerReport_Handler(svr interface{}, ctx context.Context, f server.FilterFunc) (interface{}, error) {

    // 初始化一个 BackendReportReq 对象 req，用于接收请求数据。
    req := &BackendReportReq{}

    // 调用过滤器函数 f，传入 req 对象。
    // filters 是过滤器处理后的对象，err 是可能的错误。
    filters, err := f(req)
    if err != nil {
        // 如果过滤器函数执行失败，返回错误。
        return nil, err
    }

    // 定义了一个内部函数 handleFunc，用于实际处理请求。
    handleFunc := func(ctx context.Context, reqbody interface{}, rspbody interface{}) error {
        // 将 svr 强制转换为 BackendReportHttpService 类型，然后调用 ServerReport 方法，
        // 传入 ctx、reqbody（转换为 *BackendReportReq）和 rspbody（转换为 *BackendReportRsp）。
        return svr.(BackendReportHttpService).ServerReport(ctx, reqbody.(*BackendReportReq), rspbody.(*BackendReportRsp))
    }

    // 初始化一个 BackendReportRsp 对象 rsp，用于存储响应数据。
    rsp := &BackendReportRsp{}

    // 调用 filters.Handle 方法，传入 ctx、req、rsp 和 handleFunc。
    // filters.Handle 会在处理请求的前后执行一些操作（如请求过滤、响应过滤），然后调用 handleFunc 处理请求。
    err = filters.Handle(ctx, req, rsp, handleFunc)
    if err != nil {
        // 如果 filters.Handle 执行失败，返回错误。
        return nil, err
    }

    // 返回响应对象 rsp 和 nil（表示没有错误）。
    return rsp, nil
}

```



```
CreateMtxBackStandard报错：
if rpc.IsTestCorp(corpID) || rpc.IsTestUser(appUid) {
		log.DebugContextf(ctx, "_msg=test corp or user||corp_id=%s||user_id=%s", corpID, appUid)
		paraReq.IsTest = 1
	} else {
		metrics.IncrCounter("TestCorp.TestUser.False", 1)
		log.ErrorContextf(ctx, "IsTestCorp and  IsTestUser is false:corpID[%+v],appUid[%+v]", corpID, appUid) // todo error
	}
	
从这行代码获取值：corpID, _ := mReq.CommParams["corp_id"]

从backend_oid的serverReport获取mReq

serverReport中打印没有corpId字段：log.DebugContextf(ctx, "http.ServerReport req:%+v", string(bytes))
```

这段代码定义了一个 gRPC 服务描述符 `BackendReportHttpServer_ServiceDesc`，用于注册服务 `trpc.wemeet.log_svr.backend_report_http`。该服务有三个方法，每个方法都有一个对应的处理函数。当客户端请求这些方法对应的 URL 路径时，gRPC 框架会调用相应的处理函数来处理请求。

当客户端请求一个 gRPC 服务的方法时，gRPC 框架会自动处理请求并将参数传递给相应的处理函数。在这种情况下，`BackendReportHttpService_ServerReport_Handler` 函数被调用，参数 `svr`, `ctx`, 和 `f` 会通过 gRPC 框架传递。

### 参数来源

1. **`svr` (Server)**

   - 这个参数是服务的实现实例。当 gRPC 服务被注册时，这个实例会被传递到处理函数中，以便调用具体的服务方法。

   - 来源

     ：在注册服务时通过 

     ```
     server.RegisterService
     ```

      方法传递。例如：

     ```
     go
     复制代码
     server.RegisterService(&BackendReportHttpServer_ServiceDesc, new(BackendReportHttpService))
     ```

2. **`ctx` (Context)**

   - `ctx` 是请求的上下文，包括请求的元数据、截止日期、取消信号等。这是 gRPC 框架自动生成并传递给每个处理函数的。
   - **来源**：由 gRPC 框架在处理请求时创建，并传递给处理函数。



```json
{
  "request_time": 1721960474000,
  "event_code": "security_access_log",
  "comm_params": {
    "access_obj": ".meet.meeting.cache|",
    "access_time": "2024-07-26 10:21:14",
    "access_type": "未知",
    "ip": "30.16.167.44",
    "log_msg": "",
    "module_name": "https://cowork-test.console.woa.com/meeting-detail",
    "platform_name": "cowork",
    "port": "49835",
    "security_level": "3",
    "user": "haronzhou"
  },
  "event_value": {
    "getParams": "{\"sdkAppid\":\"1400143280\",\"meetingId\":\"12054980632930454760\",\"memberId\":\"144115395661941997\",\"userId\":\"giffinhao\",\"type\":\"master\"}",
    "postParams": "[]",
    "response": ""
  },
  "client_ip": "11.141.178.92"
}

```

```
http的ServerReport -》backend_oid的serverReport-》cmd的HandleStrategyAction
```



测试客户端/api/data-report 39000

30.50.213.232

curl -X POST http://30.188.181.104:39000/api/data-report \
     -H "Content-Type: application/json" \
     -d '{
          "request_time": 1721873603007,
          "event_code": "security_access_log",
          "comm_params": {
            "corp_id": "1400115281",
            "access_obj": ".meet.dashboard.real-time-mra-connect-count|",
            "access_time": "2024-07-25 10:13:23",
            "access_type": "未知",
            "ip": "10.64.35.33",
            "log_msg": "",
            "module_name": "https://cowork-test.console.woa.com/meeting-connector",
            "platform_name": "cowork",
            "port": "56424",
            "security_level": "3",
            "server_ip": "11.160.91.152",
            "server_time": "1721873603",
            "user": "forestfu",
            "meeting_code": "meeting789",
            "uid": "123"
          },
          "event_value": {
            "getParams": "[]",
            "postParams": "{\"corp_id\":\"1400143280\"}",
            "response": "{\"mraConnectCount\":\"0\",\"nowSipNum\":0,\"mraVideoConnectCount\":\"0\",\"mraAudioConnectCount\":\"0\"}"
          },
          "client_ip": "11.141.178.92",
          "client_params": {},
          "server_params": {},
          "version": "1.0",
          "report_flag": "3"
        }'





### 测试公参

curl -X POST http://11.160.91.152:39004/api/server-report-standard \
     -H "Content-Type: application/json" \
     -d '{
          "request_time": 1721873603000,
          "event_code": "security_access_log",
          "comm_params": {
            "corp_id": "1400115281",
            "access_obj": ".meet.dashboard.real-time-mra-connect-count|",
            "access_time": "2024-07-25 10:13:23",
            "access_type": "未知",
            "ip": "10.64.35.33",
            "log_msg": "",
            "module_name": "https://cowork-test.console.woa.com/meeting-connector",
            "platform_name": "cowork",
            "port": "56424",
            "security_level": "3",
            "server_ip": "11.160.91.152",
            "server_time": "1721873603",
            "user": "forestfu",
            "meeting_code": "meeting789",
            "uid": "123"
          },
          "event_value": {
            "getParams": "[]",
            "postParams": "{\"corp_id\":\"1400143280\"}",
            "response": "{\"mraConnectCount\":\"0\",\"nowSipNum\":0,\"mraVideoConnectCount\":\"0\",\"mraAudioConnectCount\":\"0\"}"
          },
          "client_ip": "11.141.178.92",
          "client_params": {},
          "server_params": {},
          "version": "1.0"
        }'



### 测试腾讯企业 创建会议的私参

curl -X POST http://30.188.181.104:39004/api/server-report-standard \
    -H "Content-Type: application/json" \
    -d '{
        "request_time": 1690214725006,
        "event_code": "e#create_meeting",
        "comm_params": {
            "corp_id": "1400115281",
            "meeting_code": "meeting456",
            "product": "meeting",
            "source_id": "2",
            "user": "forestfu",
            "uid": "123",
            "ip": "10.64.35.55",
            "creator_corp_id": "1400143280",
            "creator_uid": "1400143280"
        },
        "event_value": {
            "getParams": "{\"corp_ids\":\"1400115280\"}",
            "postParams": "[]",
            "response": "[{\"corp_id\":\"1400115281\",\"status\":1}]",
            "creator_corp_id": "1400143280",
            "creator_uid": "1400143280",
            "uid": "123",
            "meeting_subject": "aaa",
            "subject": "test_subject",
            "nick_name": "test_nick_name",
            "nickname": "test_nickname",
            "src_user_name": "test_src_user_name",
            "tar_user_name": "test_tar_user_name",
            "nick_name_0": "test_nick_name_0",
            "old_nick_name_0": "test_old_nick_name_0",
            "creator_nick_name": "test_creator_nick_name",
            "phone": "1234567890",
            "phone_number": "0987654321",
            "phone-number": "1122334455",
            "tar_phone": "2233445566",
            "src_phone": "3344556677",
            "phone_id_0": "4455667788",
            "email": "test@example.com",
            "tar_email": "tar_test@example.com",
            "src_email": "src_test@example.com",
            "rooms_report_issue_user_emails": "issue_report@example.com"
        },
        "client_ip": "192.168.1.1",
        "client_params": {
            "client_param1": "value1"
        },
        "server_params": {
            "server_param1": "value1"
        },
        "version": "1.0"
    }'

![image-20240816180154640](/Users/giffinhao/Library/Application Support/typora-user-images/image-20240816180154640.png)





### 测试腾讯企业 不创建会议的私参且creatorcorp等于指定值

curl -X POST http://30.188.181.104:39004/api/server-report-standard \
    -H "Content-Type: application/json" \
    -d '{
        "request_time": 1690214725000,
        "event_code": "security_access_log",
        "comm_params": {
            "corp_id": "1400115284",
            "meeting_code": "meeting456",
            "product": "meeting",
            "ip": "10.64.35.99",
            "source_id": "2",
            "user": "forestfu",
            "uid": "123",
            "creator_corp_id": "1400115281",
            "creator_uid": "1400143284"
        },
        "event_value": {
            "getParams": "{\"corp_ids\":\"1400115280\"}",
            "postParams": "[]",
            "response": "[{\"corp_id\":\"1400115281\",\"status\":1}]",
            "creator_corp_id": "1400115281",
            "creator_uid": "1400143284",
            "uid": "123",
            "meeting_subject": "aaa",
            "subject": "test_subject",
            "nick_name": "test_nick_name",
            "nickname": "test_nickname",
            "src_user_name": "test_src_user_name",
            "tar_user_name": "test_tar_user_name",
            "nick_name_0": "test_nick_name_0",
            "old_nick_name_0": "test_old_nick_name_0",
            "creator_nick_name": "test_creator_nick_name",
            "phone": "1234567890",
            "phone_number": "0987654321",
            "phone-number": "1122334455",
            "tar_phone": "2233445566",
            "src_phone": "3344556677",
            "phone_id_0": "4455667788",
            "email": "test@example.com",
            "tar_email": "tar_test@example.com",
            "src_email": "src_test@example.com",
            "rooms_report_issue_user_emails": "issue_report@example.com"
        },
        "client_ip": "192.168.1.1",
        "client_params": {
            "client_param1": "value1"
        },
        "server_params": {
            "server_param1": "value1"
        },
        "version": "1.0"
    }'

### 测试非腾讯企业私参

curl -X POST http://30.188.181.104:39004/api/server-report-standard \
    -H "Content-Type: application/json" \
    -d '{
        "request_time": 1690214725000,
        "event_code": "security_access_log",
        "comm_params": {
            "corp_id": "1400115285",
            "meeting_code": "meeting456",
            "product": "meeting",
            "ip": "10.64.35.55",
            "source_id": "2",
            "user": "forestfu",
            "uid": "123",
            "creator_corp_id": "1400143287",
            "creator_uid": "1400143280"
        },
        "event_value": {
            "getParams": "{\"corp_ids\":\"1400115281\"}",
            "postParams": "[]",
            "response": "[{\"corp_id\":\"1400115281\",\"status\":1}]",
            "creator_corp_id": "1400143287",
            "creator_uid": "1400143280",
            "uid": "123",
            "meeting_subject": "aaa",
            "subject": "test_subject",
            "nick_name": "test_nick_name",
            "nickname": "test_nickname",
            "src_user_name": "test_src_user_name",
            "tar_user_name": "test_tar_user_name",
            "nick_name_0": "test_nick_name_0",
            "old_nick_name_0": "test_old_nick_name_0",
            "creator_nick_name": "test_creator_nick_name",
            "phone": "1234567890",
            "phone_number": "0987654321",
            "phone-number": "1122334455",
            "tar_phone": "2233445566",
            "src_phone": "3344556677",
            "phone_id_0": "4455667788",
            "email": "test@example.com",
            "tar_email": "tar_test@example.com",
            "src_email": "src_test@example.com",
            "rooms_report_issue_user_emails": "issue_report@example.com"
        },
        "client_ip": "192.168.1.1",
        "client_params": {
            "client_param1": "value1"
        },
        "server_params": {
            "server_param1": "value1"
        },
        "version": "1.0"
    }'

### 非腾讯客户端私参加密

#### **"01466b6306f15d9138570711073ad5cb"  AND "meeting_subject"**

<img src="/Users/giffinhao/Library/Application Support/typora-user-images/image-20240726165505572.png" alt="image-20240726165505572" style="zoom:50%;" />



"meeting_subject"  AND "c.IsTXEncrypt:true"

### 非腾讯客户端私参加密

#### "8f4a5c3d5223f714a5fe548ecb26f10a" AND "EncryptData-EncryptField"

<img src="/Users/giffinhao/Library/Application Support/typora-user-images/image-20240726170905276.png" alt="image-20240726170905276" style="zoom:50%;" />



### 腾讯客户端私参加密

#### "9745c80e664acf2f374c5df76789a6ef"  AND "EncryptData-EncryptField"

<img src="/Users/giffinhao/Library/Application Support/typora-user-images/image-20240726172007143.png" alt="image-20240726172007143" style="zoom:50%;" />

### 主要区别：

1. **角色不同**：
   - `customer.yaml` 配置的是Kafka消费者（consumer），用于从指定的主题中消费消息。
   - `trpc_go.yaml` 配置的是Kafka生产者（producer），用于向指定的主题中生产消息。
2. **参数配置**：
   - `customer.yaml` 中的 `address` 包含了 `topics` 和 `group` 参数，明确指定了消费者订阅的主题和所属的消费者组。
   - `trpc_go.yaml` 中的 `target` 包含了 `clientid`、`async` 和 `compression` 参数，明确指定了生产者客户端ID、是否异步生产以及消息压缩方式。
3. **协议和超时时间**：
   - 两者都指定了 `protocol` 为 `kafka`，并设置了超时时间，但具体值和含义略有不同。消费者的超时时间为6000毫秒，而生产者的超时时间为2000毫秒。

### 总结

- `customer.yaml` 文件主要配置了Kafka消费者，包括主题、消费者组和其他连接参数。
- `trpc_go.yaml` 文件主要配置了Kafka生产者，包括目标连接地址、客户端ID、异步生产和压缩选项。





Kafka客户端提供了不同的生产消息方式，每种方式都有其特定的使用场景和特点。以下是对这几种生产消息方式的详细解释：

### 1. `Produce` 方法

```
go
复制代码
func (c *kafkaCli) Produce(ctx context.Context, key, value []byte, headers ...sarama.RecordHeader) error
```

#### 特点：

- **同步生产**：默认情况下，该方法是同步的，调用者会等待消息发送完成后才会返回。
- **自定义选项**：可以通过配置选项来改变其行为，例如配置为异步生产。
- **返回结果**：主要关注是否发送成功，不关心具体的分区和偏移量。

#### 使用场景：

- 当需要确认消息是否发送成功时，可以使用此方法。
- 适合需要可靠性保证的场景。

### 2. `SendMessage` 方法

```
go
复制代码
func (c *kafkaCli) SendMessage(ctx context.Context, topic string, key, value []byte, headers ...sarama.RecordHeader) (partition int32, offset int64, err error)
```

#### 特点：

- **同步生产**：调用者会等待消息发送完成并返回分区和偏移量。
- **返回分区和偏移量**：除了确认消息是否发送成功，还会返回消息所在的分区和偏移量。

#### 使用场景：

- 当需要了解消息被存储的位置（分区和偏移量）时，可以使用此方法。
- 适合需要对消息存储位置进行管理和跟踪的场景。

### 3. `AsyncSendMessage` 方法

```
go
复制代码
func (c *kafkaCli) AsyncSendMessage(ctx context.Context, topic string, key, value []byte, headers ...sarama.RecordHeader) (err error)
```

#### 特点：

- **异步生产**：调用者不等待消息发送完成即返回，消息发送在后台进行。
- **高吞吐量**：由于不需要等待发送完成，可以极大提高消息发送的吞吐量。

#### 使用场景：

- 当需要快速发送大量消息且对每条消息的发送结果不特别关心时，可以使用此方法。
- 适合日志记录、指标收集等对实时性要求高但对可靠性要求相对较低的场景。

### 4. `SendSaramaMessage` 方法

```
go
复制代码
func (c *kafkaCli) SendSaramaMessage(ctx context.Context, sMsg sarama.ProducerMessage) (partition int32, offset int64, err error)
```

#### 特点：

- **直接使用Sarama原生消息**：允许直接使用Sarama的 `ProducerMessage` 结构体。
- **灵活性高**：可以利用Sarama的所有特性进行消息生产。

#### 使用场景：

- 当需要自定义消息的所有细节，利用Sarama库的高级特性时，可以使用此方法。
- 适合有复杂消息生产需求的场景，如设置自定义分区器、消息头等。

### 总结

不同的生产消息方式在同步性、灵活性和适用场景上有所区别：

- **同步 vs 异步**：
  - 同步方法（`Produce`, `SendMessage`）适用于需要确认消息发送成功的场景。
  - 异步方法（`AsyncSendMessage`）适用于需要高吞吐量、对发送结果不敏感的场景。
- **返回信息**：
  - `Produce` 方法仅返回发送是否成功。
  - `SendMessage` 和 `SendSaramaMessage` 方法返回消息的分区和偏移量。
- **灵活性**：
  - `SendSaramaMessage` 提供最高的灵活性，允许直接使用Sarama的 `ProducerMessage` 结构体。
  - 其他方法则封装了一些常用的生产行为，简化了调用。

根据具体的需求和应用场景，可以选择适合的生产消息方式来实现Kafka消息的生产。











package main

import (
	"log"

	"github.com/Shopify/sarama"
	"github.com/golang/protobuf/proto"
	"time"
	
	lpb "path/to/protobuf/definition"
)

func main() {
	// 配置 Kafka 生产者
	config := sarama.NewConfig()
	config.Producer.RequiredAcks = sarama.WaitForAll
	config.Producer.Retry.Max = 5
	config.Producer.Return.Successes = true

	// 连接到 Kafka 集群
	brokers := []string{"localhost:9092"} // 替换为实际的 Kafka broker 地址
	producer, err := sarama.NewSyncProducer(brokers, config)
	if err != nil {
		log.Fatalf("Failed to start Sarama producer: %v", err)
	}
	defer func() {
		if err := producer.Close(); err != nil {
			log.Fatalf("Failed to close Sarama producer: %v", err)
		}
	}()
	
	// 构造 BackendReportReq 消息
	backendReq := &lpb.BackendReportReq{
		RequestTime: 1690214725000,
		EventCode:   "security_access_log",
		CommParams: map[string]string{
			"corp_id":          "1400115281",
			"meeting_code":     "meeting456",
			"product":          "meeting",
			"source_id":        "5",
			"user":             "forestfu",
			"uid":              "123",
			"creator_corp_id":  "1400143280",
			"creator_uid":      "1400143280",
		},
		EventValue: map[string]string{
			"getParams":       "{\"corp_ids\":\"1400115280\"}",
			"postParams":      "[]",
			"response":        "[{\"corp_id\":\"1400115281\",\"status\":1}]",
			"creator_corp_id": "1400143280",
			"creator_uid":     "1400143280",
			"uid":             "123",
			"meeting_subject": "aaa",
		},
		ClientIp: "192.168.1.1",
		ClientParams: map[string]string{
			"client_param1": "value1",
		},
		ServerParams: map[string]string{
			"server_param1": "value1",
		},
		Version: "1.0",
	}
	
	// 序列化消息
	value, err := proto.Marshal(backendReq)
	if err != nil {
		log.Fatalf("Failed to marshal message: %v", err)
	}
	
	// 构造 Kafka 消息
	message := &sarama.ConsumerMessage{
		Headers:        []*sarama.RecordHeader{},
		Timestamp:      time.Now(),
		BlockTimestamp: time.Now(),
		Key:            []byte("exampleKey"),
		Value:          value,
		Topic:          "your_topic", // 替换为实际的 Kafka 主题名称
		Partition:      0,
		Offset:         1234,
	}
	
	// 打印构造好的 Kafka 消息内容
	log.Printf("Constructed Kafka Message:\n")
	log.Printf("Topic: %s\n", message.Topic)
	log.Printf("Partition: %d\n", message.Partition)
	log.Printf("Offset: %d\n", message.Offset)
	log.Printf("Key: %s\n", string(message.Key))
	log.Printf("Value: %s\n", string(message.Value))
	log.Printf("Timestamp: %s\n", message.Timestamp)
	log.Printf("BlockTimestamp: %s\n", message.BlockTimestamp)
	if len(message.Headers) > 0 {
		log.Printf("Headers:\n")
		for _, header := range message.Headers {
			log.Printf("  %s: %s\n", string(header.Key), string(header.Value))
		}
	}
	
	// 构造 Kafka 生产者消息
	producerMessage := &sarama.ProducerMessage{
		Topic: message.Topic,
		Key:   sarama.ByteEncoder(message.Key),
		Value: sarama.ByteEncoder(message.Value),
	}
	
	// 发送消息到 Kafka 主题
	partition, offset, err := producer.SendMessage(producerMessage)
	if err != nil {
		log.Fatalf("Failed to send message: %v", err)
	}
	
	log.Printf("Message is stored in topic(%s)/partition(%d)/offset(%d)\n", message.Topic, partition, offset)
}











从 `trpc_go.yaml` 配置文件的内容以及文件结构来看，当前项目既包含了服务端配置，也包含了客户端配置。具体来说：

- **Server 配置**：定义了服务端的信息，包括监听的 IP 和端口、使用的协议、服务名、应用名等。这些配置用于启动并运行一个服务，使其能够接收和处理来自客户端的请求。
- **Client 配置**：定义了客户端的信息，包括需要连接的后端服务的目标地址、协议、超时时间等。这些配置用于客户端连接到后端服务并发出请求。

### 项目是 Server 还是 Client？

从代码文件和配置文件可以看出：

1. **Server 配置**：
   - `server` 部分配置了多个服务，说明这个项目是一个服务端应用，能够监听指定的端口和协议，接收客户端的请求并处理。
2. **Client 配置**：
   - `client` 部分配置了多个后端服务的连接信息，说明这个项目在某些情况下会充当客户端，向其他后端服务发送请求。

### 结论

这个项目既是一个服务端（Server），也是一个客户端（Client）。它既可以接收和处理客户端的请求，又可以作为客户端向其他服务端发出请求。具体的角色取决于实际运行的功能和上下文。在分布式系统中，这种同时包含服务端和客户端配置的情况是很常见的。







一。一个项目配置多个服务，怎么决定哪个上游调哪个接口



二。为什么oidb又要转http







<img src="/Users/giffinhao/Library/Application Support/typora-user-images/image-20240805162509755.png" alt="image-20240805162509755" style="zoom:50%;" />







用户画像（User Profile）是指通过收集和分析用户的行为、属性、兴趣爱好、消费习惯、社交关系等信息，形成一个虚拟用户的综合性描述。用户画像广泛应用于数据分析、精准营销、推荐系统、个性化服务等领域。以下是用户画像的详细解释：

### 1. **用户画像的基本概念**

- **核心要素：**
  - **基础属性：** 用户的基本信息，如性别、年龄、职业、地理位置等。
  - **行为数据：** 用户的行为轨迹，如浏览记录、点击记录、购买记录、搜索历史等。
  - **兴趣爱好：** 通过用户的行为数据分析出用户的兴趣，如喜欢的商品类别、常看的内容类型等。
  - **社交关系：** 用户的社交圈信息，如好友关系、关注关系、社交互动等。

- **目的：**
  - 用户画像的主要目的是深入理解用户的需求和偏好，从而为其提供更精准、更个性化的服务。例如，根据用户画像推荐合适的产品或内容，提高用户的满意度和转化率。

### 2. **用户画像的构建过程**

- **数据采集：**
  - 从各种数据源（如网站、APP、社交媒体、电商平台）收集用户的行为数据、交易数据、社交数据等。

- **数据清洗：**
  - 对采集到的数据进行清洗和规范化处理，去除噪声数据，填补缺失值，确保数据的准确性和一致性。

- **特征提取：**
  - 从清洗后的数据中提取出有用的特征，例如用户的年龄、浏览历史、购买频率等。这些特征将用于后续的画像建模。

- **画像建模：**
  - 使用机器学习、统计分析等技术，结合提取的特征，构建用户画像模型。例如，可以通过聚类分析将用户分为不同的群体，或者通过分类模型预测用户的兴趣偏好。

- **画像应用：**
  - 将构建好的用户画像应用于各类业务场景，如个性化推荐、精准广告投放、客户细分等。用户画像还可以持续更新和优化，以保持其准确性。

### 3. **用户画像的应用场景**

- **精准营销：**
  - 根据用户画像，广告商可以投放精准的广告，以触达更有可能对其产品感兴趣的用户，从而提高广告的转化率和投资回报率。

- **推荐系统：**
  - 电子商务平台和内容平台常利用用户画像来推荐商品、文章、视频等。根据用户的历史行为和兴趣，提供个性化的推荐，提升用户体验。

- **客户关系管理（CRM）：**
  - 通过用户画像，企业可以更好地理解客户需求，进行客户分类和分层管理，从而制定更有效的营销策略和客户服务方案。

- **产品设计与优化：**
  - 产品经理可以基于用户画像分析出用户的需求和痛点，从而设计和优化产品功能，提升用户满意度。

### 4. **用户画像的挑战与问题**

- **数据隐私：**
  - 用户画像涉及大量的个人数据，因此如何保护用户隐私、确保数据安全是一个重要的挑战。法律法规（如 GDPR）对用户数据的采集和使用有严格的要求。

- **数据质量：**
  - 用户画像的准确性依赖于数据的质量。如果数据不完整或不准确，构建的用户画像可能会有偏差，从而影响决策和服务效果。

- **动态性：**
  - 用户的行为和兴趣是动态变化的，用户画像需要不断更新和调整，以反映用户的最新状态。这对数据分析和处理能力提出了更高的要求。

### 总结

用户画像是通过收集和分析用户数据，构建出虚拟用户的综合性描述，帮助企业更好地理解和服务用户。它在精准营销、推荐系统、客户管理等方面有广泛的应用，但同时也面临数据隐私、数据质量和动态性等挑战。有效的用户画像可以大大提升企业的营销效果和用户体验。





在内存中使用整型数组存储全量用户数据是一种数据结构设计方法，通常用于处理需要高效访问和操作的大规模数据集。下面详细解释这种存储方法的实现和其工作原理。

### 整型数组存储全量用户数据

#### 1. **基本概念**

- **整型数组：** 使用整数数组来存储用户数据，其中每个整数可以表示一个或多个用户 ID 的状态。例如，每个整数可以用来表示多个位（bits），每个位代表一个用户的存在状态（例如，1 表示存在，0 表示不存在）。
- **位图（Bitmap）：** 整型数组通常配合位操作（bitwise operations）使用，以有效管理和操作大规模的数据。例如，使用整数的每一位来表示用户的存在状态。

#### 2. **存储结构**

1. **定义存储范围：**

   - **ID 范围：** 假设你需要存储的用户 ID 范围为 `0` 到 `N-1`。如果 ID 的最大值是 2^32（即 uint32），那么可以使用整型数组来存储这些数据。

2. **数组的设计：**

   - **每个整数存储的位数：** 假设使用 32 位的整型数据，每个整数可以存储 32 个用户状态位。例如，如果有 100 万个用户，理论上需要大约 100 万 / 32 ≈ 31,250 个整数（整型）来存储所有用户的状态。

3. **数据存储示例：**

   - **数组元素：** 假设使用一个整数数组 `userStatus[]` 来存储用户状态，每个整数 `userStatus[i]` 可以表示 32 个用户的状态（使用位操作）。

   - 用户状态映射：

     - 对于用户 ID

        

       ```
       x
       ```

       ，可以通过位操作确定其在数组中的位置：

       - 数组索引：`index = x / 32`
       - 位位置：`bit = x % 32`

     - 设置用户状态：

       ```
       cpp
       复制代码
       userStatus[index] |= (1 << bit);  // 设置第 x 位为 1，表示用户存在
       ```

     - 清除用户状态：

       ```
       cpp
       复制代码
       userStatus[index] &= ~(1 << bit);  // 清除第 x 位，表示用户不存在
       ```

     - 检查用户状态：

       ```
       cpp
       复制代码
       bool exists = (userStatus[index] & (1 << bit)) != 0;  // 检查第 x 位是否为 1
       ```

#### 3. **优缺点分析**

**优点：**

- **内存效率高：** 位操作的方式非常节省内存，能够有效地处理大量用户数据。
- **快速访问：** 整型数组的访问速度很快，位操作也非常高效。

**缺点：**

- **没有分片支持：** 如果数据量非常大，没有分片机制的话，可能会导致单台机器内存使用不均或内存资源浪费。
- **扩展性问题：** 整型数组的大小是固定的，如果需要支持更大的 ID 范围，可能需要重新设计数据结构。
- **支持的 ID 范围限制：** 如果 ID 超过整型数的位数限制（如 uint32），需要考虑其他方案（如 uint64）或使用其他数据结构。







### 1. 直接映射方案

#### **描述**

将业务 ID【转为十进制】 直接映射到位图中的 bit 位，存储在 bitmap 数据结构中。如果支持 40 亿个业务 ID，使用大约 512MB 的位图（2^32 位），适用于业务 ID 在一定范围内且不重复的情况。

#### **实现步骤**

1. **映射：** 直接使用业务 ID 作为 bit 位的索引。
2. **存储：** 使用  bitmap 存储这些 bit 位。
3. **反解：** 可以直接从 bit 位判断对应业务 ID是否存在。

#### **优缺点**

- **优点：**
  - **无哈希冲突：** 避免了哈希冲突问题。
  - **反解简单：** 可以直接从 bit 位索引中获取业务 ID。
- **缺点：**
  - **业务 ID 范围限制：** 适用场景限制较多，业务 ID 需要在一定范围内（例如，0 到 40 亿）且不重复。
  - **内存消耗：** 可能会遇到内存消耗较大的问题，特别是在 ID 范围很大的情况下。

### 2.**映射表与位图结合方案**

#### **描述**

将业务 ID 和其对应的 bit 位存储在一个映射表中，并将实际数据存储在bitmap 中。此方案结合了映射表和位图的优点。

#### **实现步骤**

1. **创建映射表：** 使用一个关系型数据库或 NoSQL 数据库存储**业务 ID 和其对应的 bit 位**。例如：uid对应一个自增id【从0开始】
2. **存储位图数据：** 使用 bitmap 存储位图数据。
3. **反解：** 从映射表中查找业务 ID对应的自增id，然后从bitmap的 bit 位判断对应业务 ID是否存在。

#### **优缺点**

- **优点：**
  - **精确映射：** 映射表可以提供准确的 bit 位与业务 ID 的映射。
  - **可扩展性：** 映射表可以支持复杂的查询和操作。
- **缺点：**
  - **存储开销：** 映射表会增加额外的存储开销，特别是当业务 ID 数量很大时。
  - **维护复杂：** 需要维护两个数据存储系统（例如，bitmap和存储映射表的mysql），增加了系统的复杂性。

### 3.固定长度**分段位图方案**

将位图分段存储，每个段负责一部分 bit 位。通过分段位图方案可以管理大范围的 ID，并且支持高效的存取操作。如果支持 40 亿个业务 ID，可以分为40个段，每个段存储1亿。

#### 按照固定长度分段

- **实现方式**：

  1. **总位图长度**：例如 40 亿位
  2. **每段长度**：例如 1 亿位
  3. **段数**：40 个段（40 亿位 / 1 亿位）

  **计算方式**：

  - **段索引** = 业务 ID // 每段长度
  - **位位置** = 业务 ID % 每段长度

**优缺点**：

- **优点**：
  - 实现简单，段的大小一致，容易管理。
  - 可以直接将数据分布到每个段中，减少了内存开销。
  - **动态扩展时，只需增加更多段**。
- **缺点**：
  - 可能会有额外的性能开销，例如段定位和跨段操作的开销。
  - 需要管理多个段，增加系统复杂性。

### 4.高位和低位分段位图方案

假设有 40 亿业务 ID 需要管理，并且希望进行高位和低位分段：

1. **高位分段**：
   - 将业务 ID 的高位分为 10 个段，每个段处理 4 亿位。
   - 高位分段使得 ID 在各个大段中分布，每个段包含更小范围的数据。
2. **低位分段**：
   - 在每个高位段内部，根据低位进一步分段，每段处理 1 亿位。
   - 这样每个高位段内部可以处理更精细的数据，从而提升访问效率。

**优缺点**：

- **优点**：

  - **大范围数据管理**：

    - **场景**：当需要处理的数据范围非常大，例如数十亿或数百亿的业务 ID。

    - **优势**：高位分段可以有效地管理和组织大规模的数据。低位分段可以进一步细化和优化在特定段内的数据访问。

  - **热点数据隔离**：
    - **场景**：业务数据访问存在明显的热点（即某些数据被访问的频率显著高于其他数据）。
    - **优势**：通过高位分段，可以将热点数据分散到不同的段中，从而避免热点数据集中在一个段内造成的性能瓶颈。
  - **数据动态扩展**：
    - **场景**：系统需要支持动态扩展，例如从 40 亿 ID 扩展到 80 亿 ID。
    - **优势**：高位分段可以使数据扩展更加灵活。在扩展时，只需增加新的段来处理新的 ID 范围，原有的段可以继续处理旧的数据。

- **缺点**：

  - 实现复杂度高，需要解析业务 ID 的不同部分。
  - 可能需要更复杂的计算和映射逻辑来确定具体的位位置。

### 5.**哈希映射方案**

使用哈希函数将业务 ID 映射到位图中的 bit 位，存储在 bitmap 数据结构中

#### **实现步骤**

1. **哈希函数映射：** 使用哈希函数（如 SHA-256）将业务 ID 映射到 bit 位。
2. **存储：** 使用 bitmap 存储映射后的 bit 位。
3. **反解：** 使用一个反向映射表来记录 bit 位到业务 ID 的映射，支持从 bit 位反解业务 ID。

#### **优缺点**

- **优点：**
  - **简单高效：** 哈希映射是简单且高效的方式，适合快速存储和访问，并且不许额外存储id到位的映射
- **缺点：**
  - **哈希冲突：** 可能存在哈希冲突，需要处理冲突情况（例如，通过链表或开放寻址法）。
  - **反向映射表：** 需要维护一个反向映射表来支持反解，增加存储和管理开销。





### 热点数据隔离：高位分段的详细示例

**场景背景**： 在一个大规模的位图系统中，业务数据访问频率存在明显的热点，即某些业务 ID 被访问的频率显著高于其他业务 ID。这可能导致这些热点数据集中在单一段中，从而造成性能瓶颈，如内存压力和处理延迟。

**解决方案**： 通过高位分段，可以将数据划分到多个段中。这样可以将热点数据分散到不同的段，从而减少单一段的数据访问压力，优化系统性能。

### 高位分段的具体实施步骤

1. **定义高位段的大小和数量**：
   - **总位图长度**：例如 40 亿位（4,000,000,000 位）。
   - **每段长度**：例如 1 亿位（100,000,000 位），所以总段数为 40。
2. **计算业务 ID 到段的映射**：
   - 业务 ID 根据高位来确定其所在的段。例如，如果高位段长度为 1 亿位，则段索引可以通过 `业务 ID // 1 亿位` 计算得出。
3. **数据存储**：
   - 将业务 ID 映射到具体的段中，并在该段内部进行低位分段或直接映射。

### 示例

假设我们有以下业务 ID 和其访问频率：

- **业务 ID 123,456,789**：高访问频率（热点数据）
- **业务 ID 987,654,321**：低访问频率（非热点数据）
- **业务 ID 1,234,567,890**：中等访问频率

**高位分段**：

- **每段长度**：1 亿位
- **总段数**：40 个

#### 业务 ID 映射到段

1. **业务 ID 123,456,789**：
   - 段索引 = 123,456,789 // 100,000,000 = 1
   - 所以 123,456,789 映射到第 1 段。
2. **业务 ID 987,654,321**：
   - 段索引 = 987,654,321 // 100,000,000 = 9
   - 所以 987,654,321 映射到第 9 段。
3. **业务 ID 1,234,567,890**：
   - 段索引 = 1,234,567,890 // 100,000,000 = 12
   - 所以 1,234,567,890 映射到第 12 段。

#### 数据分布和访问优化

- **热点数据**（如 123,456,789）分布在第 1 段。由于高位分段，系统可以将第 1 段的数据分布到多个节点或优化第 1 段的存储，避免因集中访问导致性能瓶颈。
- **非热点数据**（如 987,654,321）分布在第 9 段。第 9 段的访问压力较小，可以在性能优化和资源分配上进行不同的策略。
- **中等访问数据**（如 1,234,567,890）分布在第 12 段。通过高位分段，可以保证中等频率的数据也不会与热点数据竞争同一段的资源。

### 优势

1. **分散负载**：通过将数据分布到多个段中，热点数据的访问压力被分散到不同的段，减少了单一段的负载。
2. **性能优化**：在访问频繁的段（例如第 1 段）上可以进行专门的优化，如更高的缓存策略、更快的存储介质等，提升整体性能。
3. **动态扩展**：当业务数据量增加时，可以简单地增加更多的段，从而避免单一段过于庞大，保持系统的可扩展性。

### 总结

高位分段可以有效地隔离热点数据，从而减少单一段的性能瓶颈。通过将数据映射到不同的段，系统能够更均匀地分配负载，提高整体性能，并且在数据扩展时可以灵活地进行管理和优化。

| **方案**                      | **实现方法**                                                 | **从 ID 到 bit 位的方法**                                    | **从 bit 位 到 ID 的反解方法**                | **优点**                                                     | **缺点**                                                     | **性能**                                           |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------- |
| **1. 直接映射方案**           | 将业务 ID 直接映射到位图中的 bit 位。                        | 直接使用业务 ID 作为 bit 位的索引。                          | 从 bit 位 直接获取业务 ID。                   | - 无哈希冲突：避免了哈希冲突问题。 - 反解简单：直接从 bit 位索引中获取业务 ID。 | - 业务 ID 范围限制：业务 ID 需要在特定范围内。 - 内存消耗大：ID 范围大时内存需求高。 | 性能最好，对于 ID 范围小且不重复的情况，性能很好。 |
| **2. 映射表与位图结合方案**   | 使用映射表存储业务 ID 和 bit 位的映射，实际数据存储在 bitmap 中。 | 映射表存储业务 ID 和 bit 位的映射。                          | 从位图中查询 bit 位，然后去映射表查询相应的id | - 精确映射：映射表提供准确的 bit 位与业务 ID 的映射。 - 可扩展性：支持复杂查询和操作。 | - 存储开销：映射表增加额外存储需求。 - 维护复杂：需要维护两个数据存储系统。 | 查询数据库需要消耗性能                             |
| **3. 固定长度分段位图方案**   | 将位图分为多个段，每段处理一部分 bit 位。                    | 段索引 = 业务 ID // 每段长度 ，位位置 = 业务 ID % 每段长度   | 根据bitmap的段索引和偏移量还原业务id          | - 实现简单：段的大小一致，容易管理。 - 动态扩展：增加更多段来扩展位图容量。 | - 性能开销：段定位和跨段操作可能引入开销。 - 复杂性：管理多个段增加系统复杂性。 | 计算段索引，偏移量会消耗性能                       |
| **4. 高位和低位分段位图方案** | 高位和低位分段位图，首先按高位分段，然后在每个高位段内部按低位分段。 | 高位分段 = 业务 ID 高位 // 高位段大小 低位分段 = 业务 ID 低位 % 低位段大小 | 需要额外数据结构记录bit位到业务id的映射       | - 大范围数据管理：有效管理和组织大规模数据。 - 热点数据隔离：避免性能瓶颈。 - 动态扩展：增加段来支持数据扩展。 | - 实现复杂：需要解析业务 ID 的不同部分。 - 可能需要复杂的计算和映射逻辑。 | 计算段索引，偏移量会消耗性能                       |
| **5. 哈希映射方案**           | 使用哈希函数将业务 ID 映射到位图中的 bit 位，存储在 bitmap 数据结构中。 | 使用哈希函数（如 SHA-256）将业务 ID 映射到 bit 位。          | 使用反向映射表记录 bit 位 到业务 ID 的映射。  | - 简单高效：哈希映射是简单且高效的方式。 - 不需要额外存储 ID 到位的映射。 | - 哈希冲突：需要处理冲突情况。 - 反向映射表：需要维护反向映射表增加开销。 | 哈希函数会消耗性能                                 |

|      |      |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |









除了上述提到的方案，还有一些其他的方案可以考虑，用于将业务 ID 映射到位图的 bit 位，并支持从 bit 位反解业务 ID。这些方案具有不同的优缺点，可以根据具体的业务需求选择合适的方案。以下是一些补充方案：

### 5. **稀疏位图方案**

#### **描述**
使用稀疏位图（Sparse Bitmap）来处理大规模业务 ID。稀疏位图使用哈希表存储只包含有值的 bit 位，适用于 ID 范围广泛且 ID 稀疏的情况。

#### **实现步骤**

1. **映射：** 将业务 ID 映射到哈希表中的 bit 位。使用哈希表存储映射关系，仅存储有值的 bit 位。
2. **存储：** 使用 Redis 的哈希结构（Hash）存储稀疏位图数据。
3. **反解：** 查询哈希表获取业务 ID。

#### **优缺点**

- **优点：**
  - **节省内存：** 仅存储实际使用的 bit 位，适合大范围稀疏数据。
  - **灵活性：** 支持动态增加和删除 bit 位。

- **缺点：**
  - **复杂性：** 映射和反解操作较为复杂，需要额外的哈希表管理。
  - **性能：** 对于非常稀疏的数据，性能可能会受到影响。

### 6. **分布式位图方案**

#### **描述**
将位图分布到多个 Redis 实例或分片中，以支持更大规模的数据存储和负载均衡。每个 Redis 实例处理位图的一部分。

#### **实现步骤**

1. **位图分片：** 将位图划分为多个分片，每个分片存储位图的一部分。
2. **映射：** 根据业务 ID 将其映射到具体的 Redis 实例和分片。
3. **反解：** 根据分片映射查找对应的 Redis 实例，然后查询 bit 位。

#### **优缺点**

- **优点：**
  - **扩展性：** 支持大规模数据存储，分布式系统能够处理更大的数据量。
  - **负载均衡：** 支持高并发读写请求，负载均衡提升性能。

- **缺点：**
  - **管理复杂性：** 需要管理多个 Redis 实例或分片，增加了系统复杂性。
  - **一致性：** 需要确保分片数据的一致性和可靠性。

### 7. **倒排索引与位图结合方案**

#### **描述**
结合倒排索引和位图，倒排索引用于快速查找业务 ID 对应的 bit 位，位图用于实际存储数据。适用于需要快速查找和反解的场景。

#### **实现步骤**

1. **创建倒排索引：** 使用倒排索引记录业务 ID 和其对应的 bit 位。
2. **存储位图：** 使用 Redis 位图存储实际的数据。
3. **反解：** 使用倒排索引快速查找业务 ID。

#### **优缺点**

- **优点：**
  - **快速查找：** 倒排索引提供了高效的查询性能。
  - **数据存储：** 位图提供了高效的数据存储和操作。

- **缺点：**
  - **存储开销：** 倒排索引会增加额外的存储开销。
  - **维护复杂性：** 需要维护倒排索引和位图的同步。

### 8. **分段位图方案**

#### **描述**
将位图分段存储，每个段负责一部分 bit 位。通过分段位图方案可以管理大范围的 ID，并且支持高效的存取操作。

#### **实现步骤**

1. **划分段：** 将位图分成多个段，每个段对应一部分 bit 位。
2. **映射：** 根据业务 ID 计算段索引和具体的 bit 位。
3. **存储：** 将数据存储到相应的段中。

#### **优缺点**

- **优点：**
  - **内存管理：** 将位图分段，有助于内存管理和优化性能。
  - **扩展性：** 支持扩展更多的段以适应更大的数据量。

- **缺点：**
  - **复杂性：** 需要管理多个段的存储和操作。
  - **性能开销：** 分段访问可能会引入一定的性能开销。

### 9. **数据库与位图结合方案**

#### **描述**
使用传统的关系型数据库或 NoSQL 数据库结合位图，以支持业务 ID 的存储和位图的管理。

#### **实现步骤**

1. **存储业务 ID：** 将业务 ID 存储在数据库中，并记录其对应的 bit 位。
2. **存储位图：** 使用 Redis 位图存储数据。
3. **反解：** 从数据库中查询 bit 位，然后使用 Redis 位图进行查询。

#### **优缺点**

- **优点：**
  - **数据管理：** 数据库提供了强大的数据管理和查询能力。
  - **灵活性：** 支持多种数据存储方式的结合。

- **缺点：**
  - **维护复杂性：** 需要维护数据库和位图的同步。
  - **存储开销：** 数据库和位图的结合可能会增加存储开销。

### 总结

- **稀疏位图方案**：适合 ID 范围广泛且数据稀疏的场景，但复杂性和性能可能会受到影响。
- **分布式位图方案**：支持大规模数据存储和负载均衡，但管理复杂性较高。
- **倒排索引与位图结合方案**：结合了快速查找和高效存储的优点，但需要额外的存储开销和维护工作。
- **分段位图方案**：适合内存管理和性能优化，但需要管理多个段。
- **数据库与位图结合方案**：提供了灵活的数据存储和管理能力，但增加了存储和维护开销。

选择合适的方案时，应考虑数据规模、系统性能、存储开销和维护复杂性等因素，以满足具体业务需求。

### 5. **稀疏位图方案**

**稀疏位图（Sparse Bitmap）** 是一种用于处理大规模、稀疏数据的位图方案。它通过只存储实际存在的 bit 位，来减少内存使用，特别适合处理 ID 范围广泛且 ID 稀疏的情况。

### **详细实现步骤**

#### **1. 映射**

- **业务 ID 映射：** 
  将业务 ID 转换为位图中的 bit 位，并将其映射到哈希表中的键值对。例如，业务 ID 可以用哈希函数计算出其在位图中的位置，然后在哈希表中存储这个位置及其值。

- **示例：**
  假设业务 ID 是 123,456,789。我们使用哈希函数（如取模运算）将其映射到位图中的位置：
  - **哈希函数：** `位位置 = 业务 ID % 位图大小`
  - 如果位图大小是 40 亿位，则位置计算为：`123,456,789 % 4,000,000,000 = 123,456,789`
  - 哈希表中存储的键值对可能是 `{123456789: 1}`，表示这个位置的位被设置为 1。

#### **2. 存储**

- **Redis 哈希结构（Hash）：**
  使用 Redis 的哈希数据结构来存储稀疏位图数据。Redis 的哈希表允许将业务 ID 映射到位图中的具体位置，并存储在哈希表中。

- **示例：**
  - 在 Redis 中创建一个哈希表 `sparse_bitmap`。
  - 存储业务 ID 123,456,789 的位位置：`HSET sparse_bitmap 123456789 1`。
  - 这样，Redis 的哈希表中会有一个键值对 `{123456789: 1}`，表示第 123,456,789 位被设置为 1。

#### **3. 反解**

- **查询哈希表：**
  查找哈希表中的键，以获取业务 ID 对应的位位置及其值。如果键存在，则该业务 ID 的 bit 位被设置为 1，否则默认为 0。

- **示例：**
  - 查询业务 ID 123,456,789 是否在哈希表中：`HGET sparse_bitmap 123456789`。
  - 如果返回值为 1，则表示该业务 ID 对应的位设置为 1；如果返回值为空或为 0，则表示该位没有被设置。

### **优缺点**

#### **优点**

1. **节省内存：**
   - 稀疏位图只存储实际存在的 bit 位，而不是所有可能的 bit 位。这显著减少了内存使用，特别是在业务 ID 稀疏的情况下。

2. **灵活性：**
   - 可以动态地添加和删除业务 ID，只需更新哈希表中的键值对即可。适合处理动态变化的数据集。

#### **缺点**

1. **复杂性：**
   - 映射和反解操作相对复杂。需要管理哈希表，并进行哈希计算来确定 bit 位的位置。

2. **性能：**
   - 对于极其稀疏的数据，虽然内存使用得到了优化，但哈希表的操作和查找可能会带来额外的性能开销。大规模的哈希表可能影响查询和存储的性能。

### **举例**

假设我们需要存储和查询业务 ID 为 123,456,789、987,654,321 和 1,234,567,890 的数据。

1. **存储：**
   - 将业务 ID 映射到位图中，并存储到 Redis 哈希表：
     ```shell
     HSET sparse_bitmap 123456789 1
     HSET sparse_bitmap 987654321 1
     HSET sparse_bitmap 1234567890 1
     ```

2. **查询：**
   - 查询业务 ID 是否存在于哈希表中：
     ```shell
     HGET sparse_bitmap 123456789   # 返回 1
     HGET sparse_bitmap 987654321   # 返回 1
     HGET sparse_bitmap 1234567890  # 返回 1
     HGET sparse_bitmap 1000000000  # 返回 (空值或 0)
     ```

### **总结**

稀疏位图方案通过仅存储实际使用的 bit 位，提供了一种内存效率高的解决方案，特别适合大范围稀疏数据的场景。虽然它增加了映射和查询的复杂性，并可能在极端稀疏情况下带来性能开销，但它在处理大规模数据集时能够显著节省内存，并保持较好的灵活性。

倒排索引压缩技术旨在减少内存和存储空间的使用，同时保持高效的查询性能。以下是一些常见的压缩技术的详细解释：

### 1. **字典压缩（Dictionary Compression）**

#### **概念**
字典压缩是一种将频繁出现的词汇映射到较短的编码的技术。这种方法基于词汇表的词频，替换较长的原始数据（如词汇）为更短的表示。

#### **实现**
- **词汇表构建：** 构建一个词汇表，将每个词汇分配一个唯一的短编码。词汇表中的词汇按出现频率排序，频繁出现的词汇分配更短的编码。
- **映射替换：** 在倒排索引中，用词汇表中的短编码替换实际的词汇。
  
#### **示例**
假设倒排索引中有以下词汇：["apple", "banana", "cherry", "date"]。我们可以创建一个词汇表如下：
- "apple" -> 1
- "banana" -> 2
- "cherry" -> 3
- "date" -> 4

原始的倒排索引可能是：
- "apple": [1, 3, 5]
- "banana": [2, 4, 6]

使用字典压缩后的倒排索引将是：
- "1": [1, 3, 5]
- "2": [2, 4, 6]

这样，存储的空间就显著减少了。

#### **优缺点**
- **优点：** 减少了存储空间，尤其是对于词汇表中重复的词汇。
- **缺点：** 需要额外的空间来存储词汇表，对于动态数据，维护词汇表可能会增加复杂性。

### 2. **差分编码（Delta Encoding）**

#### **概念**
差分编码是一种只存储相邻文档 ID 之间的差异的技术，而不是完整的文档 ID。这样可以减少存储空间，特别是在文档 ID 有一定的顺序性时。

#### **实现**
- **计算差异：** 对于每个文档 ID 列表，计算相邻文档 ID 之间的差值。
- **存储差异：** 存储这些差值而不是原始文档 ID。

#### **示例**
假设文档 ID 列表是：[100, 102, 105, 108]。差分编码会计算差值：
- 差值列表： [100, 2, 3, 3]

其中：
- 100 是第一个文档 ID
- 2 是 102 与 100 的差值
- 3 是 105 与 102 的差值
- 3 是 108 与 105 的差值

#### **优缺点**
- **优点：** 对于顺序性强的文档 ID，差分编码可以显著减少存储空间。
- **缺点：** 对于随机分布的文档 ID，差分编码效果不佳。需要额外的计算步骤来恢复原始数据。

### 3. **布尔压缩（Boolean Compression）**

#### **概念**
布尔压缩是对布尔型的倒排列表进行压缩的方法。布尔型倒排列表通常用来表示文档是否包含某个词汇，可以使用位图或其他布尔压缩技术来减少内存使用。

#### **实现**
- **位图：** 使用位图表示布尔值，1 表示存在，0 表示不存在。这样可以高效地压缩大量的布尔数据。
- **压缩位图：** 对于连续的 0 或 1，可以使用 Run-Length Encoding（RLE）等方法来进一步压缩位图数据。

#### **示例**
假设某个词汇在文档 1、3、5、6 中存在，可以表示为位图：
- 位图： [1, 0, 1, 0, 1, 1]

利用 RLE 压缩：
- 原始位图：[1, 0, 1, 0, 1, 1]
- 压缩形式：[(1, 1), (0, 1), (1, 1), (0, 1), (1, 2)]

其中：
- (1, 1) 表示 1 出现 1 次
- (0, 1) 表示 0 出现 1 次
- (1, 1) 表示 1 出现 1 次
- (0, 1) 表示 0 出现 1 次
- (1, 2) 表示 1 出现 2 次

#### **优缺点**
- **优点：** 位图和布尔压缩可以显著减少存储空间，特别是对布尔数据的压缩效果很好。
- **缺点：** 适用于布尔型数据，对于非布尔数据效果有限。位图压缩和解压缩可能引入额外的计算开销。

### 总结

这些压缩技术通过不同的方式优化倒排索引的存储和处理：
- **字典压缩** 适用于频繁出现的词汇，减少存储需求。
- **差分编码** 适用于有序的文档 ID 列表，减少存储空间。
- **布尔压缩** 适用于布尔型数据，通过位图和 RLE 等技术减少内存使用。

选择合适的压缩技术可以有效地减轻内存和存储压力，同时保持高效的查询性能。

对于处理大规模数据集（例如10亿条数据）的倒排索引，内存开销确实是一个重要考虑因素。倒排索引虽然可以提供高效的查询性能，但在存储和维护方面可能会面临显著的开销。下面是一些常见的策略来管理和优化倒排索引的内存使用：

### 1. **压缩技术**

**倒排索引压缩**可以显著减少内存使用量。常见的压缩技术包括：

- **字典压缩（Dictionary Compression）：** 例如，通过将常见的词汇映射到较短的编码来减少存储空间。
- **差分编码（Delta Encoding）：** 在存储文档 ID 时，记录相邻文档 ID 之间的差异而不是完整的文档 ID。
- **布尔压缩（Boolean Compression）：** 对于布尔型的倒排列表，可以使用位图或其他压缩技术来减少内存使用。

### 2. **分段存储**

将倒排索引分成多个段来分散内存开销。每个段处理文档集合的一个子集，这样可以有效地控制每个段的内存使用量。例如：

- **按时间分段：** 将倒排索引分成按时间段（如月、年）的段，以减少每个段的大小。
- **按词汇分段：** 将词汇表分成多个段，每个段包含一部分词汇和相应的倒排列表。

### 3. **稀疏倒排索引**

对于非常稀疏的数据，稀疏倒排索引可以提供优化：

- **稀疏倒排列表：** 只记录那些包含实际词汇的文档，而不是所有文档。
- **哈希表：** 使用哈希表来存储仅包含有值的条目，从而减少内存使用。

### 4. **外部存储**

将部分倒排索引数据存储在外部存储系统中，以减轻内存压力：

- **磁盘存储：** 将倒排索引的数据存储在磁盘上，只将当前需要的数据加载到内存中。
- **分布式存储：** 使用分布式存储系统（如 HDFS、Amazon S3）来存储倒排索引的副本，通过分布式计算框架（如 Hadoop、Spark）进行处理。

### 5. **增量更新**

在倒排索引中，增量更新可以减少内存消耗：

- **批量更新：** 批量处理文档更新，而不是实时更新倒排索引。这可以减少内存中同时存在的倒排索引条目数量。
- **合并操作：** 定期合并增量更新到主倒排索引中，从而控制内存使用并减少碎片化。

### 示例

假设我们有10亿条数据，每条数据都有一个唯一的标识符。为了处理这样的数据量，下面是一个示例如何应用上述优化：

1. **压缩技术：**
   - 使用差分编码来存储文档 ID 列表，以减少存储每个词汇的倒排列表所需的空间。

2. **分段存储：**
   - 将倒排索引分成 100 个段，每个段包含 1 亿条文档的倒排列表。每个段的大小相对较小，便于管理和优化。

3. **稀疏倒排索引：**
   - 对于不常用的词汇，使用哈希表存储其倒排列表，仅记录存在的词汇及其文档 ID。

4. **外部存储：**
   - 将倒排索引的持久化副本存储在分布式文件系统中，而在内存中仅缓存热点数据或近期更新的数据。

5. **增量更新：**
   - 执行批量更新，每隔一段时间将新数据合并到倒排索引中，以减少实时内存压力。

### 总结

处理大规模数据的倒排索引需要考虑内存优化、存储管理和高效查询等方面。通过应用压缩技术、分段存储、稀疏倒排索引、外部存储和增量更新等策略，可以有效地管理内存开销并提高系统性能。

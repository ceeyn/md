### 条件不满足的 while+await()

多线程使用指南，

wait 与 sleep 区别：

在调用 wait 方法时，线程必须要持有被调用对象的锁，当调用 wait 方法后，线程就会释放掉该对象的锁。

调用 Thread 类的 sleep 方法时，线程是不会释放对象的锁的。

通用的简单方法

```java
flag = 1;
void print(int cur, int next, String str) {
	for (int i = 0; i < loopNumber; i++) {
        synchronized(对象){
              while (flag != cur) {
                对象.wait()
              }
              print（str）
              flag = next
              对象.notify()
          }
		}
}
```

1.synchronized/reentrantlock 一把锁，根据不同的资源，设一个flag满足不同条件，例如a = 1，b = 2， c = 3，当curFlag = targetFlag时才能执行，否则while await等待

```
synchronized(对象){
	while(flag != cur){
		对象.wait()
	}
	对应的处理逻辑
}
```

2.ReentrantLock 有几个资源，就设立几个condition，例如，A，B，C两个线程交替打印1，2，3；设立两个变量，三个condition，一个 A—》B，一个B-》C，变量不满足时，condition while await，**【1,2两种方式差不多，都是一把锁，加一个条件变量】**

【A，B，C两个线程交替打印,设立3个con，不需额外变量，print(Con cur,Con next) 每次cur.await，然后next.signal】

2.semaphore,如果线程**要访问一个资源就必须先获得信号量**,例如，A，B两个线程交替打印,设立两个semaphore，线程1获得semaphoreA 打印A【先通知线程1】，然后释放semaphoreB，【再通知线程2】  线程2获得semaphoreB 打印B，然后释放semaphoreA【**semaphore像通知机制**】

https://xie.infoq.cn/article/b0657df10cac3d2f2e4d5140d?utm_campaign=geek_search&utm_content=geek_search&utm_medium=geek_search&utm_source=geek_search&utm_term=geek_search

https://xie.infoq.cn/article/60787185111fe4053cc40d890?utm_campaign=geek_search&utm_content=geek_search&utm_medium=geek_search&utm_source=geek_search&utm_term=geek_search

```
package concurrent.src.main.java.pool;

import java.util.HashSet;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @ClassName ThreadPool
 * @Description TODO
 * @Author @hzp
 * @Date 2024/8/31 12:29
 * @Version 1.0
 */
public class ThreadPool {
    private HashSet<Worker> workers = new HashSet();
    private TaskBlockingQueue<Runnable> taskQueue = new TaskBlockingQueue<>(2);
    private int maxCoreSize;
    private int coreSize;
    private long timeout;
    private Reject reject;
    private TimeUnit timeUnit;

    public ThreadPool(int maxCoreSize, int coreSize,
                      long timeout, Reject reject, TimeUnit timeUnit) {

        this.maxCoreSize = maxCoreSize;
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.reject = reject;
        this.timeUnit = timeUnit;
    }

    public void submit(Runnable task) {
        synchronized (workers) {
            if (workers.size() < maxCoreSize) {
                Worker worker = new Worker(task);
                workers.add(worker);
                worker.start();
            } else {
                taskQueue.put(task);
            }
        }
    }

    private class Worker extends Thread {
        private Runnable task;
        public Worker(Runnable task) {
            this.task = task;
        }
        @Override
        public void run() {
            while (task != null || (task = (Runnable) taskQueue.take()) != null) {
                try {
                    task.run();
                   
                }finally {
                    task = null;
                }
            }
            synchronized (workers){
                workers.remove(this);
            }
        }
    }

}

interface Reject {
    void reject();
}

class TaskBlockingQueue<T> {
    private LinkedBlockingQueue<T> taskQueue = new LinkedBlockingQueue<>();
    private int taskQueueSize;
    private ReentrantLock lock = new ReentrantLock();
    private Condition inCon = lock.newCondition();
    private Condition outCon = lock.newCondition();

    public TaskBlockingQueue(int taskQueueSize) {
        this.taskQueueSize = taskQueueSize;
    }

    public void put(T task) {
        lock.lock();
        try {
            while (taskQueue.size() == taskQueueSize) {
                System.out.println("任务队列为满。。。等待中");
                inCon.await();
            }
            taskQueue.add(task);
            System.out.println("核心线程全都忙，新来任务已经添加到任务队列中。。"+task);
            outCon.signal();
        } catch (Exception e) {

        } finally {
            lock.unlock();
        }
    }

    public T take() {
        lock.lock();
        try {
            while (taskQueue.size() == 0) {
                outCon.await();
                System.out.println("任务队列为空。。。等待中");
            }
            inCon.signal();
            T cur = taskQueue.poll();
            System.out.println("核心线程空闲了，从任务队列中消费任务。。"+cur);
            return cur;
        } catch (Exception e) {
            // catch以后必须throw，要不然没有返回值
            e.printStackTrace(); // 处理异常
            throw new RuntimeException(e);
        } finally {
            lock.unlock();
        }
    }

    public void putWithReject(T task, Reject reject) {
        lock.lock();
        try {
            if (taskQueue.size() == taskQueueSize) {
                reject.reject();
            } else {
                taskQueue.add(task);
                outCon.signal();
            }
        }finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {

        ThreadPool pool = new ThreadPool(3,2,1,()->{
            System.out.println("拒绝策略");
        },TimeUnit.MILLISECONDS);
        for (int i = 0; i < 7; i++) {
            int j = i;
            pool.submit(new Runnable() {
                @Override
                public void run() {
                    System.out.println("submit:任务"+j);
                }
            });
        }

    }
}
```



```java
public class SyncWaitNotify {
    // 循环次数
    private int loopNumber;
    // 房间
    private Object lock = new Object();
    // 标记，表示当前谁有资格执行
    private int flag;

    public SyncWaitNotify(int loopNumber, int flag) {
        this.loopNumber = loopNumber;
        this.flag = flag;
    }

    public void print(int cur, int next, String str) {
            synchronized (lock) {
                for(int i = 0; i < loopNumber; i++) {
                    while(flag != cur) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    }
                System.out.print(str);
                flag = next;
                lock.notifyAll();
            }
        }
    }

    public static void main(String[] args) {
        SyncWaitNotify swn = new SyncWaitNotify(5,1);
        new Thread(()->{swn.print(1,2,"a");}).start();
        new Thread(()->{swn.print(2,3,"b");}).start();
        new Thread(()->{swn.print(3,1,"c");}).start();
    }
}

```





```java
public class Test {
    private Semaphore a = new Semaphore(1);
    private Semaphore b = new Semaphore(0);
    private Semaphore c = new Semaphore(0);
    private void print(String word, Semaphore cur, Semaphore next) {
            for (int i = 0; i < 5; i++) {
                try {
                    cur.acquire();
                    System.out.println(word);
                    next.release();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }
    public static void main(String[] args) {
        Test test = new Test();
        Thread t1 = new Thread(()->{test.print("A",test.a,test.b);});
        Thread t2 = new Thread(()->{test.print("B",test.b,test.c);});
        Thread t3 = new Thread(()->{test.print("C",test.c,test.a);});
        t1.start();
        t2.start();
        t3.start();
    }
}

```





```java
public class SyncPark {
    private int loopNumber;

    public SyncPark(int loopNumber) {
        this.loopNumber = loopNumber;
    }

    public void print(Thread next,String str) {
        for (int i = 0; i < loopNumber; i++) {
            LockSupport.park();
            System.out.print(str);
            LockSupport.unpark(next);
        }
    }
    static Thread t1;
    static Thread t2;
    static Thread t3;

    public static void main(String[] args) {
        SyncPark aw = new SyncPark(5);
        t1 = new Thread(()->{aw.print(t2,"a");});
        t2 = new Thread(()->{aw.print(t3,"b");});
        t3 = new Thread(()->{aw.print(t1,"c");});
        // Start threads in correct order to prevent deadlock
        t1.start();
        t2.start();
        t3.start();

        // Unpark the first thread to start the printing process
        LockSupport.unpark(t1);
    }
}

```



# AQS类

## concurrenthashmap



### 线程池

1.默认：直接拒绝提交的新任务，并抛出 `RejectedExecutionException`。

2.当前线程池无法处理任务时，新任务会**被提交给调用任务的线程来运行**。这意味着调用线程会同步执行任务，而不是放入线程池中执行。

3.如果任务无法被执行，**直接丢弃新提交的任务**，不做任何处理，也不抛出异常

4.如果线程池队列满了，**会丢弃队列中最早的未执行的任务，然后【重新尝试提交当前任务**】

```java
package concurrent.src.main.java.threadpool;

import lombok.extern.slf4j.Slf4j;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicIntegerArray;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @ClassName ThreadPool
 * @Description TODO
 * @Author @hzp
 * @Date 2023/6/22 9:28 AM
 * @Version 1.0
 */
@Slf4j(topic = "c.TestPool")
public class TestPool {
    public static void main(String[] args) {
        // core是worker数量，queue capacity是队列容量
        ThreadPool threadPool = new ThreadPool(1,1000,
                TimeUnit.MILLISECONDS,1,(queue, task)->{
            // 死等
            queue.put(task);
        });
        // 添加任务
        for (int i = 0; i < 3; i++) {
            int j = i;
            threadPool.execute(()->{
                try{
                    Thread.sleep(10000000);
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
                log.debug("{}", j);
            });
        }
    }
}
interface  RejectPolicy <T>{
    void reject(BlockingQueue<T> queue, T task);
}
@Slf4j(topic = "c.ThreadPool")
class ThreadPool {

    // 线程集合
    private HashSet<Worker> workers = new HashSet<>();

    // 任务数
    private BlockingQueue<Runnable> blockingQueue;

    // 核心线程数
    private int coreSize;

    // 消费超时时间
    private long timeout;

    private TimeUnit timeUnit;

    private RejectPolicy rejectPolicy;

    public void execute(Runnable task) {
        synchronized (workers) {
            if (workers.size() < coreSize) {
                Worker worker = new Worker(task);
                log.debug("新增worker{}任务{}", worker,task);
                workers.add(worker);
                worker.start();
            } else {
                blockingQueue.putWithReject(rejectPolicy, task);
            }
        }
    }
    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapacity,RejectPolicy rejectPolicy) {
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        blockingQueue = new BlockingQueue<>(queueCapacity);
        this.rejectPolicy = rejectPolicy;
    }

    class Worker extends Thread{

        private Runnable task;

        public Worker(Runnable task) {
            this.task = task;
        }
        @Override
        public void run() {
            //blockingQueue.poll(timeout,timeUnit)
            while(task != null || (task = blockingQueue.poll(timeout,timeUnit))!=null){
                try{
                    log.debug("正在执行{}",task);
                    task.run();
                }catch (Exception e){
                    e.printStackTrace();
                }finally {
                    task = null;
                }
            }
            synchronized (workers){
                log.debug("worker被移除{}",this);
                workers.remove(this);
            }
        }
    }
}





@Slf4j(topic = "c.BlockingQueue")
class BlockingQueue<T> {

    private Deque<T> blockingQueue = new ArrayDeque<>();

    private volatile int capacity;

    private ReentrantLock lock = new ReentrantLock();

    private Condition inWaitSet = lock.newCondition();

    private Condition outWaitSet = lock.newCondition();

    public BlockingQueue(int capacity) {
        this.capacity = capacity;
    }
    // 生产者线程
    public void put(T task) {
        lock.lock();
        try {
            while(blockingQueue.size() == capacity){
                try {
                    log.debug("等待放入队列{}",task);
                    inWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            blockingQueue.add(task);
            outWaitSet.signal();
        } finally {
            lock.unlock();
        }
    }

    // 消费者线程
    public T pull() {
        lock.lock();
        try{
            while(blockingQueue.isEmpty()) {
                try {
                    outWaitSet.await();
                }catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = blockingQueue.removeFirst();
            inWaitSet.signal();
            return t;
        }  finally{
            lock.unlock();

        }
    }
    void takeCareOfBabyYvonne(Boolean 好吃的,Boolean 不让生气要让开心,Integer 感情,Integer Yvonne健康){
        while(true){
            if (不让生气要让开心 && 好吃的){
                感情++;
                Yvonne健康++;
            }
        }
    }
    // 带超时的消费者线程增强
    public T poll(long timeout, TimeUnit timeUnit) {
        long nanos = timeUnit.toNanos(timeout);
        lock.lock();
        try{
            while(blockingQueue.isEmpty()) {
                try {
                    if(nanos <= 0)
                        return null;
                     nanos = outWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = blockingQueue.removeFirst();
            inWaitSet.signal();
            return t;
        }finally{
            lock.unlock();
        }
    }
    // 带拒绝策略的生产者线程
    public void putWithReject(RejectPolicy<T> rejectPolicy, T task) {
        lock.lock();
        try {
            if (blockingQueue.size() == capacity) {
                rejectPolicy.reject(this, task);
            } else {
                log.debug("加入任务队列{}",task);
                blockingQueue.addLast(task);
                outWaitSet.signal();
            }
        }finally {
            lock.unlock();
        }
    }
    public int getSize() {
        synchronized (this) {
            return blockingQueue.size();
        }
    }
}

```



<img src="https://static001.infoq.cn/resource/image/51/ed/510e1bbdfa9bca708785be5d38025ced.png" alt="img" style="zoom: 67%;" />







<img src="https://static001.infoq.cn/resource/image/cc/5f/cc7aa71387bdd4e5897111dd3b6ea85f.png" alt="img"  />





<img src="https://static001.infoq.cn/resource/image/97/0d/974fef22f013d269778bbe7b7f81b60d.png" alt="img"  />





<img src="https://static001.infoq.cn/resource/image/f0/66/f0b32b9577575252ea4e8f2c4d39a266.png" alt="img"  />





## 线程池实际使用



**场景 1：快速响应用户请求**



**描述**：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。



**分析**：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，**所以应该不设置队列去缓冲并发任务，调高 corePoolSize 和 maxPoolSize 去尽可能创造多的线程快速执行任务。**

<img src="/Users/moon/Library/Application Support/typora-user-images/image-20241113093621094.png" alt="image-20241113093621094" style="zoom:50%;" />

**场景 2：快速处理批量任务**



**描述**：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。



**分析**：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。**这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的 corePoolSize 去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。**

<img src="/Users/moon/Library/Application Support/typora-user-images/image-20241113093732250.png" alt="image-20241113093732250" style="zoom: 33%;" />





**混合型任务** ，如果可以拆分，则`将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务`。只要这`两个任务执行的时间相差不是太大`，那么`分解后执行的吞吐率要高于串行执行的吞吐率`；如果这两个任务执行时间相差太大，则没必要进行分解。

- **优先级不同的任务** 可以使用优先级队列 `PriorityBlockingQueue` 来处理，它可以让优先级高的任务先得到执行。但是，如果`一直有高优先级的任务加入到阻塞队列中`，那么`低优先级的任务可能永远不能执行`。
- **执行时间不同的任务** 可以交给`不同规模的线程池`来处理，或者`也可以使用优先级队列`，让`执行时间短的任务先执行`。
- **依赖数据库连接池的任务** ，因为线程提交 SQL 后需要等待数据库返回结果，`线程数应该设置得较大`，这样才能更好的利用 CPU。





### 3.3 动态化线程池

#### 3.3.1 整体设计

动态化线程池的核心设计包括以下三个方面：



1. **简化线程池配置**：线程池构造参数有 8 个，但是最核心的是 3 个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。
2. **参数可动态修改**：为了解决参数不好配，修改参数成本高等问题。在 Java 线程池留有高扩展性的基础上，封装线程池，**允许线程池监听同步外部的消息，根据消息进行修改配置**。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。
3. **增加线程池监控**：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。

<img src="/Users/moon/Library/Application Support/typora-user-images/image-20241113095740846.png" alt="image-20241113095740846" style="zoom:50%;" />

#### 3.3.2 功能架构

动态化线程池提供如下功能：

- **动态调参**：支持线程池参数动态调整、界面化操作；包括修改线程池**核心大小、最大核心大小、队列长度等**；参数修改后及时生效。
- **任务监控**：支持应用粒度、线程池粒度、任务粒度的 Transaction 监控；可以看到**线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95/99 线**等。
- **负载告警**：**线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人**。
- **操作监控**：**创建/修改和删除线程池都会通知到应用的开发负责人**。
- **操作日志**：可以查看**线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么**。
- **权限校验**：只有应用开发负责人才能够修改应用的线程池参数。



<img src="/Users/moon/Library/Application Support/typora-user-images/image-20241113101926064.png" alt="image-20241113101926064" style="zoom:50%;" />



JDK 原生线程池 ThreadPoolExecutor 提供了如下几个 public 的 setter 方法，如下图所示：

<img src="/Users/moon/Library/Application Support/typora-user-images/image-20241113101949457.png" alt="image-20241113101949457" style="zoom:50%;" />

JDK 允许线程池使用方通过 **ThreadPoolExecutor 的实例**来动态设置线程池的核心策略，以 setCorePoolSize 为方法例，在运行期线程池使用方调用此方法设置 corePoolSize 之后，线程池会直接覆盖原来的 corePoolSize 值，并且基于当前值和原始值的比较结果采取不同的处理策略。**对于当前值小于当前工作线程数的情况，说明有多余的 worker 线程，此时会向当前 idle 的 worker 线程发起中断请求以实现回收**，多余的 worker 在下次 idle 的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的 worker 线程来执行队列任务，setCorePoolSize 具体流程如下：



<img src="/Users/moon/Library/Application Support/typora-user-images/image-20241113102113869.png" alt="image-20241113102113869" style="zoom:50%;" />

基于对这些问题的思考，动态化线程池提供了多个维度的监控和告警能力，包括：线程池活跃度、任务的执行 Transaction（频率、耗时）、Reject 异常、线程池内部统计信息等等，既能帮助用户从多个维度分析线程池的使用情况，又能在出现问题第一时间通知到用户，从而避免故障或加速故障恢复。



**1. 负载监控和告警**



线程池负载关注的核心问题是：基于当前线程池参数分配的资源够不够。对于这个问题，我们可以从事前和事中两个角度来看。**事前，线程池定义了“活跃度”这个概念，来让用户在发生 Reject 异常之前能够感知线程池负载问题**，线程池活跃度计算公式为：线程池活跃度 = activeCount/maximumPoolSize。这个公式代表当活跃线程数趋向于 maximumPoolSize 的时候，代表线程负载趋高。



**事中，也可以从两方面来看线程池的过载判定条件，一个是发生了 Reject 异常，一个是队列中有等待任务（支持定制阈值）**。以上两种情况发生了都会触发告警，告警信息会通过大象推送给服务所关联的负责人。



**2. 任务级精细化监控**



在传统的线程池应用场景中，线程池中的任务执行情况对于用户来说是透明的。比如在一个具体的业务场景中，业务开发申请了一个线程池同时用于执行两种任务，一个是发消息任务、一个是发短信任务，这两类任务实际执行的频率和时长对于用户来说没有一个直观的感受，很可能这两类任务不适合共享一个线程池，但是由于用户无法感知，因此也无从优化。动态化线程池内部实现了任务级别的埋点，且允许为不同的业务任务指定具有业务含义的名称，线程池内部基于这个名称做 Transaction 打点，基于这个功能，用户可以看到线程池内部任务级别的执行情况，且区分业务，任务监控示意图如下图所示：



````
要实现**任务级精细化监控**，你可以通过 Java 的线程池机制以及对任务进行自定义打点的方法来完成。下面是一个代码示例，演示如何使用 Java 的线程池实现任务级别的监控，包括对每个任务的执行时间进行监控，并生成报告。

### 实现步骤
1. **自定义任务类**：为每个任务设置一个有业务意义的名称。
2. **线程池监控执行器**：使用 `ExecutorService` 执行任务并记录执行时间。
3. **收集并记录监控数据**：记录任务的执行次数、执行时长、以及等待时间。

以下是一个代码实现的示例：

```java
import java.util.concurrent.*;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

public class ThreadPoolTaskMonitor {
    // 记录任务监控信息的类
    static class TaskMonitor {
        String taskName;
        AtomicInteger executionCount = new AtomicInteger(0);
        long totalExecutionTime = 0;

        TaskMonitor(String taskName) {
            this.taskName = taskName;
        }

        // 更新监控数据
        synchronized void updateExecutionTime(long time) {
            executionCount.incrementAndGet();
            totalExecutionTime += time;
        }

        // 计算平均执行时间
        synchronized long getAverageExecutionTime() {
            return executionCount.get() == 0 ? 0 : totalExecutionTime / executionCount.get();
        }
    }

    // 任务执行器，包含对任务监控数据的记录
    static class TaskExecutor implements Runnable {
        private final String taskName;
        private final Runnable task;
        private final TaskMonitor monitor;

        TaskExecutor(String taskName, Runnable task, TaskMonitor monitor) {
            this.taskName = taskName;
            this.task = task;
            this.monitor = monitor;
        }

        @Override
        public void run() {
            long startTime = System.currentTimeMillis();
            try {
                task.run();
            } finally {
                long endTime = System.currentTimeMillis();
                monitor.updateExecutionTime(endTime - startTime);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        // 创建线程池
        ExecutorService executorService = Executors.newFixedThreadPool(4);

        // 创建任务监控的存储结构
        Map<String, TaskMonitor> taskMonitors = new HashMap<>();
        taskMonitors.put("SendNotificationTask", new TaskMonitor("SendNotificationTask"));
        taskMonitors.put("SendSMSTask", new TaskMonitor("SendSMSTask"));

        // 定义一些模拟任务
        Runnable sendNotification = () -> {
            try {
                Thread.sleep(100);  // 模拟发消息任务
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        };

        Runnable sendSMS = () -> {
            try {
                Thread.sleep(300);  // 模拟发短信任务
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        };

        // 提交任务到线程池，并且使用任务监控类包装任务
        for (int i = 0; i < 10; i++) {
            executorService.submit(new TaskExecutor("SendNotificationTask", sendNotification, taskMonitors.get("SendNotificationTask")));
        }

        for (int i = 0; i < 5; i++) {
            executorService.submit(new TaskExecutor("SendSMSTask", sendSMS, taskMonitors.get("SendSMSTask")));
        }

        // 关闭线程池并等待所有任务完成
        executorService.shutdown();
        executorService.awaitTermination(1, TimeUnit.MINUTES);

        // 打印监控结果
        for (TaskMonitor monitor : taskMonitors.values()) {
            System.out.println("Task: " + monitor.taskName);
            System.out.println("Execution Count: " + monitor.executionCount);
            System.out.println("Average Execution Time: " + monitor.getAverageExecutionTime() + " ms");
            System.out.println();
        }
    }
}
```

### 代码说明
1. **TaskMonitor 类**：
   - 用于记录任务的执行情况。
   - 包含每个任务的名称、执行次数 `executionCount`、总执行时间 `totalExecutionTime`。
   - `getAverageExecutionTime()` 方法返回任务的平均执行时间。

2. **TaskExecutor 类**：
   - 包装每个任务的实际逻辑，用于计算任务执行的开始时间和结束时间，并更新到 `TaskMonitor` 中。
   - 记录执行时间并通过 `monitor.updateExecutionTime()` 来更新统计信息。

3. **主程序**：
   - 创建一个 `FixedThreadPool` 线程池，线程数为 4。
   - 创建两个任务：`sendNotification` 和 `sendSMS`，分别模拟发消息和发短信的逻辑。
   - 使用 `TaskExecutor` 包装每个任务，同时传入相应的 `TaskMonitor` 对象，用于记录执行情况。
   - 提交任务到线程池，并等待所有任务执行完毕后打印监控信息。

### 输出结果
程序执行完毕后，会输出如下监控信息：
```
Task: SendNotificationTask
Execution Count: 10
Average Execution Time: 100 ms

Task: SendSMSTask
Execution Count: 5
Average Execution Time: 300 ms
```

### 优化任务共享
1. **拆分线程池**：
   - 如果发现一个任务的执行次数远高于另一个任务，可以考虑将它们拆分到不同的线程池中。
2. **调整线程池参数**：
   - 对于不同类型的任务，可以设置不同的核心线程数和最大线程数来优化资源使用。

### 总结
通过在每个任务的执行逻辑中打点并记录执行时间，我们可以实现对任务级别的精细化监控。这种监控机制可以帮助开发者了解每个任务在共享线程池中的表现，进而做出优化决策，确保资源的合理分配，最终提升系统的整体性能。
````



<img src="/Users/moon/Library/Application Support/typora-user-images/image-20241113105848498.png" alt="image-20241113105848498" style="zoom:50%;" />

**90Line, 95Line, 99Line**：90%的任务执行时间在56.7毫秒以内，95%的任务在60.0毫秒以内，99%的任务在75.0毫秒以内。

**90Line, 95Line, 99Line** 的值可以帮助你找到任务的“长尾”问题。如果 99Line 的执行时间显著高于其他百分位数的时间，就需要优化处理这种少数时间过长的情况，可能涉及到任务逻辑的优化或者资源的动态分配。




代理模式（Proxy Pattern）是一种结构型设计模式，目的是为其他对象提供一种代理，以控制对这个对象的访问。代理对象在客户端和目标对象之间起到中介作用，客户端通过代理对象来访问目标对象，而不直接与目标对象进行交互。

### 代理模式的优点

1. **降低系统耦合度**：代理模式可以在一定程度上降低调用者和被调用者之间的耦合度，客户端无需了解目标对象的实现细节，只需与代理对象交互。
2. **功能增强**：代理对象可以在调用目标对象之前或之后执行一些额外的操作，如权限检查、日志记录、延迟加载等。
3. **隐藏实现细节**：代理模式可以灵活地隐藏目标对象的部分功能或服务，保护目标对象的隐私和安全。

### 代理模式的缺点

1. **性能开销**：由于增加了代理对象层，程序的性能会受到一定影响，尤其是在频繁调用的场景下，代理模式的性能不如直接调用高。
2. **代码复杂度**：代理模式增加了代码的复杂度，需要编写额外的代理类和处理逻辑，增加了系统的维护难度。

### 代理模式的分类

1. **静态代理**：静态代理是由程序员在代码中显式定义的代理类，代理类和目标对象实现相同的接口，并在代理类中调用目标对象的方法。
2. **动态代理**：动态代理是在运行时动态生成代理类，通常使用反射机制来调用目标对象的方法。Java 中的动态代理主要有两种实现方式：基于接口的 JDK 动态代理和基于类的 CGLIB 动态代理。

### 静态代理示例

静态代理是指代理类和目标类都实现了相同的接口，代理类在调用目标类的方法前后可以添加一些额外的操作。

```
java
复制代码
// 接口
public interface TicketService {
    void buyTicket();
}

// 目标对象
public class TrainTicketService implements TicketService {
    @Override
    public void buyTicket() {
        System.out.println("Buying train ticket.");
    }
}

// 代理对象
public class TicketServiceProxy implements TicketService {
    private TicketService ticketService;

    public TicketServiceProxy(TicketService ticketService) {
        this.ticketService = ticketService;
    }

    @Override
    public void buyTicket() {
        System.out.println("Before buying ticket.");
        ticketService.buyTicket();
        System.out.println("After buying ticket.");
    }
}

// 测试类
public class Main {
    public static void main(String[] args) {
        TicketService ticketService = new TrainTicketService();
        TicketService proxy = new TicketServiceProxy(ticketService);
        proxy.buyTicket();
    }
}
```

### 动态代理示例

动态代理是在运行时生成代理类，不需要显式编写代理类代码。

#### JDK 动态代理

JDK 动态代理需要目标对象实现接口。

```
java
复制代码
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// 接口
public interface TicketService {
    void buyTicket();
}

// 目标对象
public class TrainTicketService implements TicketService {
    @Override
    public void buyTicket() {
        System.out.println("Buying train ticket.");
    }
}

// 动态代理处理器
public class DynamicProxyHandler implements InvocationHandler {
    private Object target;

    public DynamicProxyHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Before buying ticket.");
        Object result = method.invoke(target, args);
        System.out.println("After buying ticket.");
        return result;
    }
}

// 测试类
public class Main {
    public static void main(String[] args) {
        TicketService ticketService = new TrainTicketService();
        TicketService proxy = (TicketService) Proxy.newProxyInstance(
            ticketService.getClass().getClassLoader(),
            ticketService.getClass().getInterfaces(),
            new DynamicProxyHandler(ticketService)
        );
        proxy.buyTicket();
    }
}
```

#### CGLIB 动态代理

CGLIB 动态代理是基于类的代理，目标对象无需实现接口。

```
java
复制代码
import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

// 目标对象
public class TrainTicketService {
    public void buyTicket() {
        System.out.println("Buying train ticket.");
    }
}

// 动态代理处理器
public class CglibProxyHandler implements MethodInterceptor {
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("Before buying ticket.");
        Object result = proxy.invokeSuper(obj, args);
        System.out.println("After buying ticket.");
        return result;
    }
}

// 测试类
public class Main {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(TrainTicketService.class);
        enhancer.setCallback(new CglibProxyHandler());

        TrainTicketService proxy = (TrainTicketService) enhancer.create();
        proxy.buyTicket();
    }
}
```

### 总结

代理模式通过在目标对象和客户端之间引入代理对象，可以在不改变目标对象的前提下，增强目标对象的功能或控制对目标对象的访问。静态代理需要显式编写代理类，而动态代理则在运行时动态生成代理类，更加灵活和方便。在实际开发中，动态代理被广泛应用于 AOP、RPC 等场景中。





工厂模式是一种创建型设计模式，它提供了一种创建对象的方式，将对象的实例化过程与客户端代码分离。工厂模式有多个变种，包括简单工厂模式、工厂方法模式和抽象工厂模式。以下是对简单工厂模式的详细解释：

### 简单工厂模式（Simple Factory Pattern）

简单工厂模式是最基础的工厂模式，通过一个工厂类来负责创建不同的对象实例。这个工厂类通常包含一个静态方法，根据传入的参数决定创建哪种具体的对象。

#### 优点

1. **简化客户端代码**：
   - 工厂类包含必要的判断逻辑，可以根据参数决定创建哪一个产品类的实例。客户端无需直接创建产品对象，只需通过工厂类来获取产品实例。这样做分离了对象的创建过程和使用过程。

2. **责任分割**：
   - 简单工厂模式通过引入专门的工厂类来创建对象，客户端只负责“消费”产品，创建产品的责任由工厂类承担。这种分工可以使代码更易维护和拓展。

3. **减少记忆负担**：
   - 客户端无需知道具体产品类的类名，只需了解传递给工厂类的参数即可。这对一些复杂的类名尤其有用，可以减少使用者的记忆负担。

4. **提高灵活性**：
   - 通过引入配置文件，可以在不修改客户端代码的情况下更换和增加新的具体产品类。这种方式在一定程度上提高了系统的灵活性和可扩展性。

#### 缺点

1. **不易扩展**：
   - 当需要添加新的产品类型时，必须修改工厂类的创建逻辑。这违反了开闭原则（对扩展开放，对修改关闭），即添加新功能时尽量不要修改已有的代码。

2. **创建逻辑复杂**：
   - 如果产品类型较多，工厂类的创建逻辑可能会变得非常复杂。一旦出错，可能会导致所有产品的创建失败，不利于系统的维护。

### 示例

以下是一个简单工厂模式的示例，以咖啡机为例来说明。

#### 产品接口和具体产品类

```java
// 产品接口
public interface Coffee {
    void brew();
}

// 具体产品类
public class Mocha implements Coffee {
    @Override
    public void brew() {
        System.out.println("Brewing Mocha...");
    }
}

public class Latte implements Coffee {
    @Override
    public void brew() {
        System.out.println("Brewing Latte...");
    }
}
```

#### 工厂类

```java
public class CoffeeFactory {
    public static Coffee createCoffee(String type) {
        switch (type) {
            case "Mocha":
                return new Mocha();
            case "Latte":
                return new Latte();
            default:
                throw new IllegalArgumentException("Unknown coffee type: " + type);
        }
    }
}
```

#### 客户端代码

```java
public class CoffeeMachine {
    public static void main(String[] args) {
        Coffee coffee1 = CoffeeFactory.createCoffee("Mocha");
        coffee1.brew();
        
        Coffee coffee2 = CoffeeFactory.createCoffee("Latte");
        coffee2.brew();
    }
}
```

在这个示例中，`CoffeeFactory` 类负责根据传入的类型参数创建具体的 `Coffee` 实例。客户端只需要调用 `CoffeeFactory.createCoffee` 方法并传入所需的咖啡类型，即可获得相应的咖啡实例并调用其方法。

### 详细解释优缺点

#### 优点详解

1. **简化客户端代码**：
   - 客户端无需知道产品的具体实现类，只需知道需要哪种类型的产品。这简化了客户端的代码，使其更易于使用和维护。

2. **责任分割**：
   - 工厂类集中管理对象的创建逻辑，使得客户端和对象创建逻辑分离。这种分工有助于代码的模块化和清晰性。

3. **减少记忆负担**：
   - 客户端只需了解传递给工厂类的参数，而不需要记住复杂的类名和构造函数参数。这减少了使用者的认知负担。

4. **提高灵活性**：
   - 通过配置文件或其他方式，可以在不修改客户端代码的情况下添加新的产品类型。这种方式提高了系统的灵活性和可扩展性。

#### 缺点详解

1. **不易扩展**：
   - 当需要添加新的产品类型时，必须修改工厂类的创建逻辑。这会导致工厂类代码的频繁修改，不利于维护和扩展。

2. **创建逻辑复杂**：
   - 如果产品类型较多，工厂类的创建逻辑可能会变得非常复杂。一旦出错，可能会导致所有产品的创建失败，不利于系统的维护。

### 总结

简单工厂模式通过引入工厂类，将对象的创建逻辑集中管理，使得客户端代码更加简洁和易于维护。然而，这种模式也有其局限性，如不易扩展和创建逻辑复杂等。在实际应用中，可以根据具体需求选择适合的工厂模式变种，如工厂方法模式和抽象工厂模式，以更好地满足系统的灵活性和可扩展性要求。





### 装饰器模式（Decorator Pattern）

装饰器模式是一种结构型设计模式，它允许向一个现有的对象添加新的功能，同时又不改变其结构。装饰器模式通过创建一个装饰类（Decorator），将被装饰的对象组合在一起，并实现与被装饰对象相同的接口或继承自相同的基类。这种方式使得装饰器可以在不修改原始类的情况下，动态地增加或增强对象的功能。

### 装饰器模式的优点

1. **职责分离**：装饰器类和被装饰类可以独立发展，不会相互耦合。可以在运行时根据需要选择不同的装饰器来组合对象，从而实现灵活的职责分离。
2. **替代继承**：装饰器模式是继承的一种替代方式，通过组合而不是继承来扩展类的功能。这使得代码更加灵活，避免了继承层次过深的问题。
3. **动态扩展功能**：可以动态地扩展一个实现类的功能，而无需修改现有代码，符合开闭原则（对扩展开放，对修改关闭）。

### 装饰器模式的关键

装饰器模式的关键在于装饰器类中使用了被装饰的对象，并且装饰器类实现了与被装饰对象相同的接口或继承自相同的基类。

### 示例

以下是一个使用装饰器模式的示例，以装饰不同的衣物为例：

#### 基础组件接口和具体实现

```
java
复制代码
// 基础组件接口
public interface Person {
    void show();
}

// 具体组件类
public class Laowang implements Person {
    @Override
    public void show() {
        System.out.println("Laowang");
    }
}
```

#### 装饰器基类和具体装饰器类

```
java
复制代码
// 装饰器基类
public class PersonDecorator implements Person {
    protected Person person;

    public PersonDecorator(Person person) {
        this.person = person;
    }

    @Override
    public void show() {
        if (person != null) {
            person.show();
        }
    }
}

// 具体装饰器类 - 穿夹克
public class JacketDecorator extends PersonDecorator {
    public JacketDecorator(Person person) {
        super(person);
    }

    @Override
    public void show() {
        super.show();
        System.out.println("Wearing a jacket");
    }
}

// 具体装饰器类 - 戴帽子
public class HatDecorator extends PersonDecorator {
    public HatDecorator(Person person) {
        super(person);
    }

    @Override
    public void show() {
        super.show();
        System.out.println("Wearing a hat");
    }
}
```

#### 客户端代码

```
java
复制代码
public class DecoratorPatternTest {
    public static void main(String[] args) {
        Person laowang = new Laowang();
        Person laowangWithJacket = new JacketDecorator(laowang);
        Person laowangWithJacketAndHat = new HatDecorator(laowangWithJacket);

        laowang.show();
        System.out.println("----------");
        laowangWithJacket.show();
        System.out.println("----------");
        laowangWithJacketAndHat.show();
    }
}
```

### 代理模式 vs 装饰器模式

虽然代理模式和装饰器模式都是结构型模式，并且都涉及到包装另一个对象，但它们的意图和使用场景是不同的：

1. **意图**：
   - **代理模式**：主要用于控制对对象的访问。代理对象可以在不修改原对象的情况下，为其提供额外的访问控制，如权限控制、延迟加载、日志记录等。
   - **装饰器模式**：主要用于动态地增加或增强对象的功能。装饰器模式通过组合而不是继承来扩展对象的功能。
2. **关注点**：
   - **代理模式**：重在访问权限的控制。代理对象控制对目标对象的访问，并可以在访问目标对象前后执行一些操作。
   - **装饰器模式**：重在功能的增强。装饰器对象在不改变原对象接口的情况下，动态地添加新功能。
3. **实现方式**：
   - **代理模式**：代理对象持有对目标对象的引用，并实现与目标对象相同的接口。代理对象在执行操作时，可以在调用目标对象方法前后加入额外的逻辑。
   - **装饰器模式**：装饰器对象持有对被装饰对象的引用，并实现与被装饰对象相同的接口。装饰器对象在调用被装饰对象的方法时，可以在前后添加新功能。

### 代理模式示例

以下是一个代理模式的示例，以保护对敏感数据的访问为例：

#### 接口和具体实现

```
java
复制代码
// 接口
public interface SensitiveData {
    void access();
}

// 具体实现类
public class RealSensitiveData implements SensitiveData {
    @Override
    public void access() {
        System.out.println("Accessing sensitive data");
    }
}
```

#### 代理类

```
java
复制代码
public class SensitiveDataProxy implements SensitiveData {
    private RealSensitiveData realSensitiveData;
    private String userRole;

    public SensitiveDataProxy(String userRole) {
        this.userRole = userRole;
    }

    @Override
    public void access() {
        if ("ADMIN".equals(userRole)) {
            if (realSensitiveData == null) {
                realSensitiveData = new RealSensitiveData();
            }
            realSensitiveData.access();
        } else {
            System.out.println("Access denied. Insufficient permissions.");
        }
    }
}
```

#### 客户端代码

```
java
复制代码
public class ProxyPatternTest {
    public static void main(String[] args) {
        SensitiveData adminData = new SensitiveDataProxy("ADMIN");
        adminData.access();

        SensitiveData userData = new SensitiveDataProxy("USER");
        userData.access();
    }
}
```

### 总结

- **代理模式**：代理模式的重点在于控制对对象的访问，常用于权限控制、延迟加载和日志记录等场景。代理对象在调用目标对象的方法之前或之后添加额外的逻辑，以控制访问或增强功能。
- **装饰器模式**：装饰器模式的重点在于动态地增加对象的功能，通过组合对象来实现功能扩展，避免了继承层次过深的问题。装饰器对象在调用被装饰对象的方法之前或之后添加新的行为，以增强功能。



### 模板方法模式（Template Method Pattern）

模板方法模式是一种行为型设计模式，它定义了一个算法的骨架，而将算法的某些步骤延迟到子类中去实现。通过这种方式，模板方法模式允许子类在不改变算法结构的情况下，重新定义算法的某些步骤。

### 1. 模式结构

模板方法模式的结构主要包括以下几个部分：

1. **抽象类（AbstractClass）**：
   - 定义了算法的骨架，并包含一个模板方法 `templateMethod()`。
   - 这个模板方法由多个基本方法（也称为钩子方法或抽象方法）组成，其中某些方法由抽象类实现，某些方法则留给子类去实现。
   
2. **具体子类（ConcreteClass）**：
   - 实现了父类中定义的抽象方法，也就是算法中可变的部分。
   - 子类可以在不改变父类中定义的算法结构的前提下，对算法的某些步骤进行定制化实现。

### 2. 模式示例

#### 茶饮制作的例子

假设我们要制作一种茶饮品，制作过程包括三个步骤：烧水、放入茶叶、喝茶。不同的人喜欢不同的茶叶种类，因此放入茶叶的步骤会有所不同。这个场景可以使用模板方法模式来实现。

```java
// 抽象类：定义制作茶饮的模板方法
abstract class TeaMaker {
    
    // 模板方法：定义了制作茶饮的步骤
    public final void makeTea() {
        boilWater();   // 烧水
        brewTea();     // 放入茶叶
        pourInCup();   // 倒入杯中
        drinkTea();    // 喝茶
    }

    // 具体方法：烧水
    private void boilWater() {
        System.out.println("Boiling water...");
    }

    // 抽象方法：放入茶叶
    protected abstract void brewTea();

    // 具体方法：倒入杯中
    private void pourInCup() {
        System.out.println("Pouring tea into cup...");
    }

    // 具体方法：喝茶
    private void drinkTea() {
        System.out.println("Drinking tea...");
    }
}

// 具体子类：普洱茶
class PuErTeaMaker extends TeaMaker {
    @Override
    protected void brewTea() {
        System.out.println("Putting Pu-Erh tea into water...");
    }
}

// 具体子类：铁观音
class TieGuanYinTeaMaker extends TeaMaker {
    @Override
    protected void brewTea() {
        System.out.println("Putting Tie Guan Yin tea into water...");
    }
}

// 使用示例
public class Main {
    public static void main(String[] args) {
        TeaMaker puErTea = new PuErTeaMaker();
        puErTea.makeTea(); // 制作普洱茶

        TeaMaker tieGuanYinTea = new TieGuanYinTeaMaker();
        tieGuanYinTea.makeTea(); // 制作铁观音茶
    }
}
```

**输出**：
```
Boiling water...
Putting Pu-Erh tea into water...
Pouring tea into cup...
Drinking tea...
Boiling water...
Putting Tie Guan Yin tea into water...
Pouring tea into cup...
Drinking tea...
```

在这个示例中，`TeaMaker` 类定义了制作茶饮的算法骨架，其中 `brewTea()` 方法由子类 `PuErTeaMaker` 和 `TieGuanYinTeaMaker` 分别实现。不同的子类可以定制化具体的茶叶种类，而算法的其余部分（如烧水、倒茶和喝茶）则由父类统一处理。

#### 每日工作的例子

在另一种场景中，我们可以定义一个人的日常工作流程，其中包括上班打卡、工作和下班打卡。不同的人有不同的工作内容，因此可以使用模板方法模式来表示这一过程。

```java
// 抽象类：定义每日工作的模板方法
abstract class DailyWork {

    // 模板方法：定义了每日工作的步骤
    public final void workDay() {
        clockIn();     // 上班打卡
        doWork();      // 工作
        clockOut();    // 下班打卡
    }

    // 具体方法：上班打卡
    private void clockIn() {
        System.out.println("Clocking in...");
    }

    // 抽象方法：工作内容
    protected abstract void doWork();

    // 具体方法：下班打卡
    private void clockOut() {
        System.out.println("Clocking out...");
    }
}

// 具体子类：后端开发
class BackendDeveloper extends DailyWork {
    @Override
    protected void doWork() {
        System.out.println("Writing backend code...");
    }
}

// 具体子类：前端开发
class FrontendDeveloper extends DailyWork {
    @Override
    protected void doWork() {
        System.out.println("Writing frontend code...");
    }
}

// 具体子类：测试工程师
class Tester extends DailyWork {
    @Override
    protected void doWork() {
        System.out.println("Testing the application...");
    }
}

// 使用示例
public class Main {
    public static void main(String[] args) {
        DailyWork backendDeveloper = new BackendDeveloper();
        backendDeveloper.workDay(); // 后端开发人员的工作流程

        DailyWork frontendDeveloper = new FrontendDeveloper();
        frontendDeveloper.workDay(); // 前端开发人员的工作流程

        DailyWork tester = new Tester();
        tester.workDay(); // 测试工程师的工作流程
    }
}
```

**输出**：
```
Clocking in...
Writing backend code...
Clocking out...
Clocking in...
Writing frontend code...
Clocking out...
Clocking in...
Testing the application...
Clocking out...
```

在这个示例中，`DailyWork` 类定义了一个工作日的基本流程，其中 `doWork()` 方法由不同的子类实现。`BackendDeveloper`、`FrontendDeveloper` 和 `Tester` 分别表示后端开发、前端开发和测试工程师的工作内容。

### 3. 模板方法模式的优点

1. **代码复用**：
   - 模板方法模式通过将相同的代码放在父类中，使得子类可以共享这些代码，从而提高了代码的复用性。不同子类只需要关注差异化的部分，这样可以避免代码重复。

2. **易于扩展**：
   - 模板方法模式符合开闭原则（Open/Closed Principle），即可以通过扩展新的子类来实现新的行为，而无需修改现有的代码。父类提供的骨架结构可以在子类中灵活地进行扩展。

3. **实现反向控制**：
   - 在模板方法模式中，父类控制算法的执行流程，而具体的实现细节则由子类决定。这种方式实现了“反向控制”（Inversion of Control），即高层次模块依赖于低层次模块的实现。

### 4. 模板方法模式的缺点

1. **代码复杂性增加**：
   - 使用模板方法模式可能会导致类层次结构过于复杂，特别是在需要定义多个子类的情况下，容易导致类的数量增多，增加系统的复杂性。

2. **类的依赖性增强**：
   - 父类与子类之间的依赖性较强，修改父类的骨架结构可能会影响所有的子类，导致代码的维护成本增加。

### 5. 适用场景

模板方法模式适用于以下场景：

- **算法的各个步骤在不同场景中会有所不同，但流程固定**。
- **需要代码复用，并且有多个子类共享相同的代码逻辑**。
- **系统需要维护稳定的算法结构，而部分算法步骤可能经常发生变化**。

### 总结

模板方法模式通过定义算法骨架，允许子类实现算法的某些步骤，从而实现了代码复用、反向控制和易于扩展的特点。它在许多场景中都可以大幅提高代码的灵活性和可维护性。





模板方法模式和工厂模式都是常用的设计模式，虽然它们都涉及到父类和子类的关系，也都用于实现代码复用和结构的灵活性，但它们的目的和使用场景是不同的。下面是这两种模式的详细对比：

### 模板方法模式（Template Method Pattern）

**目的**：
- 模板方法模式的目的是定义一个算法的整体框架（骨架），并将一些具体的步骤延迟到子类中去实现。它关注的是**算法步骤的顺序和固定结构**，而允许子类定制算法的某些步骤。

**结构**：
- 抽象类中定义了一个模板方法，这个方法封装了算法的骨架。
- 子类可以实现或覆盖算法中的某些步骤，但不能改变整体流程。

**使用场景**：
- 适用于算法或业务逻辑的框架已经确定，但某些具体的实现需要根据不同的场景或需求有所不同。
- 例如：实现一个处理流程的框架，不同的实现可以有不同的处理细节，但流程的框架是固定的。

**示例**：
- 制作茶饮料的步骤是固定的（烧水、泡茶、喝茶），但具体使用什么茶叶是不同的。

### 工厂模式（Factory Method Pattern）

**目的**：
- 工厂模式的目的是**创建对象**，它将实例化对象的过程延迟到子类中实现。工厂模式的核心是提供一个接口，用于创建对象，而不是直接在代码中使用 `new` 操作符实例化对象。

**结构**：
- 工厂模式通常包括一个抽象工厂类或接口，其中定义了一个方法用于创建对象。
- 具体子类或实现类负责创建具体的产品实例。

**使用场景**：
- 适用于对象的创建过程复杂、多变，或者需要将对象的创建过程与使用过程解耦。
- 例如：不同数据库的连接器创建，具体的数据库连接对象（如 MySQL、PostgreSQL）由具体的工厂子类创建。

**示例**：
- 生产汽车的工厂，每种车型由不同的具体工厂来生产，客户端通过工厂接口获取具体的汽车实例。

### 主要区别

1. **目的不同**：
   - **模板方法模式**：主要用于定义一个算法或流程的框架，并允许子类实现特定步骤。
   - **工厂模式**：主要用于创建对象，将对象的创建过程与使用过程分离。

2. **关注点不同**：
   - **模板方法模式**：关注的是行为的复用，模板方法通过固定的算法骨架来复用逻辑。
   - **工厂模式**：关注的是对象的创建，工厂方法模式通过工厂来创建对象，隐藏实例化的细节。

3. **实现方式不同**：
   - **模板方法模式**：定义一个模板方法，其中包含多个步骤（有些步骤由子类实现）。
   - **工厂模式**：定义一个工厂接口或抽象类，具体子类实现该接口来创建具体的对象实例。

4. **应用场景不同**：
   - **模板方法模式**：当你需要在多个子类中共享通用的行为逻辑，但其中的某些步骤在子类中有所不同时，使用模板方法模式。
   - **工厂模式**：当你需要将对象的创建与业务逻辑分开，并希望代码对具体类的依赖最小化时，使用工厂模式。

### 具体例子对比

#### 模板方法模式：
```java
abstract class Document {
    public final void print() {
        open();
        parseData();
        format();
        close();
    }

    protected abstract void parseData();

    private void open() {
        System.out.println("Opening document...");
    }

    private void format() {
        System.out.println("Formatting document...");
    }

    private void close() {
        System.out.println("Closing document...");
    }
}

class PdfDocument extends Document {
    @Override
    protected void parseData() {
        System.out.println("Parsing PDF data...");
    }
}

class WordDocument extends Document {
    @Override
    protected void parseData() {
        System.out.println("Parsing Word data...");
    }
}
```

这里，`print()` 是模板方法，`parseData()` 是不同文档类型的不同实现，但 `open()`、`format()` 和 `close()` 是固定流程。

#### 工厂方法模式：
```java
interface CarFactory {
    Car createCar();
}

class SedanFactory implements CarFactory {
    public Car createCar() {
        return new Sedan();
    }
}

class SUVFactory implements CarFactory {
    public Car createCar() {
        return new SUV();
    }
}
```

这里，`CarFactory` 是工厂接口，具体的 `SedanFactory` 和 `SUVFactory` 实现了创建不同类型汽车的逻辑。

### 总结

- **模板方法模式**：用于定义算法骨架，允许子类实现不同的步骤。
- **工厂方法模式**：用于创建对象，隐藏具体实现细节。

这两者在实际应用中有不同的侧重点，选择哪种模式取决于你是要复用算法的流程（模板方法模式），还是要灵活地创建对象（工厂方法模式）。





### 享元模式（Flyweight Pattern）

享元模式是一种结构型设计模式，它的核心思想是通过共享对象来减少内存消耗，特别是在系统中存在大量相同或类似对象时。享元模式的目标是避免在内存中保存多个相同的对象，而是通过共享相同的对象实例来减少内存开销。

### 1. 享元模式的基本原理

在享元模式中，系统会将多个相同或类似的对象的状态分为**内部状态**和**外部状态**：

- **内部状态（Intrinsic State）**：这部分状态是对象的固有属性，可以被多个对象共享，并且在对象的生命周期内保持不变。
- **外部状态（Extrinsic State）**：这部分状态是对象的外部特性，会随着环境的变化而改变，不能被共享，由客户端负责维护和传递。

享元模式通过将内部状态保存在一个共享的享元对象中，外部状态由客户端在使用时传入，从而使得系统中只需保留少量的享元对象，大大减少了内存的使用。

### 2. 享元模式的结构

享元模式通常由以下几个部分组成：

- **享元接口（Flyweight）**：
  - 定义了享元对象的方法，通常包括对外部状态进行操作的接口。

- **具体享元类（ConcreteFlyweight）**：
  - 实现享元接口，并存储内部状态。具体享元类是可以共享的对象。

- **非共享享元类（UnsharedConcreteFlyweight）**：
  - 并不是所有的享元对象都可以共享，这些对象通常是由多个享元对象组合而成的复杂对象，不支持共享。

- **享元工厂（FlyweightFactory）**：
  - 管理享元对象的创建和共享逻辑。享元工厂维护一个池（通常是哈希表），用于存储已经创建的享元对象，并在需要时返回已经存在的享元对象。

- **客户端（Client）**：
  - 客户端通过享元工厂获取享元对象，并在需要时传递外部状态。

### 3. 享元模式的使用示例

假设我们在开发一个文字处理器，文字处理器需要显示大量重复的字符。我们可以使用享元模式来节省内存，每个字符只在内存中存储一次，而不是每次使用时都创建新的实例。

#### 享元接口

```java
// 享元接口
interface Flyweight {
    void display(int fontSize, String color);
}
```

#### 具体享元类

```java
// 具体享元类：表示字符
class CharacterFlyweight implements Flyweight {
    private final char character;

    public CharacterFlyweight(char character) {
        this.character = character;
    }

    @Override
    public void display(int fontSize, String color) {
        System.out.println("Character: " + character + ", Font Size: " + fontSize + ", Color: " + color);
    }
}
```

#### 享元工厂

```java
// 享元工厂：用于管理和创建享元对象
class FlyweightFactory {
    private final Map<Character, Flyweight> flyweights = new HashMap<>();

    public Flyweight getFlyweight(char character) {
        Flyweight flyweight = flyweights.get(character);
        if (flyweight == null) {
            flyweight = new CharacterFlyweight(character);
            flyweights.put(character, flyweight);
        }
        return flyweight;
    }
}
```

#### 客户端

```java
public class Main {
    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();

        Flyweight flyweightA = factory.getFlyweight('A');
        flyweightA.display(12, "Red");

        Flyweight flyweightB = factory.getFlyweight('B');
        flyweightB.display(14, "Blue");

        Flyweight anotherFlyweightA = factory.getFlyweight('A');
        anotherFlyweightA.display(16, "Green");

        // 输出: flyweightA 和 anotherFlyweightA 是同一个实例
        System.out.println(flyweightA == anotherFlyweightA); // true
    }
}
```

**输出**：
```
Character: A, Font Size: 12, Color: Red
Character: B, Font Size: 14, Color: Blue
Character: A, Font Size: 16, Color: Green
true
```

在这个示例中，字符 `A` 只创建了一次（即 `flyweightA` 和 `anotherFlyweightA` 实际上是同一个实例）。当我们在不同的地方显示相同的字符时，我们只需要获取已经存在的实例并提供外部状态（字体大小和颜色），这显著减少了内存的使用。

### 4. 享元模式的优点

- **减少内存消耗**：通过共享相同的对象实例，享元模式可以大大减少系统中相同对象的数量，从而节省内存。
  
- **提高性能**：由于减少了对象的创建和销毁，享元模式可以提高系统的运行性能，特别是在大规模使用对象的场景下。

### 5. 享元模式的缺点

- **实现复杂性**：享元模式需要对系统中的对象进行详细的分析和划分，以确定哪些状态可以共享，哪些状态需要外部维护，这增加了实现的复杂性。

- **引入外部状态管理**：享元模式将一些状态从对象中分离出来，由客户端进行管理，这可能增加客户端的负担，并且在某些情况下，维护外部状态会变得复杂。

### 6. 享元模式的适用场景

- **系统中存在大量相同或相似的对象**，这些对象会占用大量内存，并且可以通过共享来节省资源。

- **对象的多数属性可以是不可变的**，可以被多个对象共享。

- **外部状态可以被独立管理**，不会影响对象的共享性。

### 7. 享元模式的典型应用

- **Java 中的 Integer 缓存机制**：Java 在装箱操作时对 `-128` 到 `127` 之间的整数进行了缓存，这就是享元模式的典型应用。当你在这个范围内创建一个 `Integer` 对象时，实际上是从缓存中获取已经存在的实例，而不是创建新的实例。

- **字符串常量池**：Java 中的字符串常量池（String Pool）也是享元模式的一种实现。字符串常量池会缓存已经创建的字符串，避免重复创建相同的字符串对象。

### 总结

享元模式通过共享对象来减少内存的消耗和提高系统性能，适用于系统中存在大量相似或相同对象的场景。虽然享元模式可以显著优化内存使用，但也带来了实现上的复杂性，特别是在处理外部状态时，需要仔细权衡其利弊。





享元模式和单例模式都是设计模式中的重要模式，虽然它们都涉及到对象的管理和复用，但它们的目的、应用场景和实现方式有所不同。下面详细介绍这两种模式的区别。

### 1. 模式定义

- **单例模式（Singleton Pattern）**：
  - **定义**：单例模式是一种创建型模式，它确保某个类在应用程序生命周期内只有一个实例，并提供全局访问点。单例模式的核心是控制实例的创建过程，并通过提供一个静态方法来访问这个唯一的实例。
  
- **享元模式（Flyweight Pattern）**：
  - **定义**：享元模式是一种结构型模式，它通过共享对象来减少内存消耗，特别是在系统中存在大量相同或相似对象的情况下。享元模式的核心思想是将对象的可共享部分分离出来，并通过享元工厂来管理和复用这些共享对象。

### 2. 模式目的

- **单例模式**：
  - **目的**：单例模式的主要目的是确保类在整个应用程序生命周期内只有一个实例。这通常用于管理全局状态、配置、资源访问控制等场景。
  - **使用场景**：适用于需要一个且仅有一个实例的场景，如配置管理类、日志类、线程池、数据库连接池等。

- **享元模式**：
  - **目的**：享元模式的主要目的是通过共享对象来节省内存，尤其是当系统中有大量类似对象时。享元模式通过复用现有对象而不是重新创建，来减少对象数量，优化性能。
  - **使用场景**：适用于需要大量重复对象、且这些对象大部分状态可以共享的场景，如字符处理、图形编辑器、游戏开发中的粒子系统等。

### 3. 对象的数量

- **单例模式**：
  - **对象数量**：单例模式严格限制了对象的数量，整个系统中只能有一个实例（或在某些实现中，可以有有限数量的实例，如多例模式）。
  - **实例**：每个类在整个系统中只能有一个实例。即使在多个线程或不同模块中使用，获取的也是同一个实例。

- **享元模式**：
  - **对象数量**：享元模式不限制对象的数量，而是通过共享机制减少重复对象的数量。系统中可能会有多个享元对象，但这些对象共享相同的内部状态。
  - **实例**：享元模式允许系统中有多个共享对象实例，每个实例代表不同的外部状态。

### 4. 共享与复用

- **单例模式**：
  - **共享与复用**：单例模式通过全局访问点共享一个唯一的实例。无论何时何地使用单例类，访问的都是同一个对象实例。
  
- **享元模式**：
  - **共享与复用**：享元模式通过将对象的内部状态共享，复用已经存在的对象实例。它允许在内存中创建多个享元对象，但这些对象会复用相同的内部状态，节省内存。

### 5. 内部状态与外部状态

- **单例模式**：
  - **状态管理**：单例模式的状态通常是全局的，并且不区分内部状态和外部状态。单例对象的状态在整个应用程序中共享。
  
- **享元模式**：
  - **状态管理**：享元模式将对象的状态分为内部状态和外部状态。内部状态是可以共享的，并由享元对象管理；外部状态是不可共享的，由客户端负责在使用时传入。

### 6. 实现方式

- **单例模式**：
  - **实现方式**：单例模式通常通过静态变量和静态方法实现，确保类的构造函数是私有的，并提供一个公共的静态方法来获取唯一实例。常见的实现方式包括饿汉式、懒汉式、双重检查锁、静态内部类等。

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() { }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

- **享元模式**：
  - **实现方式**：享元模式通常通过享元工厂管理对象的创建和复用。享元工厂会检查是否存在一个可以复用的对象，如果存在则返回该对象，如果不存在则创建一个新的对象并返回。
  
```java
public class FlyweightFactory {
    private Map<String, Flyweight> flyweights = new HashMap<>();

    public Flyweight getFlyweight(String key) {
        Flyweight flyweight = flyweights.get(key);
        if (flyweight == null) {
            flyweight = new ConcreteFlyweight(key);
            flyweights.put(key, flyweight);
        }
        return flyweight;
    }
}
```

### 7. 典型应用场景

- **单例模式**：
  - **应用场景**：配置管理类、日志类、线程池、数据库连接池、缓存、全局唯一资源的访问控制等场景。
  
- **享元模式**：
  - **应用场景**：文字处理中的字符对象、图形编辑器中的图形对象、游戏开发中的对象池、Web服务器中的连接池等场景。

### 8. 实现复杂度

- **单例模式**：
  - **实现复杂度**：单例模式的实现相对简单，只需确保构造方法私有化，并提供一个静态方法获取实例。需要注意线程安全问题，尤其是在多线程环境下。
  
- **享元模式**：
  - **实现复杂度**：享元模式的实现较为复杂，需要仔细划分对象的内部状态和外部状态，并通过享元工厂管理对象的共享和复用。享元模式还需要考虑如何管理外部状态，以及如何在需要时扩展享元池。

### 总结

- **单例模式**：是一种创建型模式，关注于创建一个全局唯一的对象实例，确保系统中只有一个实例对象存在。单例模式适用于需要全局共享资源的场景。

- **享元模式**：是一种结构型模式，通过共享相似对象的内部状态来减少内存消耗，提升系统性能。享元模式适用于系统中存在大量相同或类似对象的场景，通过共享机制避免重复创建相同对象。

这两种模式在实际开发中有不同的应用场景和侧重点，开发者可以根据需求选择合适的设计模式来优化系统的性能和资源使用。





### 策略模式（Strategy Pattern）概述

策略模式是一种行为型设计模式，它定义了一系列算法，并将每个算法都封装起来，使得它们可以相互替换。策略模式使得算法可以独立于使用它们的客户端而变化。

在策略模式中，通常有三个角色：
1. **策略接口（Strategy Interface）**：定义了一个算法的接口，各种具体的策略类都实现这个接口。
2. **具体策略类（Concrete Strategy Classes）**：实现了策略接口，封装了具体的算法。
3. **上下文类（Context Class）**：持有一个策略接口的引用，用于调用具体的策略类。

### 策略模式在生活中的应用场景

策略模式在生活中有很多实际的应用场景，最常见的就是选择出行方式、支付方式、打折方式等。以下是详细的解释：

#### 场景一：出行方式的选择

当你决定去某个目的地，比如说北京，你有多种交通方式可以选择，例如：

- **坐飞机**：最快捷的方式，但可能最贵。
- **坐高铁**：速度适中，价格适中。
- **自己开车**：灵活性高，但可能比较费时。
- **坐长途汽车**：最便宜，但速度最慢。

在这个场景中，每一种出行方式可以看作是一种策略。你可以根据时间、成本、方便程度等因素选择合适的出行策略。

#### 策略模式实现

1. **策略接口**：定义一个通用的出行策略接口，所有的出行方式都需要实现这个接口。

```java
// 出行策略接口
interface TravelStrategy {
    void travel();
}
```

2. **具体策略类**：实现不同的出行方式。

```java
// 飞机策略
class AirplaneStrategy implements TravelStrategy {
    @Override
    public void travel() {
        System.out.println("Traveling by airplane...");
    }
}

// 高铁策略
class HighSpeedRailStrategy implements TravelStrategy {
    @Override
    public void travel() {
        System.out.println("Traveling by high-speed rail...");
    }
}

// 自驾策略
class SelfDrivingStrategy implements TravelStrategy {
    @Override
    public void travel() {
        System.out.println("Traveling by self-driving...");
    }
}

// 长途汽车策略
class BusStrategy implements TravelStrategy {
    @Override
    public void travel() {
        System.out.println("Traveling by long-distance bus...");
    }
}
```

3. **上下文类**：持有一个出行策略的引用，允许客户端动态地选择和切换策略。

```java
// 上下文类
class TravelContext {
    private TravelStrategy strategy;

    // 设置出行策略
    public void setStrategy(TravelStrategy strategy) {
        this.strategy = strategy;
    }

    // 执行出行策略
    public void executeStrategy() {
        strategy.travel();
    }
}
```

4. **客户端**：可以根据不同情况选择不同的出行策略。

```java
public class Main {
    public static void main(String[] args) {
        TravelContext context = new TravelContext();

        // 选择飞机出行
        context.setStrategy(new AirplaneStrategy());
        context.executeStrategy(); // 输出: Traveling by airplane...

        // 选择高铁出行
        context.setStrategy(new HighSpeedRailStrategy());
        context.executeStrategy(); // 输出: Traveling by high-speed rail...

        // 选择自驾出行
        context.setStrategy(new SelfDrivingStrategy());
        context.executeStrategy(); // 输出: Traveling by self-driving...

        // 选择长途汽车出行
        context.setStrategy(new BusStrategy());
        context.executeStrategy(); // 输出: Traveling by long-distance bus...
    }
}
```

在这个例子中，客户端可以根据不同的需求灵活地选择和切换出行策略，而不需要修改上下文类的代码，这符合开闭原则（对扩展开放，对修改关闭）。

#### 场景二：支付方式的选择

在购物时，用户通常有多种支付方式可以选择，例如：

- **信用卡支付**：使用信用卡进行支付。
- **微信支付**：通过微信完成支付。
- **支付宝支付**：通过支付宝完成支付。
- **现金支付**：在实体店使用现金支付。

每一种支付方式可以看作是一种策略，用户可以在结账时选择最方便或最优惠的支付方式。

#### 场景三：打折策略的选择

商场促销活动中，常常会有多种打折方式，例如：

- **满减优惠**：购物金额达到一定数额后减免一定金额。
- **折扣优惠**：对商品总价打折，如打八折。
- **积分兑换**：使用积分兑换折扣或商品。

这些打折方式也是一种策略，商场可以根据不同的促销活动选择适用的打折策略。

### 策略模式的优缺点

#### 优点

1. **符合开闭原则**：策略模式允许在不修改现有代码的情况下添加新的策略，系统扩展性强。
2. **避免使用多重条件语句**：通过将算法封装到独立的策略类中，策略模式避免了在客户端代码中使用复杂的条件语句。
3. **提高代码复用性**：不同的策略类可以复用相同的上下文接口，从而提高代码的复用性。

#### 缺点

1. **增加了类的数量**：每个具体策略都是一个类，如果策略过多，可能会导致系统中类的数量急剧增加，管理起来较为复杂。
2. **对外暴露策略**：策略模式将具体的算法实现暴露给客户端，客户端需要了解不同策略的行为，这可能增加客户端的复杂性。

### 总结

策略模式通过定义一系列算法，使得客户端可以灵活地选择和切换不同的算法，从而提高了系统的可扩展性和灵活性。在生活中，策略模式的应用非常广泛，例如选择出行方式、支付方式、打折策略等。通过策略模式，我们可以避免大量的条件判断语句，使代码更加简洁、易于维护，同时也符合软件设计中的开闭原则。





### 责任链模式（Chain of Responsibility Pattern）概述

责任链模式是一种行为型设计模式，它允许多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系。责任链模式将这些对象连成一条链，并沿着这条链传递请求，直到有对象处理它为止。每个对象在处理请求时，既可以处理请求，也可以将请求传递给链中的下一个对象。

### 责任链模式的结构

责任链模式的结构主要包括以下几个角色：

1. **抽象处理者（Handler）**：
   - 定义一个处理请求的接口，包含处理请求的方法 `handleRequest()` 以及设置下一个处理者的方法 `setNextHandler()`。在抽象处理者中可以有一个对下一个处理者的引用。

2. **具体处理者（ConcreteHandler）**：
   - 具体处理者实现了抽象处理者的接口，具体处理请求。在具体处理者中，如果自己不能处理该请求，则将请求传递给下一个处理者进行处理。

3. **客户端（Client）**：
   - 客户端负责创建处理链，并发出请求。

### 责任链模式的优缺点

#### 优点

1. **解耦请求与处理**：请求的发送者与处理者解耦，发送者不需要知道是谁处理了请求，处理者也不需要知道是谁发送的请求。
2. **请求处理灵活**：责任链模式允许动态添加或删除处理者，或者修改链的结构，从而使得系统更灵活。
3. **责任单一**：每个处理者只需专注于处理自己感兴趣的请求，对于其他请求，可以直接传递给下一个处理者。
4. **符合开闭原则**：可以通过添加新的处理者来扩展系统的功能，而不影响已有代码。

#### 缺点

1. **可能会影响性能**：如果链条过长，可能导致请求传递过程中性能下降。
2. **不容易调试**：由于请求是在多个处理者之间传递的，定位问题可能变得困难。
3. **可能导致循环调用**：如果链条配置不当，可能会导致循环调用，导致系统陷入死循环。

### 生活中的责任链模式实例

#### 1. OA审批流程

在公司内部发起的 OA 审批流程是责任链模式的一个经典例子。假设某个员工提交了一个请假申请，这个申请需要依次经过项目经理、部门经理、老板、人力资源等多个角色的审批。

每个审批者都可以根据具体情况处理请求（例如批准或拒绝），如果他无法处理或不需要处理该请求，就将请求传递给下一个审批者。

```java
// 抽象处理者
abstract class Approver {
    protected Approver nextApprover;

    public void setNextApprover(Approver nextApprover) {
        this.nextApprover = nextApprover;
    }

    public abstract void handleRequest(int leaveDays);
}

// 具体处理者：项目经理
class ProjectManager extends Approver {
    @Override
    public void handleRequest(int leaveDays) {
        if (leaveDays <= 2) {
            System.out.println("Project Manager approves " + leaveDays + " days leave.");
        } else if (nextApprover != null) {
            nextApprover.handleRequest(leaveDays);
        }
    }
}

// 具体处理者：部门经理
class DepartmentManager extends Approver {
    @Override
    public void handleRequest(int leaveDays) {
        if (leaveDays <= 5) {
            System.out.println("Department Manager approves " + leaveDays + " days leave.");
        } else if (nextApprover != null) {
            nextApprover.handleRequest(leaveDays);
        }
    }
}

// 具体处理者：老板
class Boss extends Approver {
    @Override
    public void handleRequest(int leaveDays) {
        if (leaveDays > 5) {
            System.out.println("Boss approves " + leaveDays + " days leave.");
        } else if (nextApprover != null) {
            nextApprover.handleRequest(leaveDays);
        }
    }
}

// 客户端
public class Main {
    public static void main(String[] args) {
        Approver projectManager = new ProjectManager();
        Approver departmentManager = new DepartmentManager();
        Approver boss = new Boss();

        projectManager.setNextApprover(departmentManager);
        departmentManager.setNextApprover(boss);

        // 发起请假请求
        projectManager.handleRequest(3);  // 部门经理审批
        projectManager.handleRequest(1);  // 项目经理审批
        projectManager.handleRequest(7);  // 老板审批
    }
}
```

**输出**：
```
Department Manager approves 3 days leave.
Project Manager approves 1 days leave.
Boss approves 7 days leave.
```

在这个例子中，`projectManager`、`departmentManager` 和 `boss` 形成了一个责任链。每个审批者根据请假天数决定是否处理请求，或者将请求传递给下一个审批者。这样，系统可以灵活地处理各种请求，而不需要请求发送者了解整个审批流程的细节。

### 责任链模式的实际应用

#### 1. SpringMVC中的拦截器

SpringMVC中的拦截器机制是责任链模式的一个典型应用。拦截器可以对请求进行预处理和后处理，并且可以设置多个拦截器按顺序执行。

当一个请求到达 SpringMVC 时，它会按照配置的顺序依次经过每一个拦截器的处理，如果某个拦截器处理了请求，它可以选择是否继续将请求传递给下一个拦截器。最终，处理后的请求会到达控制器，并由控制器返回响应。

#### 2. MyBatis中的插件机制

MyBatis 的插件机制也是责任链模式的一个典型应用。在 MyBatis 中，可以通过插件机制来拦截某些关键操作，比如 SQL 语句的生成、执行，以及结果的映射。

插件的执行顺序是按照责任链模式来进行的，每个插件都可以选择是否继续将请求传递给下一个插件。通过这种机制，开发者可以在不修改 MyBatis 核心代码的情况下，实现对 MyBatis 行为的定制和扩展。

### 总结

责任链模式通过将请求的处理职责链式地分配给多个对象，使得请求的发送者与处理者解耦。它在处理复杂的流程时，能够提供极大的灵活性。通过动态调整链条中的处理者，可以轻松应对需求的变化。尽管责任链模式可能会引入一定的性能开销和调试难度，但它在很多实际场景中都是非常有效的解决方案，例如 OA 审批流程、SpringMVC 的拦截器机制和 MyBatis 的插件机制等。



模板方法模式和策略模式都是常用的设计模式，它们在解决问题时有着不同的出发点和使用场景。以下是两者的详细对比和区别：

### 1. 模式定义

- **模板方法模式（Template Method Pattern）**：
  - **定义**：模板方法模式是一种行为型设计模式，它定义了一个算法的骨架，将某些步骤延迟到子类中实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
  
- **策略模式（Strategy Pattern）**：
  - **定义**：策略模式是一种行为型设计模式，它定义了一系列算法，并将每个算法都封装起来，使得它们可以相互替换。策略模式使得算法可以独立于使用它们的客户端而变化。

### 2. 模式结构

- **模板方法模式**：
  - **抽象类**：定义了算法的骨架，包括模板方法（不可改变的固定部分）和一个或多个抽象方法（可变的部分）。
  - **具体子类**：实现或覆盖抽象方法，填补模板方法中的具体步骤。
  
- **策略模式**：
  - **策略接口**：定义了一个算法的接口。
  - **具体策略类**：实现了策略接口，提供具体的算法实现。
  - **上下文类**：持有策略接口的引用，并通过该接口调用具体的策略类来执行算法。

### 3. 目的和使用场景

- **模板方法模式**：
  - **目的**：模板方法模式的主要目的是在父类中定义一个算法的骨架，子类可以通过实现或覆盖算法中的某些步骤来定制化算法，但算法的整体结构保持不变。
  - **使用场景**：当你有一个整体结构固定的算法，但其中某些步骤可能因具体情况不同而有所变化时，可以使用模板方法模式。例如，数据处理流程、文档生成流程等。

- **策略模式**：
  - **目的**：策略模式的主要目的是将算法的实现与算法的使用分离，允许在运行时选择或切换不同的算法，而不需要修改使用这些算法的代码。
  - **使用场景**：当你有多种不同的算法可以互相替代，并且希望客户端能够根据需要选择其中一种算法时，可以使用策略模式。例如，支付方式选择、排序算法选择、路径规划算法等。

### 4. 灵活性

- **模板方法模式**：
  - **灵活性**：模板方法模式通过继承来实现算法步骤的变化，这使得它在需要增加或修改算法步骤时，需要创建新的子类或修改现有子类。因此，模板方法模式的灵活性较低，且依赖于类的继承关系。

- **策略模式**：
  - **灵活性**：策略模式通过组合而非继承来实现算法的变化。算法的实现与使用是分离的，客户端可以在运行时选择不同的策略，因此策略模式具有较高的灵活性。

### 5. 代码的复用性

- **模板方法模式**：
  - **复用性**：模板方法模式提高了代码的复用性，特别是当多个子类共享相同的算法骨架时。公共的部分可以放在抽象类中，而变化的部分由子类实现。

- **策略模式**：
  - **复用性**：策略模式也提高了代码的复用性，特别是在不同的上下文中可以复用相同的策略类。通过将不同的算法封装为策略类，可以在不同的场景中使用这些策略。

### 6. 开闭原则的实现

- **模板方法模式**：
  - **开闭原则**：模板方法模式对算法的骨架部分是封闭的（不能修改），但对子类实现的步骤是开放的（可以扩展）。要增加新的算法步骤或修改步骤的实现，通常需要创建新的子类。

- **策略模式**：
  - **开闭原则**：策略模式完全符合开闭原则。可以通过添加新的策略类来扩展新的算法，而不需要修改已有的代码。策略模式的扩展性更强，因为新的策略只需实现策略接口即可。

### 7. 具体例子对比

#### 模板方法模式示例

```java
// 抽象类：定义算法骨架
abstract class DataProcessor {
    // 模板方法：定义了算法的步骤
    public final void process() {
        loadData();
        processData();
        saveData();
    }

    protected abstract void loadData();   // 抽象方法：加载数据
    protected abstract void processData(); // 抽象方法：处理数据

    private void saveData() {
        System.out.println("Saving processed data...");
    }
}

// 具体子类：从文件加载数据
class FileDataProcessor extends DataProcessor {
    @Override
    protected void loadData() {
        System.out.println("Loading data from file...");
    }

    @Override
    protected void processData() {
        System.out.println("Processing data from file...");
    }
}

// 具体子类：从数据库加载数据
class DatabaseDataProcessor extends DataProcessor {
    @Override
    protected void loadData() {
        System.out.println("Loading data from database...");
    }

    @Override
    protected void processData() {
        System.out.println("Processing data from database...");
    }
}
```

在模板方法模式中，`process()` 方法定义了数据处理的固定流程，而 `loadData()` 和 `processData()` 方法由不同的子类来实现。

#### 策略模式示例

```java
// 策略接口：定义支付方式
interface PaymentStrategy {
    void pay(int amount);
}

// 具体策略类：信用卡支付
class CreditCardPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paying " + amount + " using Credit Card.");
    }
}

// 具体策略类：微信支付
class WeChatPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paying " + amount + " using WeChat.");
    }
}

// 上下文类：持有支付策略
class PaymentContext {
    private PaymentStrategy strategy;

    public PaymentContext(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void executePayment(int amount) {
        strategy.pay(amount);
    }
}

// 使用示例
public class Main {
    public static void main(String[] args) {
        PaymentContext context = new PaymentContext(new CreditCardPayment());
        context.executePayment(100);  // 使用信用卡支付

        context = new PaymentContext(new WeChatPayment());
        context.executePayment(200);  // 使用微信支付
    }
}
```

在策略模式中，`PaymentContext` 可以选择不同的支付策略来完成支付操作，策略类可以在运行时被替换。

### 总结

- **模板方法模式**：主要用于定义算法的骨架，允许子类在不改变算法结构的情况下定制算法的某些步骤。模板方法模式适合当算法的整体步骤是固定的，而某些步骤在不同子类中有不同实现的情况。

- **策略模式**：主要用于在运行时选择或替换不同的算法，策略模式将算法的实现和使用分离，允许在不同的场景中选择不同的策略。策略模式适合当需要在多个算法之间进行选择，且这些算法是独立的、可互换的情况。

两者的区别在于：

1. **模板方法模式**关注的是算法的结构，通过继承来定制算法的步骤，而**策略模式**关注的是算法的选择，通过组合来灵活选择不同的算法。
2. **模板方法模式**通常由父类定义算法骨架，子类实现具体步骤；而**策略模式**由上下文类持有策略接口，策略类实现不同的算法。
3. **模板方法模式**更加关注步骤的复用，而**策略模式**更加关注算法的替换和扩展。





让我用更简单的方式来解释适配器模式，并举一些具体的例子来帮助理解。

### 什么是适配器模式？

**适配器模式**是一种设计模式，目的是让两个原本不能一起工作的类能够一起工作。它就像一个“翻译器”，把一种接口转换成另一种接口，这样原本不兼容的接口可以合作。

### 现实生活中的例子

**插头适配器**：  
假设你有一个美国插头的设备，但你在欧洲旅游，欧洲的插座和美国的不一样，这时你需要一个插头适配器。这个适配器一端可以插入欧洲的插座，另一端可以连接你的美国插头。这个适配器起到的作用就是把不同的接口（插头）连接在一起，使得你的设备可以正常使用。

**USB 转换器**：  
你可能有一个带有 USB-C 接口的设备，但你的电脑只有 USB-A 接口，这时你可以使用一个 USB-C 转 USB-A 的转换器。这就是适配器模式在生活中的另一个例子。转换器将 USB-C 的信号转换为 USB-A 的信号，使得它们可以一起工作。

### 在软件中的应用

在软件开发中，我们经常会遇到这样的问题：一个类的接口不符合我们需要的接口，但我们又想利用这个类的功能。这时我们就可以使用适配器模式。

**简单的编程例子**

假设你有一个老版本的支付系统类 `OldPaymentSystem`，它的接口是 `payByCard()`，但你现在的系统只支持通过 `processPayment()` 进行支付。

```java
// 旧的支付系统
class OldPaymentSystem {
    public void payByCard() {
        System.out.println("Payment processed using Old Payment System");
    }
}

// 新的支付接口
interface PaymentProcessor {
    void processPayment();
}

// 适配器类
class PaymentAdapter implements PaymentProcessor {
    private OldPaymentSystem oldPaymentSystem;

    public PaymentAdapter(OldPaymentSystem oldPaymentSystem) {
        this.oldPaymentSystem = oldPaymentSystem;
    }

    @Override
    public void processPayment() {
        // 适配器将新接口转换为旧接口
        oldPaymentSystem.payByCard();
    }
}

// 客户端代码
public class Main {
    public static void main(String[] args) {
        OldPaymentSystem oldPaymentSystem = new OldPaymentSystem();
        PaymentProcessor paymentProcessor = new PaymentAdapter(oldPaymentSystem);
        
        // 通过适配器，我们可以使用新的接口来调用旧系统的支付功能
        paymentProcessor.processPayment();
    }
}
```

**解释**：

1. **OldPaymentSystem** 是旧的支付系统，它的接口是 `payByCard()`。
2. **PaymentProcessor** 是新的支付接口，我们的系统希望调用 `processPayment()` 方法。
3. **PaymentAdapter** 是适配器类，它实现了 `PaymentProcessor` 接口，并在内部使用 `OldPaymentSystem` 的 `payByCard()` 方法。这样，我们的系统就可以通过调用 `processPayment()` 方法来使用旧的支付系统。

**好处**：我们不用修改 `OldPaymentSystem`，也不用修改现有的系统代码，只需要创建一个适配器，就可以使它们一起工作。

#### 2. 对象适配器模式（使用组合）

对象适配器模式通过对象组合来实现适配器，它将现有的类的实例传递给适配器类，适配器类通过调用这个实例的方法来实现目标接口。

**优点**：

- 可以适配多个适配者类，因为它是通过组合的方式进行适配，不受单继承限制。
- 更灵活，可以通过传递不同的适配者实例来改变适配行为。

**缺点**：

- 由于是组合关系，不能直接访问适配者类的方法。

### 总结

适配器模式就像一个“翻译器”，让两个原本不能一起工作的类通过适配器来互相通信。它的典型应用场景是在使用现有类时，这些类的接口与目标接口不匹配，而又不能修改现有类的时候。通过适配器，我们可以在不修改现有类的情况下使得不同接口的类可以协同工作。





好的，我再给你举一个关于**类适配器模式**的例子。类适配器模式通过**继承**来实现适配功能。

### 类适配器模式示例

假设我们有一个现有的类 `Adaptee`，它提供了一些我们需要的功能，但它的接口与我们期望使用的接口不同。我们需要创建一个新的类 `Adapter`，这个类继承了 `Adaptee` 并实现了我们需要的接口 `Target`。

### 示例代码

```java
// 目标接口，客户端期望使用的接口
interface Target {
    void request();
}

// 被适配的类，现有的类（具有我们需要的功能，但接口不同）
class Adaptee {
    public void specificRequest() {
        System.out.println("Adaptee's specificRequest called");
    }
}

// 类适配器，通过继承实现适配
class ClassAdapter extends Adaptee implements Target {
    @Override
    public void request() {
        // 调用被适配者的功能
        specificRequest();
    }
}

// 客户端代码
public class Main {
    public static void main(String[] args) {
        // 使用适配器，客户端可以通过Target接口来使用Adaptee的功能
        Target target = new ClassAdapter();
        target.request(); // 输出: Adaptee's specificRequest called
    }
}
```

### 解释

1. **Target接口**：这是客户端期望使用的接口，它定义了 `request()` 方法。客户端的代码将使用这个接口来调用方法。

2. **Adaptee类**：这是现有的类，它已经有了一个方法 `specificRequest()`，但这个方法的名字和 `Target` 接口中的方法名字不同（功能也可能不同）。

3. **ClassAdapter类**：这是适配器类，它继承了 `Adaptee` 类并实现了 `Target` 接口。通过继承 `Adaptee`，`ClassAdapter` 获得了 `Adaptee` 的所有方法，同时实现了 `Target` 接口中的 `request()` 方法。在 `request()` 方法内部，适配器调用了 `specificRequest()` 方法，从而实现接口的适配。

4. **客户端代码**：客户端通过 `Target` 接口来使用适配器。虽然客户端调用的是 `request()` 方法，但实际上执行的是 `Adaptee` 的 `specificRequest()` 方法。

### 类适配器模式的特点

- **继承**：类适配器通过继承现有类来实现适配，这意味着适配器类自动获得了被适配类的所有功能。
- **实现接口**：适配器类还实现了目标接口，从而在接口层面上满足客户端的需求。
- **单继承限制**：由于 Java 是单继承的语言，类适配器模式不能适配多个类（即一个适配器类只能继承一个类），这限制了它的灵活性。

### 类适配器模式的优缺点

**优点**：
- **简单直接**：适配器类通过继承获得现有类的所有功能，无需额外组合对象。
- **性能高**：由于适配器类和被适配类是同一个对象（通过继承实现），调用效率高。

**缺点**：
- **单继承限制**：类适配器只能适配一个类，无法处理多重适配。
- **不兼容多个适配者**：无法适配多个类的功能，因为它只能继承一个类。

### 类适配器模式的应用场景

- 当你想使用某个现有类，但是它的接口不符合你的要求，并且你无法修改这个类的源代码。
- 当你想对一个类进行一些功能增强，并希望将其接口改为某个标准接口时，可以使用类适配器模式。

### 总结

类适配器模式通过继承来适配一个类，使其接口符合客户端的要求。这种方式简单直接，但由于 Java 中的单继承限制，它在适配多个类时显得不够灵活。在需要更灵活的适配时，通常会选择对象适配器模式。

### 适配器模式的实际应用

#### 1. **生活中的插座转换器**

在不同国家或地区，电源插座的形状、大小、输入电压都可能不同。如果你去国外旅行，你可能需要一个插座转换器，以适应当地的插座形状。这就是一种适配器模式的实际应用：插座转换器将一个电器设备（比如你的手机充电器）的插头接口转换为可以适应当地插座的接口。

#### 2. **软件开发中的数据库连接**

在软件开发中，不同的数据库系统（如 MySQL、Oracle、PostgreSQL）通常有不同的连接接口。如果一个应用程序需要支持多种数据库系统，通常会使用适配器模式将不同数据库的连接接口统一为一个标准接口，从而简化代码逻辑，使得应用程序能够与多种数据库无缝协作。

#### 3. **第三方库的整合**

在开发过程中，可能需要使用某些第三方库，而这些库的接口与我们现有的系统接口不兼容。通过适配器模式，可以创建一个适配器类，将第三方库的接口转换为我们系统所期望的接口，从而实现整合。




**HTTPS** **解决了** **HTTP** **的哪些问题？**

HTTP 由于是明⽂传输，所以安全上存在以下三个⻛险：

**窃听⻛险**，⽐如通信链路上可以获取通信内容，⽤户号容易没。

**篡改⻛险**，⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。

**冒充⻛险**，⽐如冒充淘宝⽹站，⽤户钱容易没。

<img src="/Users/haozhipeng/Library/Application Support/typora-user-images/image-20240808150744618.png" alt="image-20240808150744618" style="zoom:50%;" />

HTTP**S** 在 HTTP 与 TCP 层之间加⼊了 SSL/TLS 协议，可以很好的解决了上述的⻛险：

**信息加密**：交互信息⽆法被窃取，但你的号会因为「⾃身忘记」账号⽽没。

**校验机制**：⽆法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾⼴

告。

**身份证书**：证明淘宝是真的淘宝⽹，但你的钱还是会因为「剁⼿」⽽没。

可⻅，只要⾃身不做「恶」，SSL/TLS 协议是能保证通信是安全的。

HTTPS 是如何解决上⾯的三个⻛险的？

**混合加密**的⽅式实现信息的**机密性**，解决了窃听的⻛险。

**摘要算法**的⽅式来实现**完整性**，它能够为数据⽣成独⼀⽆⼆的「指纹」，指纹⽤于校验数据的完整

性，解决了篡改的⻛险。

将服务器公钥放⼊到**数字证书**中，解决了冒充的⻛险。

*1.* 混合加密通过**混合加密**的⽅式可以保证信息的**机密性**，解决了窃听的⻛险。

<img src="/Users/haozhipeng/Library/Application Support/typora-user-images/image-20240808150813050.png" alt="image-20240808150813050" style="zoom:50%;" />

HTTPS 采⽤的是**对称加密**和**⾮对称加密**结合的「混合加密」⽅式：

在通信建⽴前采⽤**⾮对称加密**的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。

在通信过程中全部使⽤**对称加密**的「会话秘钥」的⽅式加密明⽂数据。

采⽤「混合加密」的⽅式的原因：

**对称加密**只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。

**⾮对称加密**使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度

慢。

*2.* 摘要算法 *+* 数字签名

为了保证传输的内容不被篡改，我们需要对内容计算出⼀个「指纹」，然后同内容⼀起传输给对⽅。

对⽅收到后，先是对内容也计算出⼀个「指纹」，然后跟发送⽅发送的「指纹」做⼀个⽐较，如果「指

纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。那么，在计算机⾥会**⽤摘要算法（哈希函数）来计算出内容的哈希值**，也就是内容的「指纹」，这个**哈希**

**值是唯⼀的，且⽆法通过哈希值推导出内容**。

<img src="/Users/haozhipeng/Library/Application Support/typora-user-images/image-20240808150855326.png" alt="image-20240808150855326" style="zoom:50%;" />

通过哈希算法可以确保内容不会被篡改，**但是并不能保证「内容** **+** **哈希值」不会被中间⼈替换，因为这⾥**

**缺少对客户端收到的消息是否来源于服务端的证明**。

举个例⼦，你想向⽼师请假，⼀般来说是要求由家⻓写⼀份请假理由并签名，⽼师才能允许你请假。

但是你有模仿你爸爸字迹的能⼒，你⽤你爸爸的字迹写了⼀份请假理由然后签上你爸爸的名字，⽼师⼀看

到这个请假条，查看字迹和签名，就误以为是你爸爸写的，就会允许你请假。

那作为⽼师，要如何避免这种情况发⽣呢？现实⽣活中的，可以通过电话或视频来确认是否是由⽗⺟发出

的请假，但是计算机⾥可没有这种操作。

那为了避免这种情况，计算机⾥会⽤**⾮对称加密算法**来解决，共有两个密钥：

⼀个是公钥，这个是可以公开给所有⼈的；

⼀个是私钥，这个必须由本⼈管理，不可泄露。

这两个密钥可以**双向加解密**的，⽐如可以⽤公钥加密内容，然后⽤私钥解密，也可以⽤私钥加密内容，公

钥解密内容。

流程的不同，意味着⽬的也不相同：

**公钥加密，私钥解密**。这个⽬的是为了**保证内容传输的安全**，因为被公钥加密的内容，其他⼈是⽆法

解密的，只有持有私钥的⼈，才能解密出实际的内容；

**私钥加密，公钥解密**。这个⽬的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的⼈发送的。

⼀般我们不会⽤⾮对称加密来加密实际的传输内容，因为⾮对称加密的计算⽐较耗费性能的。

所以⾮对称加密的⽤途主要在于**通过「私钥加密，公钥解密」的⽅式，来确认消息的身份**，我们常说的**数**

**字签名算法**，就是⽤的是这种⽅式，不过私钥加密内容不是内容本身，⽽是**对内容的哈希值加密**。

<img src="/Users/haozhipeng/Library/Application Support/typora-user-images/image-20240808150923968.png" alt="image-20240808150923968" style="zoom:50%;" />

私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，

就说明该消息是由服务器发送的。

引⼊了数字签名算法后，你就⽆法模仿你爸爸的字迹来请假了，你爸爸⼿上持有着私钥，你⽼师持有着公

钥。

这样只有⽤你爸爸⼿上的私钥才对请假条进⾏「签名」，⽼师通过公钥看能不能解出这个「签名」，如果

能解出并且确认内容的完整性，就能证明是由你爸爸发起的请假条，这样⽼师才允许你请假，否则⽼师就

不认。

*3.* 数字证书

前⾯我们知道：

可以通过哈希算法来保证消息的完整性；

可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的⼀⽅发送的）；

但是这还远远不够，**还缺少身份验证的环节**，万⼀公钥是被伪造的呢？还是拿请假的例⼦，虽然你爸爸持有私钥，⽼师通过是否能⽤公钥解密来确认这个请假条是不是来源你⽗

亲的。

但是我们还可以⾃⼰伪造出⼀对公私钥啊！

你找了个夜晚，偷偷把⽼师桌⾯上和你爸爸配对的公钥，换成了你的公钥，那么下次你在请假的时候，你

继续模仿你爸爸的字迹写了个请假条，然后⽤你的私钥做个了「数字签名」。

但是⽼师并不知道⾃⼰的公钥被你替换过了，所以他还是按照往常⼀样⽤公钥解密，由于这个公钥和你的

私钥是配对的，⽼师当然能⽤这个被替换的公钥解密出来，并且确认了内容的完整性，于是⽼师就会以为

是你⽗亲写的请假条，⼜允许你请假了。

好家伙，为了⼀个请假，真的是⽃智⽃勇。

后⾯你的⽼师和⽗亲发现了你伪造公私钥的事情后，决定新商⼀个对策来应对你这个臭家伙。

正所谓魔⾼⼀丈，道⾼⼀尺。

既然伪造公私钥那么随意，所以你爸把他的公钥注册到**警察局**，警察局⽤他们⾃⼰的私钥对你⽗亲的公钥

做了个数字签名，然后把你爸爸的「个⼈信息 + 公钥 + 数字签名」打包成⼀个**数字证书，也就是说这个数**

**字证书包含你爸爸的公钥。**

这样，你爸爸如果因为家⾥确实有事要向⽼师帮你请假的时候，不仅会⽤⾃⼰的私钥对内容进⾏签名，还

会把数字证书给到⽼师。

⽼师拿到了数字证书后，**⾸先会去警察局验证这个数字证书是否合法**，因为数字证书⾥有警察局的数字签

名，警察局要验证证书合法性的时候，⽤⾃⼰的公钥解密，如果能解密成功，就说明这个数字证书是在警

察局注册过的，就认为该数字证书是合法的，然后就会把数字证书⾥头的公钥（你爸爸的）给到⽼师。

**由于通过警察局验证了数字证书是合法的，那么就能证明这个公钥就是你⽗亲的**，于是⽼师就可以安⼼的

⽤这个公钥解密出请假条，如果能解密出，就证明是你爸爸写的请假条。

正是通过了⼀个权威的机构来证明你爸爸的身份，所以你的伪造公私钥这个⼩伎俩就没⽤了。

在计算机⾥，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书

认证机构颁发）中，只要证书是可信的，公钥就是可信的。

数字证书的⼯作流程，我也画了⼀张图，⽅便⼤家理解：

<img src="/Users/haozhipeng/Library/Application Support/typora-user-images/image-20240808151012643.png" alt="image-20240808151012643" style="zoom:50%;" />

通过数字证书的⽅式保证服务器公钥的身份，解决冒充的⻛险。

**HTTPS** **是如何建⽴连接的？其间交互了什么？**

SSL/TLS 协议基本流程：

客户端向服务器索要并验证服务器的公钥。

双⽅协商⽣产「会话秘钥」。

双⽅采⽤「会话秘钥」进⾏加密通信。

前两步也就是 SSL/TLS 的建⽴过程，也就是 TLS 握⼿阶段。

TLS 的「握⼿阶段」涉及**四次**通信，使⽤不同的密钥交换算法，TLS 握⼿流程也会不⼀样的，现在常⽤的

密钥交换算法有两种：RSA 算法 和 ECDHE 算法。

基于 RSA 算法的 TLS 握⼿过程⽐较容易理解，所以这⾥先⽤这个给⼤家展示 TLS 握⼿过程，如下图：

![image-20240808151110375](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20240808151110375.png)



![image-20240808151125165](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20240808151125165.png)

TLS 协议建⽴的详细流程：

*1. ClientHello*

⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。

在这⼀步，客户端主要向服务器发送以下信息：

（1）客户端⽀持的 TLS 协议版本，如 TLS 1.2 版本。

（2）客户端⽣产的随机数（ Client Random ），后⾯⽤于⽣成「会话秘钥」条件之⼀。

（3）客户端⽀持的密码套件列表，如 RSA 加密算法。

*2. SeverHello*

服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容：

（1）确认 TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。

（2）服务器⽣产的随机数（ Server Random ），也是后⾯⽤于⽣产「会话秘钥」条件之⼀。

（3）确认的密码套件列表，如 RSA 加密算法。

（4）服务器的数字证书。

*3.*客户端回应

客户端收到服务器的回应之后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真

实性。如果证书没有问题，客户端会**从数字证书中取出服务器的公钥**，然后使⽤它加密报⽂，向服务器发送如下

信息：

（1）⼀个随机数（ pre-master key ）。该随机数会被服务器公钥加密。

（2）加密通信算法改变通知，**表示随后的信息都将⽤「会话秘钥」加密通信。**

（3）客户端握⼿结束通知，表示**客户端的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做**

**个摘要，⽤来供服务端校验。**

上⾯第⼀项的随机数是整个握⼿阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都

是⼀样的。

**服务器和客户端有了这三个随机数（****Client Random****、****Server Random****、****pre-master key****），接着就⽤双**

**⽅协商的加密算法，各⾃⽣成本次通信的「会话秘钥」**。

*4.* 服务器的最后回应

服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的

「会话秘钥」。

然后，向客户端发送最后的信息：

（1）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。

（2）服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做

个摘要，⽤来供客户端校验。

⾄此，整个 TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使⽤普通的

HTTP 协议，只不过⽤「会话秘钥」加密内容。

客户端校验数字证书的流程是怎样的？

接下来，详细说⼀下实际中数字证书签发和验证流程。

如下图图所示，为数字证书签发和验证流程：

<img src="/Users/haozhipeng/Library/Application Support/typora-user-images/image-20240808151356933.png" alt="image-20240808151356933" style="zoom:50%;" />

CA 签发证书的过程，如上图左边部分：

⾸先 CA 会把**持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏**

**Hash 计算，得到⼀个 Hash 值；**

然后 **CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 Certificate Signature，也就是 CA 对证书做了签**

**名；**

最后将 Certificate Signature 添加在⽂件证书上，形成数字证书；

客户端校验服务端的数字证书的过程，如上图右边部分：

⾸先客户端会使⽤同样的 Hash 算法获取该证书的 Hash 值 H1；

通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使⽤ CA 的公钥解密

Certificate Signature 内容，得到⼀个 Hash 值 H2 ；

最后⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。

但事实上，证书的验证过程中**还存在⼀个证书信任链的问题**，因为我们向 CA 申请的证书⼀般不是根证书

签发的，⽽是由中间证书签发的，⽐如百度的证书，从下图你可以看到，证书的层级有三级











### MD5 详细介绍

#### 1. 什么是 MD5？

MD5（Message-Digest Algorithm 5）是一种广泛使用的哈希函数，能产生一个128位（16字节）的哈希值（散列值）。MD5 是由 Ronald Rivest 在1991年设计的，用于确保信息传递完整一致。虽然 MD5 已被证明存在安全性漏洞，但它仍然在某些场景中被使用。

#### 2. MD5 的特点

1. **固定长度输出**：无论输入的大小，MD5 总是生成128位（16字节）的哈希值。
2. **高效性**：MD5 算法设计用于快速计算，适合在计算资源有限的环境中使用。
3. **广泛使用**：尽管有安全性问题，MD5 仍然在文件完整性验证等非安全性要求高的场景中广泛使用。

#### 3. MD5 的工作原理

MD5 算法对输入信息进行处理，将其分为固定的512位的块，并通过一系列复杂的步骤进行计算，生成128位的哈希值。MD5 的计算过程包括以下几个步骤：

1. **填充消息**：将消息填充到长度满足 `448 mod 512` 位，填充方式为在消息末尾加上一个1和若干个0。
2. **附加长度**：将消息的原始长度（以64位表示）附加到填充后的消息末尾，使得消息的总长度为512的倍数。
3. **初始化 MD 缓冲区**：初始化4个32位的缓冲区（A、B、C、D），它们用于存储中间和最终的哈希值。
4. **处理每个512位的块**：对每个512位的块进行处理，更新缓冲区的值。
5. **输出**：最终的哈希值由缓冲区的内容连接得到。

#### 4. MD5 的应用

1. **文件完整性验证**：计算文件的 MD5 哈希值，下载文件后计算哈希值对比，确保文件未被篡改。
2. **数字签名**：在电子邮件和软件分发中使用 MD5 进行数字签名，以验证数据的完整性。
3. **密码存储**：尽管不推荐，仍有一些旧系统使用 MD5 存储密码的哈希值。

#### 5. MD5 的局限性和安全问题

1. **碰撞攻击**：MD5 已被证明容易发生碰撞，即不同的输入可能产生相同的哈希值，这使得 MD5 不适合用于安全性要求高的场景。
2. **抗预像攻击**：MD5 的设计使其不具备足够的抗预像攻击能力，攻击者可以找到与给定哈希值匹配的输入。
3. **不适合密码存储**：MD5 的速度较快，容易被暴力破解，不适合用于密码存储。现代密码学推荐使用更安全的哈希函数，如 SHA-256 或 bcrypt。
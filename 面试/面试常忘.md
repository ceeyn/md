### java为什么是值传递

对于基本类型：传递的是值的拷贝。

对于对象类型：传递的是引用的拷贝（引用本身按值传递）。

1.安全性，对引用的复制不会影响到原来对象

2.易用性，所有赋值统一

3.使垃圾回收实现更为简单，传递值的复制，则出了方法作用域后生命周期结束，并且垃圾回收进行可达性分析时也更为简单





### 1.动态代理

1.jdk继承接口代理，jdk动态代理前16次会反射调用，第17次会基于fastclass创建一个代理类，将方法签名映射成index，调用目标的方法，不走反射，提升性能，但是每次方法调用都会生成一个代理类

2.cglib继承原有类代理，不能代理final，private方法，可以选择反射调用和fastclass机制生成调用，fastclass机制空间换时间，不走反射，性能较高



### java类加载

1.加验准解初使卸

编译：生成class文件，final对象赋初值

加载：根据类的全限定类名，读取class文件，加载类的元信息到方法区，并生成一个Class对象作为访问类的信息的入口

准备：static赋初值

解：符号引用转化为直接引用

初：static变量赋值，static方法执行

使用：生成对象： **初始化零值**，**实例变量显式赋值**，**构造方法逻辑**

卸载：1.类所有对象回收，2.类的所有classLoader回收 3.类的Class对象回收





## 三级缓存





## 事务失效

事务传播级别：require，support，nested，nerver，madatory

support：如果有事务就加入；如果没有就以非事务方式执行

NESTED：**如果有事务，就在当前事务中开启一个“嵌套事务”；如果没有，就和 REQUIRED 一样新建事务**

MANDATORY：当前必须有事务，没有事务就抛异常，子方法对事务有依赖



1.代理失效的场景，private、static、final，调用本类中的方法导致事务失效

2.注解属性 rollbackFor 设置错误，事务默认回滚运行时异常，受检异常会失效

3.异常被 catch 捕获导致 @Transactional 失效

4.数据库引擎不支持事务

5.多线程环境下事务失效

6.事务传播级别设置不当，required_new会创建新的事务，如果原事务回滚，新事务提交了，这个时候会出现不一致情况





## java线程

<img src="/Users/moon/Library/Application Support/typora-user-images/image-20241206095746320.png" alt="image-20241206095746320" style="zoom:50%;" />


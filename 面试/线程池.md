### 为什么用线程池

1.基于一种池化思想，将一些资源统一管理，减少频繁分配和销毁的开销

2.可以快速响应业务



## 线程池实际使用

1.分析

（1）根据io拆分，cpu密集型、io密集型（依赖于sql的）、混合型（可以拆分成一个cpu密集型，io密集型，若时间相差不大则进行拆分），

（2）根据执行时间、业务拆分，可以根据不同的任务时间拆分出不同细致的线程池，优先级，使用PriorityBlockingQueue，

（3）根据响应速度、吞吐量，响应速度可以不设阻塞队列，吞吐量为了尽可能提高单位时间处理任务量，可以设置较大的队列



2.动态化线程池

配置：可以将线程池的核心参数设置成可配置，例如将核心线程数、最大线程数、任务队列放到zookeeper，监听变化后实时更新，本地有set的方法可实时改变，

监控：统计关键指标，通过重写beforeExcute，最小耗时、最大耗时、平均耗时，通过核心线程占最大线程的比例可以统计出线程池的负载，可以按任务的名称显示，p95，p99

告警：如果关键指标出现问题，例如负载过高等及时通知线程池负责人处理





### 线程池

1.默认：直接拒绝提交的新任务，并抛出 `RejectedExecutionException`。

2.当前线程池无法处理任务时，新任务会**被提交给调用任务的线程来运行**。这意味着调用线程会同步执行任务，而不是放入线程池中执行。

3.如果任务无法被执行，**直接丢弃新提交的任务**，不做任何处理，也不抛出异常

4.如果线程池队列满了，**会丢弃队列中最早的未执行的任务，然后【重新尝试提交当前任务**】

```java
package concurrent.src.main.java.threadpool;

import lombok.extern.slf4j.Slf4j;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicIntegerArray;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @ClassName ThreadPool
 * @Description TODO
 * @Author @hzp
 * @Date 2023/6/22 9:28 AM
 * @Version 1.0
 */
@Slf4j(topic = "c.TestPool")
public class TestPool {
    public static void main(String[] args) {
        // core是worker数量，queue capacity是队列容量
        ThreadPool threadPool = new ThreadPool(1,1000,
                TimeUnit.MILLISECONDS,1,(queue, task)->{
            // 死等
            queue.put(task);
        });
        // 添加任务
        for (int i = 0; i < 3; i++) {
            int j = i;
            threadPool.execute(()->{
                try{
                    Thread.sleep(10000000);
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
                log.debug("{}", j);
            });
        }
    }
}
interface  RejectPolicy <T>{
    void reject(BlockingQueue<T> queue, T task);
}
@Slf4j(topic = "c.ThreadPool")
class ThreadPool {

    // 线程集合
    private HashSet<Worker> workers = new HashSet<>();

    // 任务数
    private BlockingQueue<Runnable> blockingQueue;

    // 核心线程数
    private int coreSize;

    // 消费超时时间
    private long timeout;

    private TimeUnit timeUnit;

    private RejectPolicy rejectPolicy;

    public void execute(Runnable task) {
        synchronized (workers) {
            if (workers.size() < coreSize) {
                Worker worker = new Worker(task);
                log.debug("新增worker{}任务{}", worker,task);
                workers.add(worker);
                worker.start();
            } else {
                blockingQueue.putWithReject(rejectPolicy, task);
            }
        }
    }
    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapacity,RejectPolicy rejectPolicy) {
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        blockingQueue = new BlockingQueue<>(queueCapacity);
        this.rejectPolicy = rejectPolicy;
    }

    class Worker extends Thread{

        private Runnable task;

        public Worker(Runnable task) {
            this.task = task;
        }
        @Override
        public void run() {
            //blockingQueue.poll(timeout,timeUnit)
            while(task != null || (task = blockingQueue.poll(timeout,timeUnit))!=null){
                try{
                    log.debug("正在执行{}",task);
                    task.run();
                }catch (Exception e){
                    e.printStackTrace();
                }finally {
                    task = null;
                }
            }
            synchronized (workers){
                log.debug("worker被移除{}",this);
                workers.remove(this);
            }
        }
    }
}





@Slf4j(topic = "c.BlockingQueue")
class BlockingQueue<T> {

    private Deque<T> blockingQueue = new ArrayDeque<>();

    private volatile int capacity;

    private ReentrantLock lock = new ReentrantLock();

    private Condition inWaitSet = lock.newCondition();

    private Condition outWaitSet = lock.newCondition();

    public BlockingQueue(int capacity) {
        this.capacity = capacity;
    }
    // 生产者线程
    public void put(T task) {
        lock.lock();
        try {
            while(blockingQueue.size() == capacity){
                try {
                    log.debug("等待放入队列{}",task);
                    inWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            blockingQueue.add(task);
            outWaitSet.signal();
        } finally {
            lock.unlock();
        }
    }

    // 消费者线程
    public T pull() {
        lock.lock();
        try{
            while(blockingQueue.isEmpty()) {
                try {
                    outWaitSet.await();
                }catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = blockingQueue.removeFirst();
            inWaitSet.signal();
            return t;
        }  finally{
            lock.unlock();

        }
    }
    void takeCareOfBabyYvonne(Boolean 好吃的,Boolean 不让生气要让开心,Integer 感情,Integer Yvonne健康){
        while(true){
            if (不让生气要让开心 && 好吃的){
                感情++;
                Yvonne健康++;
            }
        }
    }
    // 带超时的消费者线程增强
    public T poll(long timeout, TimeUnit timeUnit) {
        long nanos = timeUnit.toNanos(timeout);
        lock.lock();
        try{
            while(blockingQueue.isEmpty()) {
                try {
                    if(nanos <= 0)
                        return null;
                     nanos = outWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = blockingQueue.removeFirst();
            inWaitSet.signal();
            return t;
        }finally{
            lock.unlock();
        }
    }
    // 带拒绝策略的生产者线程
    public void putWithReject(RejectPolicy<T> rejectPolicy, T task) {
        lock.lock();
        try {
            if (blockingQueue.size() == capacity) {
                rejectPolicy.reject(this, task);
            } else {
                log.debug("加入任务队列{}",task);
                blockingQueue.addLast(task);
                outWaitSet.signal();
            }
        }finally {
            lock.unlock();
        }
    }
    public int getSize() {
        synchronized (this) {
            return blockingQueue.size();
        }
    }
}

```



**AtomicInteger ctl 高三位是状态，低29位是数量，使用CAS更新ctl**

`workerCount` 指的是**所有活跃的线程数量（包括核心线程和非核心线程）**，而 **核心线程数和非核心线程数是不同的概念**

<img src="https://static001.infoq.cn/resource/image/51/ed/510e1bbdfa9bca708785be5d38025ced.png" alt="img" style="zoom: 67%;" />







<img src="https://static001.infoq.cn/resource/image/cc/5f/cc7aa71387bdd4e5897111dd3b6ea85f.png" alt="img"  />

### ⑥ 线程池的关闭（`shutdown或者shutdownNow方法`）

- 可以通过调用线程池的`shutdown或者shutdownNow方法`来关闭线程池：遍历线程池中工作线程，逐个调用`interrupt方法`来**中断线程**。
- **shutdown方法与shutdownNow的特点：**

1. `shutdown方法`将线程池的状态设置为`SHUTDOWN状态`，**只会中断空闲的工作线程**。
2. `shutdownNow方法`将线程池的状态设置为`STOP状态`，**会中断所有工作线程**，不管工作线程是否空闲。
3. 

<img src="https://static001.infoq.cn/resource/image/97/0d/974fef22f013d269778bbe7b7f81b60d.png" alt="img"  />





<img src="https://static001.infoq.cn/resource/image/f0/66/f0b32b9577575252ea4e8f2c4d39a266.png" alt="img"  />










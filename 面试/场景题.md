# cpu达到百分百

- **jmap**：用于分析内存问题，生成堆内存快照 (`-dump`)，查看堆内存结构 (`-heap`)，用于解决内存泄漏、内存溢出等问题。

- **jstack**：用于分析线程问题，打印线程栈 (`jstack`)，找出死锁、线程阻塞、线程过多等问题。

- `jstat` 是一个强大的命令行工具，专门用于监控 JVM 的内存和 GC 活动。

  常用参数包括 `-gc`、`-gcutil`、`-class`，分别用于监控垃圾回收信息、内存利用率、类加载情况等。



https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng%3D%3D&chksm=fa4973dfcd3efac99d7296aecb51c115797bfabaec7cd30363a8f66c34ebbd486eb4a48b8296&idx=1&mid=2247486574&scene=27&sn=7daeaee15c4f8c28162cc92bf7321843&utm_campaign=geek_search&utm_content=geek_search&utm_medium=geek_search&utm_source=geek_search&utm_term=geek_search#wechat_redirect



https://blog.csdn.net/chenlixiao007/article/details/105999034?ops_request_misc=%257B%2522request%255Fid%2522%253A%25222C806BE9-3F67-48D3-B4CC-2A99E7060261%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=2C806BE9-3F67-48D3-B4CC-2A99E7060261&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-16-105999034-null-null.142^v100^pc_search_result_base1&utm_term=java%20cpu%20100&spm=1018.2226.3001.4187



首先我们通过`top`命令查看当前CPU消耗过高的进程是哪个，从而得到进程id；然后通过`top -Hp <pid>`来查看该进程中有哪些线程CPU过高，一般超过80%就是比较高的，80%左右是合理情况。这样我们就能得到CPU消耗比较高的线程id。接着通过该`线程id的十六进制表示`在`jstack`日志中查看当前线程具体的堆栈信息。

在这里我们就可以区分导致CPU过高的原因具体是Full GC次数过多还是代码中有比较耗时的计算了。如果是Full GC次数过多，那么通过`jstack`得到的线程信息会是类似于VM Thread之类的线程，而如果是代码中有比较耗时的计算，那么我们得到的就是一个线程的具体堆栈信息。如下是一个代码中有比较耗时的计算，导致CPU过高的线程信息：

- 如果通过 `top` 命令看到CPU并不高，并且系统内存占用率也比较低。此时就可以考虑是否是由于另外三种情况导致的问题。具体的可以根据具体情况分析：
- 如果是接口调用比较耗时，并且是不定时出现，则可以通过压测的方式加大阻塞点出现的频率，从而通过`jstack`查看堆栈信息，找到阻塞点；
- 如果是某个功能突然出现停滞的状况，这种情况也无法复现，此时可以通过多次导出`jstack`日志的方式对比哪些用户线程是一直都处于等待状态，这些线程就是可能存在问题的线程；
- 如果通过`jstack`可以查看到死锁状态，则可以检查产生死锁的两个线程的具体阻塞点，从而处理相应的问题。





```
以下是将上述操作步骤整理成 Markdown 格式 的说明：

定位高 CPU 消耗线程并分析堆栈信息

通过 top、jstack 和线程 ID 的十六进制转换，定位导致高 CPU 消耗的线程，并分析其堆栈信息。

步骤 1：使用 top 找到 CPU 消耗高的进程

运行以下命令，找到 CPU 使用率较高的进程：

top

在 top 的输出中，找到 %CPU 较高的进程，记下其进程 ID（pid）。

步骤 2：使用 top -Hp <pid> 找到高 CPU 消耗的线程

假设在步骤 1 中找到的 pid 是 12345，运行以下命令查看该进程的线程信息：

top -Hp 12345

在输出中：
	•	找到 %CPU 高的线程。
	•	记下该线程的线程 ID（tid）。

步骤 3：将线程 ID 转换为十六进制

jstack 输出中的线程标识符（nid）是十六进制格式，因此需要将 tid 转换为十六进制。

假设线程 ID 是 67890，运行以下命令：

printf "%x\n" 67890

示例输出：

10932

这个 10932 就是对应线程的十六进制 ID，用于在 jstack 输出中查找线程堆栈信息。

步骤 4：使用 jstack 获取堆栈信息

运行以下命令导出进程的线程堆栈信息：

jstack 12345 > thread_dump.txt

打开 thread_dump.txt 文件，搜索转换后的十六进制线程 ID。例如，搜索：

nid=0x10932

找到该线程对应的堆栈信息，分析线程堆栈，判断是否是代码问题或其他原因导致高 CPU 消耗。

完整示例

以下是完整的操作命令示例：
	1.	找到 CPU 消耗高的进程：

top


	2.	查看进程中的线程信息：

top -Hp 12345


	3.	将线程 ID 转换为十六进制：

printf "%x\n" 67890


	4.	导出堆栈信息并查找线程：

jstack 12345 > thread_dump.txt
grep "nid=0x10932" thread_dump.txt

通过上述步骤，可以定位导致 CPU 使用率过高的线程，并通过其堆栈信息进一步分析具体原因，例如：
	•	Full GC 过多（堆栈显示为 VM Thread 相关信息）。
	•	代码计算过于耗时（堆栈显示为具体业务逻辑）。
	•	死锁或阻塞问题（通过多次堆栈对比发现线程一直等待）。

参考命令说明
	•	top：查看系统进程和 CPU 使用情况。
	•	top -Hp <pid>：查看指定进程的线程 CPU 使用情况。
	•	printf "%x\n"：将十进制线程 ID 转换为十六进制。
	•	jstack：生成 Java 进程的线程堆栈信息。

通过这些工具，可以快速排查和解决高 CPU 消耗问题。


```



````
`jstat` 是 Java 虚拟机 (JVM) 自带的监控工具，用于实时监控和收集 JVM 的各项性能数据。它是一个非常有用的工具，可以帮助开发者了解 Java 应用程序在运行过程中垃圾收集 (GC)、内存分布、类加载等方面的情况，进而发现潜在的性能瓶颈和内存泄漏问题。

### `jstat` 的作用及使用场景

`jstat` 可以监控以下几类 JVM 的性能指标：

1. **GC 信息** (`jstat -gc`)：
   - 显示 JVM 中各个代（新生代、老年代、元空间等）的使用情况以及 GC 次数、GC 时间。
   - **应用场景**：当应用程序出现性能瓶颈、频繁触发垃圾回收或长时间的停顿 (Stop-The-World) 时，可以使用 `jstat -gc` 命令查看各代空间的占用和 GC 的频率，帮助判断是哪个区域导致了频繁的 GC。

2. **类加载信息** (`jstat -class`)：
   - 显示类加载的统计信息，包括类的加载数量、内存使用、卸载类数量等。
   - **应用场景**：在大规模 Java 应用中，监控类的加载情况，可以判断是否有类的频繁加载和卸载，造成内存使用的剧烈变化。

3. **内存统计信息** (`jstat -gccapacity`)：
   - 显示新生代、老年代、元空间等的容量和内存使用情况。
   - **应用场景**：帮助了解内存的分配情况，观察不同区域的使用是否接近其容量上限，判断是否需要调整 JVM 内存参数。

4. **GC 统计信息** (`jstat -gcutil`)：
   - 显示各个代的利用率（Eden 区、Survivor 区、Old 区、元空间）和 GC 次数、GC 总时间。
   - **应用场景**：帮助了解应用程序在某个时间点各内存区域的占用率以及 GC 情况，判断垃圾回收的频率和效果。

5. **JVM 运行信息** (`jstat -compiler`、`jstat -printcompilation`)：
   - 显示 JIT 编译的信息，监控 JIT 编译器如何将字节码转换为机器码，了解哪些方法进行了编译、编译的时间等。
   - **应用场景**：通过查看 JIT 编译的信息，了解是否有热点代码被频繁地编译，判断 JVM 的性能是否因为编译而受到影响。

### 使用 `jstat` 的具体示例

#### 示例：监控垃圾收集 (GC) 情况

假设应用程序的进程 ID 为 `1234`，你想监控 JVM 各内存区域的垃圾回收情况，可以使用以下命令：

```sh
jstat -gc 1234 1000
```

- `-gc` 表示查看 GC 信息。
- `1234` 是 Java 应用程序的进程 ID。
- `1000` 表示每隔 1000 毫秒（即 1 秒）刷新一次信息。

输出示例如下：

```
 S0C    S1C    S0U    S1U      EC       EU       OC         OU       MC       MU     CCSC     CCSU       YGC     YGCT    FGC    FGCT     GCT
1024.0 1024.0  256.0   0.0   8192.0   1024.0  32768.0    1024.0   4480.0    4320.5   512.0    512.0        4    0.024     1     0.020    0.044
```

解释：
- **S0C、S1C**：Survivor 0 区和 Survivor 1 区的容量。
- **S0U、S1U**：Survivor 0 区和 Survivor 1 区的使用量。
- **EC、EU**：Eden 区的容量和使用量。
- **OC、OU**：老年代的容量和使用量。
- **YGC、YGCT**：年轻代 GC 的次数和所用的时间。
- **FGC、FGCT**：Full GC 的次数和所用的时间。

通过这些数据，可以很直观地看到 GC 的执行次数和各个内存区域的使用情况。如果年轻代的使用量接近容量，则说明可能频繁发生 Minor GC；而老年代的使用接近容量，则可能会引起 Full GC。

#### 示例：监控内存利用率

可以通过以下命令查看各个区域的内存利用率情况：

```sh
jstat -gcutil 1234 2000
```

- `-gcutil` 表示显示各代内存的利用率。
- `1234` 是进程 ID。
- `2000` 表示每隔 2000 毫秒（即 2 秒）刷新一次数据。

输出示例如下：

```
  S0     S1     E      O      M     CCS     YGC    FGC    FGCT     GCT
  10.5   0.0   15.0   20.1   75.0   65.0      4      1     0.022    0.032
```

解释：
- **S0、S1**：Survivor 区的利用率。
- **E**：Eden 区的利用率。
- **O**：Old 区（老年代）的利用率。
- **M**：元空间的利用率。
- **CCS**：Compressed Class Space 的利用率。
- **YGC**：年轻代 GC 的次数。
- **FGC**：Full GC 的次数。
- **FGCT、GCT**：Full GC 和总 GC 所消耗的时间。

这些利用率指标能够帮助我们了解当前内存的使用情况，从而评估 JVM 配置是否合理，是否需要调整垃圾收集器的参数等。

#### 示例：监控类加载情况

可以使用以下命令监控 JVM 中类的加载情况：

```sh
jstat -class 1234 1000
```

- `-class` 表示监控类加载的情况。
- `1234` 是进程 ID。
- `1000` 表示每隔 1000 毫秒刷新一次。

输出示例如下：

```
  Loaded  Bytes  Unloaded  Bytes   Time
    3200   5240.0        2     1.0   0.32
```

解释：
- **Loaded**：加载的类的数量。
- **Bytes**：加载类的字节数。
- **Unloaded**：卸载的类的数量。
- **Time**：用于类加载的时间。

通过 `jstat -class` 可以查看应用中类的加载和卸载情况，如果频繁地卸载和加载某些类，可能会导致性能下降，可以根据这些信息优化类的加载策略。

### 典型应用场景

1. **排查频繁 GC 问题**：
   - 当应用程序性能下降，频繁进行垃圾回收时，可以通过 `jstat -gc` 和 `jstat -gcutil` 查看 GC 频率和内存使用情况，帮助确认是否是某个区域的内存频繁被填满导致频繁 GC，从而调整内存大小或者 GC 参数。

2. **优化类加载**：
   - 在大型 Java 应用中，如果类加载器频繁加载和卸载类，会造成较大的性能开销。通过 `jstat -class` 可以了解类的加载和卸载情况，并采取合适的类加载策略进行优化。

3. **Full GC 分析**：
   - 通过 `jstat -gc` 可以查看 Full GC 的次数和时间，帮助分析应用中老年代的使用情况，减少 Full GC 的发生次数，例如优化对象生命周期、减小内存碎片等。

### 总结

- `jstat` 是一个强大的命令行工具，专门用于监控 JVM 的内存和 GC 活动。
- 常用参数包括 `-gc`、`-gcutil`、`-class`，分别用于监控垃圾回收信息、内存利用率、类加载情况等。
- `jstat` 的数据可以帮助我们分析应用的内存占用和 GC 频率，从而做出相应的优化调整，是 Java 性能调优不可或缺的工具。

通过 `jstat`，开发者可以更好地理解 Java 应用程序在内存和垃圾回收方面的行为，找出潜在的问题，并且进行有针对性的调优。
````





```
使用 jstat 和 jmap 工具可以进一步分析 JVM 的运行状况，尤其是内存分配和垃圾回收（GC）行为，以诊断和解决性能问题。以下是使用这两个工具的具体步骤以及它们在分析高 CPU 或内存问题中的应用：

利用 jstat 和 jmap 分析 JVM 问题

1. jstat 分析 JVM 性能指标

jstat 是 JVM 自带的工具，用于监控 JVM 的性能和内存分配情况，尤其是垃圾回收行为。

常用命令
	1.	查看 JVM 的垃圾回收信息

jstat -gc <pid> 1000

	•	<pid>：目标 Java 进程的进程 ID。
	•	1000：刷新间隔（毫秒）。
输出示例：

S0C    S1C    S0U    S1U      EC       EU       OC         OU         MC       MU       CCSC     CCSU       YGC    YGCT     FGC    FGCT     GCT
512.0  512.0  0.0    256.0    1024.0   768.0    8192.0     4096.0     512.0    256.0    64.0     32.0       10     0.12      3      0.05      0.17

字段含义：
	•	S0C/S1C：Survivor 0/1 区容量（KB）。
	•	S0U/S1U：Survivor 0/1 区已使用容量（KB）。
	•	EC/EU：Eden 区容量和已使用容量。
	•	OC/OU：Old 区容量和已使用容量。
	•	YGC/YGCT：Young GC 次数和时间。
	•	FGC/FGCT：Full GC 次数和时间。
	•	GCT：GC 总时间。
分析重点：
	•	查看 FGC（Full GC）次数是否频繁，时间是否过长。
	•	如果 Old 区（OU）使用率很高，可能是内存泄漏或长时间未触发 GC。

	2.	查看堆内存使用情况

jstat -gccapacity <pid>

输出包括各代（Eden、Survivor、Old）的最大容量和当前使用容量。

	3.	查看类加载信息

jstat -class <pid>

输出包括已加载的类数量、卸载类数量和消耗的元空间（Metaspace）大小，帮助判断是否有类加载过多的问题。

2. jmap 导出堆转储文件

jmap 用于生成堆快照（Heap Dump）文件，或者直接查看堆中对象的分布情况。

常用命令
	1.	查看堆内存对象分布

jmap -histo <pid>

输出示例：

num     #instances         #bytes  class name
----------------------------------------------
1:        10000          1600000  [C
2:         5000          1200000  java.lang.String
3:         3000           900000  java.util.HashMap$Node
4:         2000           800000  java.util.ArrayList
...

分析重点：
	•	#instances：某个类的对象实例数。
	•	#bytes：对象占用的堆内存大小。
	•	大对象占用较多内存：
	•	如果某些类（如 java.util.HashMap 或数组 [C）实例数或占用内存过高，可能是内存泄漏的根源。
	•	如果 java.lang.String 占比很高，可能是频繁创建字符串导致的内存问题。

	2.	生成堆转储文件

jmap -dump:format=b,file=heapdump.hprof <pid>

参数：
	•	format=b：生成二进制格式的转储文件。
	•	file=heapdump.hprof：指定输出文件名。
	•	<pid>：目标进程 ID。
分析工具：
	•	使用工具如 Eclipse MAT (Memory Analyzer Tool) 或 VisualVM 分析生成的 .hprof 文件，定位内存泄漏或大对象。

	3.	查看 JVM 配置

jmap -heap <pid>

输出 JVM 的堆配置（如堆大小、GC 类型）以及当前各代内存的使用情况。

3. 综合分析 CPU 高的线程和内存问题

结合 jstat 和 jmap 的分析思路：
	1.	定位高 CPU 消耗线程：
	•	通过 top 和 top -Hp <pid> 找到高 CPU 消耗的线程 ID。
	•	将线程 ID 转换为十六进制，结合 jstack 分析线程堆栈。
	•	如果堆栈显示线程与 GC 或资源争用相关，可进一步使用 jstat 分析垃圾回收情况。
	2.	分析垃圾回收（GC）频率：
	•	通过 jstat -gc <pid> 检查 Young GC 和 Full GC 次数和时间：
	•	如果 Full GC 次数多且时间长，说明老年代（Old Generation）占用率过高。
	•	如果 Young GC 次数多且 Eden 区快速填满，说明对象创建速度过高，可能有短命对象需要优化。
	3.	分析内存分布和泄漏：
	•	通过 jmap -histo <pid> 查看哪些类的对象实例数或内存占用过高。
	•	如果发现某些对象占用内存异常大，可以进一步生成堆转储文件：

jmap -dump:format=b,file=heapdump.hprof <pid>


	•	使用 MAT 等工具分析转储文件，确定内存泄漏的根源。

	4.	结合线程和内存分析：
	•	如果高 CPU 线程的堆栈指向某些计算逻辑，检查是否有代码性能问题（如死循环、递归计算）。
	•	如果指向垃圾回收线程，结合 jstat 输出分析是否是 GC 频率或内存不足引起。

4. 示例分析流程

假设 pid 为 12345：

Step 1：通过 jstat 检查 GC 行为

jstat -gc 12345 1000

观察 FGC 和 YGCT 是否有异常增长。

Step 2：通过 jmap 检查堆中对象

jmap -histo 12345

查看是否有某些对象实例过多或内存占用过高。

Step 3：导出堆转储文件

如果怀疑内存泄漏，生成转储文件：

jmap -dump:format=b,file=heapdump.hprof 12345

使用 MAT 或 VisualVM 进一步分析。

Step 4：结合线程堆栈分析

通过 jstack 分析高 CPU 线程的调用堆栈，定位问题代码或 GC 线程。

总结
	•	使用 jstat 分析 JVM 的垃圾回收和内存使用情况，定位 GC 频率高或内存不足的问题。
	•	使用 jmap 查看堆中对象分布，分析内存泄漏或生成堆转储文件进行详细分析。
	•	结合 top 和 jstack，可以定位到具体线程的代码逻辑是否存在问题，并判断 CPU 高是由 GC、死锁还是代码耗时计算引起。

通过这些工具，可以快速诊断和解决 JVM 中的性能问题。
```



# 一条sql过慢

1.首先explain查看具体执行

2.讨论下图

https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg%3D%3D&chksm=f368897cc41f006ad40bf96669ac30f1d937bb075283db91788419c8086c1039bca6d3e3fcbe&idx=3&mid=2650182749&scene=27&sn=fc88ba99216b67169f3a5c1426ddb477&utm_campaign=geek_search&utm_content=geek_search&utm_medium=geek_search&utm_source=geek_search&utm_term=geek_search#wechat_redirect

![image-20241125105627914](/Users/haozhipeng/Library/Application Support/typora-user-images/image-20241125105627914.png)



https://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ%3D%3D&chksm=fcad7202cbdafb144051f985ae0ddf833d1ca44beeb176f92a3befe0372efb00baa4e54fc1c8&idx=1&mid=2247510046&scene=27&sn=57288b3f23859e60b0a3e7a5676c677a&utm_campaign=geek_search&utm_content=geek_search&utm_medium=geek_search&utm_source=geek_search&utm_term=geek_search#wechat_redirect

1.选择区分度高的作为索引

2.



1. SQL语句优化，尽量精简，去除非必要语句
2. 索引优化，让所有SQL都能够走索引
3. 如果是表的瓶颈问题，则分表，单表数据量维持在1000W以内
4. 如果是单库瓶颈问题，则分库，读写分离
5. 如果是物理机器性能问题，则分多个数据库节点



https://mp.weixin.qq.com/s?__biz=MzIwMzY1OTU1NQ%3D%3D&chksm=96cee702a1b96e145791ff5c5cd5eb75e627444d7ca07feb28e42040177b52f4768ec3cf2ffb&idx=2&mid=2247509838&scene=27&sn=74024d16444208043829ba7621724f13&utm_campaign=geek_search&utm_content=geek_search&utm_medium=geek_search&utm_source=geek_search&utm_term=geek_search#wechat_redirect



https://xie.infoq.cn/article/83a6ee16e302a021bbb40d3b9?utm_campaign=geek_search&utm_content=geek_search&utm_medium=geek_search&utm_source=geek_search&utm_term=geek_search

```



要对 MySQL 进行优化，可以从架构层、引擎层、SQL 层三个方面进行。每个层次的优化目标和方法各有不同，但它们的目标都是提高数据库的性能、响应速度和资源利用率。以下详细描述如何在这三个层次上进行优化：

### 一、架构层优化

架构层面的优化是指在系统设计和数据库部署阶段，通过合理的系统架构设计来提高 MySQL 性能。主要包括数据库的整体规划、部署、集群、读写分离等。

1. **分库分表**
   - **水平分库分表**：将同一个表的数据根据某个规则分布到多个数据库实例中，减少单个表的记录数，进而减少磁盘的 I/O 操作。
   - **垂直分库分表**：根据业务的逻辑，将不同的表分布到不同的数据库中。比如将用户信息表和订单信息表放到不同的数据库中，减少数据库负载。

2. **读写分离**
   - 在读写分离的场景下，将写操作交给主数据库（Master），而读操作交给多个从数据库（Slave）。这可以极大减轻主库的查询压力。
   - 常用的方法是通过 MySQL 的主从复制机制，结合应用层的读写分离代码来实现负载均衡。

3. **缓存机制**
   - **使用内存缓存**：在高并发场景下，使用 Redis 或 Memcached 来缓存热点数据，减少对 MySQL 的访问，降低 MySQL 的负载。
   - **查询缓存**：对于较为静态的数据，可以利用 MySQL 的查询缓存（在 MySQL 8 中已被移除，但仍有类似机制）。它可以缓存查询结果，减少重复查询的成本。

4. **负载均衡和集群**
   - **主从集群**：通过主从复制实现数据高可用，并且通过应用层进行负载均衡。
   - **分布式集群**：通过分片数据库中间件（如 Sharding-Sphere、MyCat），将数据分散到多个物理节点上，减轻单个数据库的压力。

5. **备份与容灾**
   - 规划数据库的备份与容灾策略，使用工具如 `mysqldump`、`xtrabackup` 进行备份，同时结合云服务的备份策略，提高数据库的可用性和安全性。

### 二、引擎层优化

MySQL 提供了多种存储引擎（例如 InnoDB、MyISAM），每种存储引擎有不同的特性，因此选择合适的存储引擎、调优引擎参数、合理配置存储结构，可以极大提高数据库性能。

1. **选择合适的存储引擎**
   - **InnoDB 引擎**：InnoDB 支持事务、安全性强、崩溃恢复功能好，对于多数 Web 应用来说更适合。它支持行级锁、MVCC，适合频繁读写和事务操作。
   - **MyISAM 引擎**：MyISAM 的特点是简单高效、读取性能好，但不支持事务和行级锁，适用于以读为主、无需事务支持的场景。

2. **调整 InnoDB 的参数配置**
   - **调整 Buffer Pool 大小**：InnoDB 通过 `innodb_buffer_pool_size` 参数缓存表和索引，合理调整该值可以极大提升 I/O 性能，一般建议设置为物理内存的 60-70%。
   - **日志文件配置**：调整 `innodb_log_file_size` 的大小，合理增大事务日志的容量，可以提升写入性能。
   - **Redo 和 Undo 调优**：合理设置 `innodb_log_buffer_size`，让 Redo log 足够大可以减少磁盘 I/O；合理调整 Undo log 保留周期，以减少无效数据占用空间。

3. **表设计与索引优化**
   - **合适的索引设计**：索引是优化查询的重要手段。需要选择合适的字段进行索引，避免为每个字段都建立索引导致索引文件过大。应优先考虑常用查询条件、排序字段、JOIN 字段进行索引。
   - **覆盖索引**：对于频繁访问的查询，可以利用覆盖索引（即查询的字段都在索引中），减少回表操作。
   - **聚簇索引与非聚簇索引**：InnoDB 默认使用聚簇索引，可以根据查询需求合理选择索引类型。
  
4. **锁的优化**
   - **锁粒度**：InnoDB 支持行级锁和表级锁，合理选择锁粒度，避免大量行级锁转为表级锁而导致锁冲突。
   - **减少锁等待时间**：可以通过降低事务的执行时间来减少锁的持有时间，同时避免死锁的发生。
  
5. **分区表**
   - 如果数据量特别大，可以使用分区表。通过 `RANGE`、`HASH` 等分区策略，可以将一个表分为多个逻辑分区，这样查询和修改只需操作相应的分区，提升查询和写入效率。

### 三、SQL 层优化

SQL 语句的优化是 MySQL 优化的关键环节，编写高效的 SQL 语句可以有效减少查询时间，降低资源占用。

1. **合理使用索引**
   - **避免全表扫描**：编写 SQL 时应尽量使用索引字段做过滤条件，避免全表扫描。可以通过 `EXPLAIN` 分析 SQL 查询计划，确定索引的使用情况。
   - **避免隐式转换**：隐式转换会导致 MySQL 无法使用索引。比如 `where id = "123"` 中 id 是 int 类型，而 "123" 是字符串，导致索引失效。

2. **SQL 查询的重构**
   - **减少子查询的使用**：尽量避免嵌套子查询，特别是带有 `IN` 的子查询，建议使用 `JOIN` 代替，以便更好地使用索引。
   - **使用覆盖索引**：可以尽量设计覆盖索引的查询，避免回表操作，比如 `select id, name from table where id = ?`，如果 `id` 和 `name` 都在索引中，可以减少从表中获取数据的开销。
   - **使用适当的分组和排序**：对于涉及 `GROUP BY` 和 `ORDER BY` 的查询，应尽量让这些字段也使用索引，避免全表排序带来的性能消耗。

3. **优化 LIMIT 分页查询**
   - 对于 `LIMIT` 分页查询，如果 offset 很大，查询效率会显著降低。可以通过记录上一次查询的最大 id，基于索引来进行分页查询，避免大量的跳过扫描。

4. **使用合适的数据类型**
   - **使用合适的整数类型**：例如 `TINYINT`、`SMALLINT`、`INT`、`BIGINT` 等应根据需求选择合适的类型，以减少存储空间。
   - **字符类型优化**：对于固定长度的字符串，可以使用 `CHAR` 类型，对于可变长度则使用 `VARCHAR`，避免存储空间浪费。
   - **减少宽表设计**：宽表的字段过多时，每次访问会带来大量无用数据，可以通过分表将冷数据与热数据分离。

5. **减少锁的开销**
   - 在事务中，尽量将写操作放在最后执行，避免长时间持有锁。
   - 尽量将批量插入拆分成多个小批量操作，降低锁冲突几率，减少表级锁带来的阻塞。

6. **使用批量操作**
   - 对于 `INSERT`、`UPDATE` 等操作，尽量采用批量操作来减少每次网络通信和事务处理的开销。

7. **SQL 优化工具**
   - 使用 MySQL 的 `EXPLAIN` 工具可以分析查询的执行计划，找到潜在的性能瓶颈，比如是否使用了全表扫描，是否使用了合适的索引等。
   - `SHOW PROFILES` 和 `SHOW STATUS` 可以帮助查看查询的执行状态和性能数据，用于分析查询的耗时以及每一阶段的时间消耗。

### 总结

- **架构层面**：通过分库分表、读写分离、缓存策略、负载均衡等手段来优化整体架构。
- **引擎层面**：选择合适的存储引擎、调整引擎配置、合理设计表结构和索引。
- **SQL 层面**：编写高效的 SQL 语句，利用索引、避免全表扫描、减少子查询、分页优化、使用批量操作等。

综合这些优化措施，可以有效提高 MySQL 数据库的性能，减少查询时间和资源消耗。不同的业务场景需要根据具体需求选择最合适的优化方法。
```





### 深分页

https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg%3D%3D&chksm=f36885cdc41f0cdbb97c065cef458a136965db2ce75776d523ecfedca013fc5cc3fe49bd5b78&idx=2&mid=2650183916&scene=27&sn=e75358f1098915ef9b8450f040bd7d1f&utm_campaign=geek_search&utm_content=geek_search&utm_medium=geek_search&utm_source=geek_search&utm_term=geek_search#wechat_redirect

select * from tb limit 一百万，10 -》 select * from tb  where id >（select id from limit 一百万）limit 10 【前提是查询*的时候没有覆盖索引的情况，这样的话前者每次都得回表丢弃，后者只用回表 10 次】

否则假如下面两者都有覆盖索引是等同的：

SELECT a, b, c FROM tb ORDER BY id LIMIT 1000000, 10;

SELECT a, b, c FROM tb
WHERE id > (
    SELECT id FROM tb ORDER BY id LIMIT 1000000, 1
)
ORDER BY id
LIMIT 10;

### 深分页查询的问题

在深分页查询中，`LIMIT`语句的`offset`值很大，这意味着 MySQL 需要扫描大量的索引节点和行数据，然后丢弃大部分结果。这个过程不仅效率低下，而且随着`offset`值的增加，性能下降会更加明显。原因如下：

- **索引扫描开销**：MySQL 需要扫描更多的索引节点来定位到`offset`对应的行。
- **回表操作开销**：对于非聚簇索引，每次找到满足条件的索引记录都需要执行一次回表操作，这在大`offset`值时尤其昂贵。
- **结果集构建开销**：即使已经找到了所需的数据，MySQL 仍然需要处理和丢弃之前的`offset`行。

1.限制查询数量

2.分批查询每次把上次的start带回来，每次定位到id在哪，然后往后遍历100个数据，这样不管是多少万的数据，查询性能都很稳定（标签记录法）

3.子查询优化

https://xie.infoq.cn/article/1f1553764c46581c381c2d942?utm_campaign=geek_search&utm_content=geek_search&utm_medium=geek_search&utm_source=geek_search&utm_term=geek_search





lru 归并



# @Transactional

`@Transactional` 是 Spring 框架中用于声明式事务管理的注解**。它可以应用于类或方法上，用于定义该类或方法在执行过程中应该有事务支持**。以下是详细介绍 `@Transactional` 的各个方面：

### 1. 基本用法

#### 应用在类上

当 `@Transactional` 注解应用在类上时，该类的所有公共方法都将具有事务支持。

```
java
复制代码
@Service
@Transactional
public class UserService {
    public void createUser(User user) {
        // 该方法将在事务中执行
    }
}
```

#### 应用在方法上

当 `@Transactional` 注解应用在方法上时，只有该方法具有事务支持。

```
java
复制代码
@Service
public class UserService {
    @Transactional
    public void createUser(User user) {
        // 该方法将在事务中执行
    }
}
```

### 2. 事务属性

`@Transactional` 注解提供了多种属性用于配置事务行为：

#### propagation

- `propagation` 属性用于**控制事务的传播行为，即当前事务方法在被其他事务方法调用时，事务的处理方式。Spring 提供了七种不同的传播行为，允许您定义事务在不同情况下的执行逻辑。以下是详细介绍每种传播行为及其应用场景**：

  ### 1. `REQUIRED`（默认）

  如**果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务**。

  - **应用场景**：这是最常用的传播行为，适用于大多数业务场景。
  - **示例**：

  ```
  java
  复制代码
  @Transactional(propagation = Propagation.REQUIRED)
  public void methodA() {
      // methodA将在事务中执行
  }
  ```

  ### 2. `REQUIRES_NEW`

  总是创建一个新的事务，如果当前存在事务，则将当前事务挂起。

  - **应用场景**：适用于需要独立提交的操作，不受外部事务影响。
  - **示例**：

  ```
  java
  复制代码
  @Transactional(propagation = Propagation.REQUIRES_NEW)
  public void methodB() {
      // methodB将在新的事务中执行
  }
  ```

  ### 3. `SUPPORTS`

  **如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行**。

  - **应用场景**：适用于**不强制要求事务的操作，可以与现有事务一起执行，也可以独立执行。**
  - **示例**：

  ```
  java
  复制代码
  @Transactional(propagation = Propagation.SUPPORTS)
  public void methodC() {
      // methodC在有事务时加入事务，没有事务时非事务执行
  }
  ```

  ### 4. `NOT_SUPPORTED`

  总是**以非事务方式执行，如果当前存在事务，则将当前事务挂起。**

  - **应用场景**：适用于明确不需要事务的操作，避免事务开销。
  - **示例**：

  ```
  java
  复制代码
  @Transactional(propagation = Propagation.NOT_SUPPORTED)
  public void methodD() {
      // methodD将以非事务方式执行
  }
  ```

  ### 5. `MANDATORY`

  如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。

  - **应用场景**：适用于必须在事务中执行的操作，如果没有事务环境，则视为错误。
  - **示例**：

  ```
  java
  复制代码
  @Transactional(propagation = Propagation.MANDATORY)
  public void methodE() {
      // methodE必须在事务中执行，否则抛出异常
  }
  ```

  ### 6. `NEVER`

  **总是以非事务方式执行，如果当前存在事务，则抛出异常**。

  - **应用场景**：适用于明确要求不能在事务中执行的操作。
  - **示例**：

  ```
  java
  复制代码
  @Transactional(propagation = Propagation.NEVER)
  public void methodF() {
      // methodF不能在事务中执行，否则抛出异常
  }
  ```

  ### 7. `NESTED`

  **如果当前存在事务，则创建一个嵌套事务（子事务）；如果当前没有事务，则创建一个新的事务。**

  - **应用场景**：适用于需要部分回滚的复杂事务场景，通过保存点实现局部回滚。
  - **注意**：需要数据库支持保存点。
  - **示例**：

  ```
  java
  复制代码
  @Transactional(propagation = Propagation.NESTED)
  public void methodG() {
      // methodG将在嵌套事务中执行
  }
  ```

  ### 实际应用示例

  以下是一个综合示例，展示了如何在实际项目中应用不同的传播行为：

  ```
  java
  复制代码
  @Service
  public class OrderService {
  
      @Autowired
      private PaymentService paymentService;
  
      @Transactional(propagation = Propagation.REQUIRED)
      public void createOrder(Order order) {
          // 创建订单逻辑
          saveOrder(order);
  
          // 调用支付服务
          paymentService.processPayment(order);
      }
  
      @Transactional(propagation = Propagation.REQUIRES_NEW)
      public void saveOrder(Order order) {
          // 保存订单逻辑
          orderRepository.save(order);
      }
  }
  
  @Service
  public class PaymentService {
  
      @Transactional(propagation = Propagation.REQUIRES_NEW)
      public void processPayment(Order order) {
          // 支付处理逻辑
          paymentRepository.save(payment);
      }
  }
  ```

  在这个示例中：

  - `createOrder` 方法使用 `REQUIRED` 传播行为，如果存在事务，则加入该事务；否则创建一个新的事务。
  - `saveOrder` 和 `processPayment` 方法使用 `REQUIRES_NEW` 传播行为，总是创建一个新的事务，即使在同一事务上下文中调用，也会开启新的事务。

  ### 传播行为的使用注意事项

  1. **事务隔离级别**：不同传播行为的组合使用时，需要注意事务的隔离级别和并发问题。
  2. **事务传播与异常处理**：在使用事务传播时，需要合理处理异常，确保事务能够正确提交或回滚。
  3. **性能开销**：使用 `REQUIRES_NEW` 和 `NESTED` 传播行为时，需要注意事务的创建和嵌套事务的性能开销。
  4. **事务管理器支持**：确保所使用的数据库和事务管理器支持所需的传播行为，特别是嵌套事务。

  通过合理使用 `propagation` 属性，可以根据业务需求精细控制事务的传播行为，确保数据一致性和操作的原子性。

  4o

  当前事务方法在被其他事务方法调用，1. REQUIRED（默认） 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。请问那当前不是肯定存在事物吗？

  

  ChatGPT

  在事务管理中，`REQUIRED` 传播行为是最常用的默认设置。理解这一行为的关键在于事务的上下文。在以下几个场景中，`REQUIRED` 的作用会有所不同：

  ### 场景 1：事务方法在无事务上下文中调用

  假设有一个服务方法 `serviceMethod1` 被一个没有开启事务的调用者调用，而 `serviceMethod1` 本身标注了 `@Transactional(propagation = Propagation.REQUIRED)`。

  ```
  java
  复制代码
  @Service
  public class MyService {
      @Transactional(propagation = Propagation.REQUIRED)
      public void serviceMethod1() {
          // 事务操作
      }
  }
  
  // 调用代码，没有开启事务
  myService.serviceMethod1();
  ```

  在这种情况下，因为调用 `serviceMethod1` 时没有现有事务上下文，所以 `serviceMethod1` 会创建一个新的事务。

  ### 场景 2：事务方法在事务上下文中调用

  假设有另一个服务方法 `serviceMethod2`，它也标注了 `@Transactional(propagation = Propagation.REQUIRED)`，并且在 `serviceMethod1` 中被调用。

  ```
  java
  复制代码
  @Service
  public class MyService {
      @Transactional(propagation = Propagation.REQUIRED)
      public void serviceMethod1() {
          // 调用另一个事务方法
          serviceMethod2();
      }
  
      @Transactional(propagation = Propagation.REQUIRED)
      public void serviceMethod2() {
          // 事务操作
      }
  }
  ```

  在这种情况下，当调用 `serviceMethod1` 时，会创建一个事务。在 `serviceMethod1` 内部调用 `serviceMethod2` 时，由于 `serviceMethod2` 也使用 `REQUIRED` 传播行为，且当前已经存在事务上下文，因此 `serviceMethod2` 不会创建新的事务，而是加入当前的事务。

  ### 场景 3：外部调用与内部调用

  考虑如下外部调用和内部调用的场景：

  ```
  java
  复制代码
  @Service
  public class MyService {
      @Transactional(propagation = Propagation.REQUIRED)
      public void serviceMethod1() {
          // 事务操作
      }
  
      @Transactional(propagation = Propagation.REQUIRED)
      public void serviceMethod3() {
          // 调用自身的serviceMethod1
          serviceMethod1();
      }
  }
  ```

  当 `serviceMethod3` 被外部调用时，它会创建一个事务。在 `serviceMethod3` 内部调用 `serviceMethod1` 时，虽然是同一个类，但 `serviceMethod1` 将加入 `serviceMethod3` 的事务，而不是创建新的事务。

  ### 总结

  - **独立调用**：当事务方法被外部调用且没有现有事务上下文时，`REQUIRED` 会创建一个新的事务。
  - **嵌套调用**：当事务方法在现有事务上下文中被调用时，`REQUIRED` 会加入现有事务，而不是创建新的事务。

  ### 示例

  以下示例展示了如何根据不同传播行为处理事务：

  ```
  java
  复制代码
  @Service
  public class MyService {
  
      @Transactional(propagation = Propagation.REQUIRED)
      public void methodA() {
          // 在没有现有事务时，创建新的事务
          // 在有现有事务时，加入现有事务
      }
  
      @Transactional(propagation = Propagation.REQUIRES_NEW)
      public void methodB() {
          // 总是创建新的事务
      }
  
      public void methodC() {
          // 无事务方法
          methodA(); // methodA 会创建新的事务
          methodB(); // methodB 会创建新的事务
      }
  
      @Transactional(propagation = Propagation.REQUIRED)
      public void methodD() {
          // 当前方法创建事务
          methodA(); // methodA 加入现有事务
          methodB(); // methodB 创建新的事务
      }
  }
  ```

  通过上述示例和解释，可以更清楚地理解 `REQUIRED` 的作用及其在不同上下文中的行为。

#### isolation

事务的隔离级别，表示一个事务可以看到其他事务所做更改的程度。常用的隔离级别包括：

- `DEFAULT`（默认）：使用数据库的默认隔离级别。
- `READ_UNCOMMITTED`：允许读取未提交的数据（脏读）。
- `READ_COMMITTED`：只能读取已提交的数据（防止脏读）。
- `REPEATABLE_READ`：防止脏读和不可重复读。
- `SERIALIZABLE`：完全串行化的读，防止脏读、不可重复读和幻读。

#### timeout

事务的超时时间（以秒为单位）。如果事务在指定时间内没有完成，则会回滚。

```
java
复制代码
@Transactional(timeout = 5)
public void createUser(User user) {
    // 该方法在事务中执行，超时时间为5秒
}
```

#### readOnly

指示事务是否只读。只读事务可以进行优化，例如不需要执行刷新操作。

```
java
复制代码
@Transactional(readOnly = true)
public User getUserById(Long id) {
    // 该方法在只读事务中执行
}
```

#### rollbackFor

指定一个或多个异常类，当这些异常被抛出时，事务将回滚。

```
java
复制代码
@Transactional(rollbackFor = {Exception.class})
public void createUser(User user) throws Exception {
    // 该方法在事务中执行，抛出Exception时将回滚
}
```

#### noRollbackFor

指定一个或多个异常类，当这些异常被抛出时，事务将不会回滚。

```
java
复制代码
@Transactional(noRollbackFor = {RuntimeException.class})
public void createUser(User user) {
    // 该方法在事务中执行，抛出RuntimeException时将不会回滚
}
```

### 3. 事务管理器

Spring 提供了多种事务管理器，常用的有：

- `DataSourceTransactionManager`：用于管理 JDBC 事务。
- `JpaTransactionManager`：用于管理 JPA 事务。
- `HibernateTransactionManager`：用于管理 Hibernate 事务。

配置事务管理器的示例：

```
java
复制代码
@Configuration
@EnableTransactionManagement
public class AppConfig {

    @Bean
    public DataSource dataSource() {
        // 配置数据源
    }

    @Bean
    public PlatformTransactionManager transactionManager() {
        return new DataSourceTransactionManager(dataSource());
    }
}
```

### 4. 示例

以下是一个综合示例，展示了如何使用 `@Transactional` 注解进行事务管理：

```
java
复制代码
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED, timeout = 5, rollbackFor = {Exception.class})
    public void createUser(User user) throws Exception {
        userRepository.save(user);
        // 其他业务逻辑
    }

    @Transactional(readOnly = true)
    public User getUserById(Long id) {
        return userRepository.findById(id).orElse(null);
    }
}
```

在这个示例中：

- `createUser` 方法具有事务支持，使用 `REQUIRED` 传播行为，`READ_COMMITTED` 隔离级别，超时时间为5秒，并且在抛出 `Exception` 时回滚。
- `getUserById` 方法在只读事务中执行。

### 5. 注意事项

- **事务只能应用于公共方法**：因为 Spring AOP 只能拦截公共方法。
- **事务失效**：当 `@Transactional` 注解应用于私有或保护方法时，事务不会生效。
- **事务嵌套**：使用 `PROPAGATION_NESTED` 传播行为可以实现事务嵌套，但需要数据库支持保存点。
- **事务回滚**：默认情况下，Spring **仅在未捕获的运行时异常上回滚事务。要在检查异常上回滚事务**，需要使用 `rollbackFor` 属性。

通过合理配置和使用 `@Transactional` 注解，可以确保数据库操作的一致性和完整性，简化事务管理的复杂性。



在 Spring 的事务管理中，默认情况下，事务只有在未捕获的运行时异常（即 `RuntimeException` 或其子类）上才会回滚。如果抛出的是受检异常（即 `Exception` 或其子类，但不包括 `RuntimeException`），事务将不会自动回滚。为了在受检异常上也回滚事务，可以使用 `@Transactional` 注解的 `rollbackFor` 属性。

### 背景知识

- **运行时异常 (`RuntimeException`)**：在 Java 中，运行时异常是继承自 `RuntimeException` 的异常。这些异常是未检查的（unchecked），编译器不会强制要求处理它们。默认情况下，Spring 事务管理会在运行时异常上回滚事务。
- **受检异常 (`Exception`)**：受检异常是继承自 `Exception`，但不是 `RuntimeException` 的异常。编译器会强制要求处理这些异常，通常通过 `try-catch` 语句或在方法签名中声明 `throws`。

### 默认行为

默认情况下，当事务方法抛出未捕获的运行时异常时，Spring 会回滚事务。例如：

```
java
复制代码
@Service
public class MyService {

    @Transactional
    public void transactionalMethod() {
        // 业务逻辑
        if (someCondition) {
            throw new RuntimeException("Something went wrong!"); // 事务将回滚
        }
    }
}
```

在上述代码中，如果 `someCondition` 为真，将抛出 `RuntimeException`，并且事务将会回滚。

然而，如果方法抛出的是受检异常，事务默认不会回滚：

```
java
复制代码
@Service
public class MyService {

    @Transactional
    public void transactionalMethod() throws Exception {
        // 业务逻辑
        if (someCondition) {
            throw new Exception("Checked exception occurred!"); // 事务不会回滚
        }
    }
}
```

在这种情况下，尽管抛出了 `Exception`，事务仍然会提交，而不是回滚。

### 自定义回滚行为

如果希望在受检异常上也回滚事务，可以使用 `rollbackFor` 属性。例如：

```
java
复制代码
@Service
public class MyService {

    @Transactional(rollbackFor = Exception.class)
    public void transactionalMethod() throws Exception {
        // 业务逻辑
        if (someCondition) {
            throw new Exception("Checked exception occurred!"); // 事务将回滚
        }
    }
}
```

在上述代码中，即使抛出的是 `Exception`，事务也会回滚，因为我们在 `@Transactional` 注解中指定了 `rollbackFor = Exception.class`。

### 详细解释

#### 1. **`@Transactional` 注解**

- `@Transactional` 注解用于声明方法或类需要事务支持。
- 默认情况下，它仅在未捕获的 `RuntimeException` 上回滚事务。

#### 2. **`rollbackFor` 属性**

- `rollbackFor` 属性用于指定一个或多个异常类，遇到这些异常时回滚事务。
- 它可以是单个异常类或异常类数组。

#### 示例

```
java
复制代码
@Service
public class MyService {

    @Transactional(rollbackFor = {Exception.class, CustomException.class})
    public void transactionalMethod() throws Exception {
        // 业务逻辑
        if (someCondition) {
            throw new CustomException("Custom checked exception occurred!"); // 事务将回滚
        }
    }
}

public class CustomException extends Exception {
    public CustomException(String message) {
        super(message);
    }
}
```

在这个示例中，`transactionalMethod` 方法在抛出 `Exception` 或 `CustomException` 时都会回滚事务。

### 总结

- **默认行为**：Spring 仅在未捕获的 `RuntimeException` 上回滚事务。
- **自定义行为**：通过 `rollbackFor` 属性，可以指定受检异常也触发事务回滚。

### 面试角度

在面试中，了解和掌握 Spring 事务管理的默认行为以及如何定制回滚策略是非常重要的。以下是一些可能的面试问题和回答示例：

#### 问题 1：Spring 默认在什么情况下回滚事务？

**回答**：Spring 默认情况下会在未捕获的运行时异常（即 `RuntimeException` 或其子类）上回滚事务。对于受检异常，事务不会自动回滚，除非通过 `rollbackFor` 属性进行配置。

#### 问题 2：如何让 Spring 在受检异常上也回滚事务？

**回答**：可以使用 `@Transactional` 注解的 `rollbackFor` 属性来指定希望回滚事务的异常类型。例如，`@Transactional(rollbackFor = Exception.class)` 会使事务在抛出任何 `Exception` 时回滚。

通过详细了解这些知识，能够更好地处理实际开发中的事务管理问题，并在面试中展现扎实的技术功底。







### 2. 直接调用本类中的方法

#### 原因：

当在一个类中调用本类的另一个方法时，AOP 不会生效。这是因为 Spring AOP 基于代理机制，只有通过代理对象调用方法时，才能触发切面逻辑。

**代理机制**：
Spring AOP 基于代理机制实现，主要有两种代理方式：
1. **JDK 动态代理**：适用于目标对象实现了接口的情况。
2. **CGLIB 代理**：适用于目标对象没有实现接口的情况。

当 Spring AOP 创建一个代理对象时，方法调用的过程是这样的：
- 调用代理对象的方法。
- 代理对象决定是否执行切面逻辑。
- 如果有切面逻辑，先执行切面逻辑，再执行目标方法。
- 否则，直接执行目标方法。

但是，当在一个类中直接调用本类的另一个方法时，这个调用不会通过代理对象进行，而是直接调用该方法。因此，切面逻辑不会被执行。

#### 详细解释

考虑以下示例代码：

```java
@Service
public class MyService {

    @Transactional
    public void methodA() {
        // do something
        methodB();
    }

    @Transactional
    public void methodB() {
        // do something
    }
}
```

在这个示例中，`methodA` 直接调用 `methodB`。如果有一个 `@Transactional` 切面，期望 `methodA` 和 `methodB` 都受事务管理。

但是，实际情况是：
- 调用 `methodA` 时，事务切面会生效，因为调用是通过代理对象进行的。
- 当 `methodA` 调用 `methodB` 时，这个调用是直接在对象内部发生的，不经过代理对象。因此，事务切面不会作用于 `methodB`。

#### 解决方法：

将方法调用抽取到外部类，通过 Spring 管理的代理对象来调用方法。这意味着你需要使用 Spring 管理的对象来调用方法，以确保调用通过代理对象进行。

### 具体示例：

以下是一个解决方案，将方法调用抽取到外部类，并使用 Spring 管理的代理对象来调用方法。

#### 示例一：在外部类中调用

创建一个新的服务类，将 `methodA` 和 `methodB` 的调用逻辑放到外部类中。

```java
@Service
public class MyService {

    @Transactional
    public void methodA() {
        // do something
    }

    @Transactional
    public void methodB() {
        // do something
    }
}

@Service
public class MyServiceCaller {

    @Autowired
    private MyService myService;

    public void callMethods() {
        myService.methodA();
        myService.methodB();
    }
}
```

在这个示例中，`MyServiceCaller` 使用 `MyService` 的代理对象来调用 `methodA` 和 `methodB`，因此 AOP 切面会生效。

#### 示例二：在同一类中使用 Spring 管理的代理对象

如果不想创建新的类，可以在同一类中使用 Spring 管理的代理对象来调用方法。这可以通过 Spring 的上下文获取当前代理对象。

```java
@Service
public class MyService {

    @Autowired
    private ApplicationContext applicationContext;

    @Transactional
    public void methodA() {
        // do something
        MyService proxy = applicationContext.getBean(MyService.class);
        proxy.methodB();
    }

    @Transactional
    public void methodB() {
        // do something
    }
}
```

在这个示例中，通过 `ApplicationContext` 获取 `MyService` 的代理对象，然后通过代理对象调用 `methodB`，这样就能确保 AOP 切面生效。

### 总结：

当在一个类中直接调用本类的另一个方法时，Spring AOP 切面不会生效，因为这种调用不会通过代理对象进行。解决这个问题的常见方法是将方法调用抽取到外部类，或者在同一类中通过 Spring 上下文获取代理对象来调用方法。这样可以确保所有方法调用都通过代理对象进行，从而触发 AOP 切面逻辑。





好的，我将通过具体的例子来详细解释跳表的原理和操作过程。假设我们有一个跳表，想要存储如下的有序元素集合：

```
[3, 6, 7, 9, 12, 17, 19, 21, 25, 26]
```

### 一、跳表的结构

我们要构建的跳表可能长这样（假设每个节点的层数是随机分配的）：

```
Level 3:                     9
Level 2:         6           9                       25
Level 1: 3       6       7   9           17      21  25
Level 0: 3   6   7   9   12  17  19  21  25  26
```

在这个跳表中：
- **Level 0** 包含所有的元素，这是基础层。
- **Level 1、2 和 3** 分别是更高层次的索引，元素数量逐层递减。

### 二、跳表的查找操作

假设我们要查找元素 `19`。查找过程如下：

1. 从 **Level 3** 开始：
   - 当前节点是 `9`。19 > 9，因此向右查找。
   - 发现 `9` 的右边没有更多节点，下降到 **Level 2**。

2. 在 **Level 2**：
   - 当前节点仍然是 `9`。19 > 9，因此向右移动到 `25`。
   - 19 < 25，向下移动到 **Level 1**。

3. 在 **Level 1**：
   - 当前节点是 `9`。19 > 9，向右移动到 `17`。
   - 19 > 17，继续向右移动到 `21`。
   - 19 < 21，向下移动到 **Level 0**。

4. 在 **Level 0**：
   - 当前节点是 `17`。19 > 17，继续向右移动到 `19`，找到目标元素。

在这个过程中，每次下降到更低一层，只会处理有限数量的节点，从而加速查找过程。

### 三、跳表的插入操作

假设我们要插入一个新的元素 `15`。步骤如下：

1. 首先，根据随机函数确定新节点的层数。假设新节点有 2 层，意味着它会出现在 **Level 0** 和 **Level 1**。

2. 在 **Level 1** 和 **Level 0** 中查找插入位置：
   - 在 **Level 1**：从 `9` 向右移动到 `17`，发现 `15` 应该插入在 `9` 和 `17` 之间。
   - 在 **Level 0**：从 `9` 向右移动到 `12`，发现 `15` 应该插入在 `12` 和 `17` 之间。

3. 插入新节点并更新指针：
   - 在 **Level 1**：插入 `15`，并更新 `9` 的 `forward` 指针指向 `15`，`15` 的 `forward` 指针指向 `17`。
   - 在 **Level 0**：插入 `15`，并更新 `12` 的 `forward` 指针指向 `15`，`15` 的 `forward` 指针指向 `17`。

插入后，跳表的结构可能会变成这样：

```
Level 3:                     9
Level 2:         6           9                       25
Level 1: 3       6       7   9       15      17      25
Level 0: 3   6   7   9   12  15  17  19  21  25  26
```

### 四、跳表的删除操作

假设我们要删除元素 `9`。步骤如下：

1. 在所有层中找到 `9` 的位置。

2. 更新指针来绕过 `9`：
   - 在 **Level 3**：删除 `9`，将其指针更新为 `NULL`。
   - 在 **Level 2**：将 `6` 的指针更新为指向 `25`。
   - 在 **Level 1**：将 `7` 的指针更新为指向 `15`。
   - 在 **Level 0**：将 `7` 的指针更新为指向 `12`。

删除后，跳表的结构可能会变成这样：

```
Level 3:                     
Level 2:         6                                   25
Level 1: 3       6       7       15      17          25
Level 0: 3   6   7   12  15  17  19  21  25  26
```

### 五、总结

通过这个例子，可以看到跳表的查找、插入和删除操作的过程。跳表通过多个层级的索引加速了这些操作，使得查找、插入和删除的时间复杂度都接近 O(log N)，而其实现比平衡树简单得多。

Redis 利用跳表在有序集合（Sorted Set）中的高效操作，支持快速的范围查找和按分数排名查询，这些都归功于跳表的高效数据组织结构和操作原理。



要详细解释跳表的工作原理、操作过程及其在实际应用中的作用，我将从跳表的定义、数据结构、操作过程（包括查找、插入、删除）、索引更新机制、以及在实际应用中的优势等方面进行详细说明，并结合具体示例和图解来帮助理解。

### 一、跳表的定义和基本原理

1. **跳表的定义**：
   - 跳表（Skip List）是一种随机化的数据结构，基于有序链表，通过在链表上增加多级索引，优化查找、插入和删除操作。
   - 跳表的核心思想是使用多层次的“跳跃”指针来加速操作，提供类似于平衡树的时间复杂度。

2. **跳表的基本构造**：
   - **有序链表**：跳表的底层结构是一个有序链表，所有节点按照从小到大的顺序排列。
   - **多级索引**：在有序链表的基础上，每隔一定数量的节点就会创建一个更高层次的索引，使得跳表可以在多个层次上进行“跳跃”搜索。

### 二、跳表的数据结构图解

我们从一个简单的有序链表开始，然后逐步构建跳表的多级索引。

1. **基础有序链表**：
   假设我们有一个简单的有序链表，存储如下数据：

   ```
   [3, 6, 7, 9, 12, 17, 19, 21, 25, 26]
   ```

   图示如下：

   ```
   3 -> 6 -> 7 -> 9 -> 12 -> 17 -> 19 -> 21 -> 25 -> 26
   ```

   在这个链表中，查找某个数据（例如 `19`）的时间复杂度为 O(n)，因为我们可能需要遍历所有节点才能找到目标值。

2. **引入索引层次**：
   为了加速查找操作，我们在链表上增加多级索引。如下图所示：

   ```
   Level 2:        6          17             25
   Level 1:    3   6    9     12  17   21    25  26
   Level 0: 3 -> 6 -> 7 -> 9 -> 12 -> 17 -> 19 -> 21 -> 25 -> 26
   ```

   - **Level 0** 是基础的有序链表，包含所有数据。
   - **Level 1** 和 **Level 2** 是索引层，用来加速查找操作。

   在这个结构中，较高层次的链表包含较少的节点，它们通过跳跃来覆盖更大的范围，从而加速查找操作。

### 三、跳表的操作过程

1. **查找操作**：
   查找操作从跳表的顶层（最高层）开始，逐层向下，直到找到目标节点或确认节点不存在。查找的时间复杂度为 O(log n)。

   **查找 `19` 的示例**：
   - 从 `Level 2` 开始，初始节点为 `6`，向右查找到 `17`。
   - 由于 `19 > 17`，向右移动到 `25`，此时 `19 < 25`，所以下降到 `Level 1`。
   - 在 `Level 1`，从 `17` 开始，向右查找到 `21`，此时 `19 < 21`，所以下降到 `Level 0`。
   - 在 `Level 0`，从 `17` 向右查找到 `19`，查找成功。

2. **插入操作**：
   插入新节点时，首先确定新节点应该出现的层数（通过随机化算法），然后在对应层次中插入新节点，并更新相关的索引。插入的时间复杂度为 O(log n)。

   **插入 `15` 的示例**：
   - 随机确定 `15` 的层数，假设 `15` 应该出现在 `Level 0` 和 `Level 1`。
   - 在 `Level 1` 中，从 `12` 开始，向右查找到 `17`，将 `15` 插入到 `12` 和 `17` 之间。
   - 在 `Level 0` 中，从 `12` 开始，向右查找到 `17`，将 `15` 插入到 `12` 和 `17` 之间。
   - 插入后的跳表结构如下：

   ```
   Level 2:        6          17             25
   Level 1:    3   6    9    12  15   17   21  25  26
   Level 0: 3 -> 6 -> 7 -> 9 -> 12 -> 15 -> 17 -> 19 -> 21 -> 25 -> 26
   ```

3. **删除操作**：
   删除节点时，首先找到要删除的节点，然后从跳表的各个层次中删除该节点，并更新相关指针。删除的时间复杂度为 O(log n)。

   **删除 `9` 的示例**：
   - 从最高层 `Level 2` 开始，查找 `9`，找到后将其从 `Level 1` 和 `Level 0` 中删除。
   - 删除后的跳表结构如下：

   ```
   Level 2:        6          17             25
   Level 1:    3   6          12  15   17   21  25  26
   Level 0: 3 -> 6 -> 7 -> 12 -> 15 -> 17 -> 19 -> 21 -> 25 -> 26
   ```

### 四、跳表的索引更新机制

跳表的多级索引通过随机化算法来维护，使得索引的更新变得简单且高效。具体来说：

1. **随机化选择层级**：
   - 当插入一个新节点时，跳表会通过随机化算法决定该节点要加入到多少层的索引中。
   - 通常情况下，每一个节点在第 k 层出现的概率为 1/2^(k-1)，这意味着高层索引的节点数量会越来越少。

2. **动态平衡索引**：
   - 由于索引层级是随机化的，所以即使在频繁的插入和删除操作之后，跳表依然可以保持高效的查找性能。
   - 索引的动态平衡机制使得跳表能够在不需要复杂的旋转或重构操作的情况下，始终保持接近 O(log n) 的查找、插入和删除性能。

### 五、跳表的实际应用

1. **Redis 的 SortedSet**：
   - 在 Redis 中，跳表被用作 SortedSet 的底层实现，支持有序集合中元素的快速查找、范围查询和排名操作。
   - 跳表的随机化索引结构和 Redis 的设计理念非常契合，因为它们都追求高效、简单和可扩展性。

2. **LevelDB 的 MemTable**：
   - 在 LevelDB 中，跳表被用于 MemTable 的实现，支持高效的有序键值存储和查找操作。
   - 跳表的快速插入和删除操作使得它非常适合在数据库中作为内存中的中间数据结构。

### 六、总结

跳表是一种简单而高效的数据结构，它通过在有序链表上引入多级索引，使得查找、插入和删除操作的时间复杂度从 O(n) 降低到 O(log n)。跳表的实现相对平衡树更为简单，但依然能够提供接近的性能，因此在实际工程中得到了广泛应用，如 Redis 的 SortedSet 和 LevelDB 的 MemTable。

通过上述详细解释和示例，相信你能够对跳表的工作原理和操作过程有一个深入的理解。如果还有任何疑问或需要进一步的探讨，欢迎继续提问！












### check_region_mapping.py

```
import os
import sys
from copy import deepcopy
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from collections import Counter
import numpy as np

PRD = os.environ['PRD']
SUBJ_ID = os.environ['SUBJ_ID']
a = '1'
CHECK = os.environ['CHECK']
if "DISPLAY" in os.environ:
    DISPLAY = os.environ['DISPLAY']
else:
    DISPLAY = ""
region_mapping_corr = float(os.environ['REGION_MAPPING_CORR'])
os.chdir(os.path.join(PRD,a,SUBJ_ID,'surface'))


def breadth_first_search(iposi, itrian, ilab):
    queue = [iposi]
    V = [iposi]
    while len(queue) > 0:
        iQ = queue.pop()
        iedges = list(itrian[np.argwhere(itrian==iQ)[:,0]].flatten())
        while len(iedges)>0:
            ineig = iedges.pop()
            if ineig not in V and texture[ineig]==ilab:
                V.append(ineig)
                queue.append(ineig)
    return V

def calculate_connected(texture, vert, trian):
    "find if the regions are connected components using Breadth-first seach"
    labels = np.unique(texture) 
    res = []
    for ilab in labels:
        ipos = np.nonzero(texture==ilab)
        ivert = vert[ipos]
        itrian=[]
        for itri in np.nonzero(texture==ilab)[0].tolist():
            itrian.extend(trian[np.nonzero(trian==itri)[0]])
        itrian = np.array(itrian).astype('int')
        V = breadth_first_search(ipos[0][0], itrian, ilab)
        res.append((ilab, ivert.shape[0]-len(V)))
    return res

def find_both_components(texture, vert, trian, ilab):
    " find the two subgraphs"
    ipos = np.nonzero(texture==ilab)
    ivert = vert[ipos]
    itrian=[]
    for itri in ipos[0].tolist():
        itrian.extend(trian[np.nonzero(trian==itri)[0]])
    itrian = np.array(itrian).astype('int')
    # first region
    V1 = breadth_first_search(ipos[0][0], itrian, ilab)
    # second region
    istart = 1
    while ipos[0][istart] in V1:
        istart += 1   
    V2 = breadth_first_search(ipos[0][istart], itrian, ilab)
    return (V1, V2)

def correct_sub_region(texture, trian, Vw):
    "correct the region mapping for the chosen component"
    new_texture = np.copy(texture)
    icount = 0
    while len(Vw)>0:
        iVw = Vw.pop()
        itrian = trian[np.nonzero(trian==iVw)[0]].flatten().astype('int').tolist()
        ir = list(filter(lambda x : new_texture[x] != new_texture[iVw], itrian))
        if len(ir)>0:
            new_texture[iVw] = new_texture[Counter(ir).most_common(1)[0][0]] 
        else:
            if icount<50: 
                Vw.insert(0, iVw)
                icount +=1
            else:
                # TODO: good error message
                print('error in correction')
                import pdb; pdb.set_trace()
    return new_texture

def check_region_mapping(texture, vert, trian, ilab):
    "drawing the region"
    ipos = np.nonzero(texture==ilab)
    itrian=[]
    for itri in ipos[0].tolist():
        itrian.extend(trian[np.nonzero(trian==itri)[0]])
    itrian = np.array(itrian).astype('int')
    bool_itrian = np.in1d(itrian, ipos[0]).reshape(itrian.shape[0], 3)
    itrian[np.nonzero(bool_itrian == False)] = 0
    citri = np.vstack([np.vstack([itrian[:,0], itrian[:,1]]).T, np.vstack([itrian[:,1],itrian[:,2]]).T, np.vstack([itrian[:,2],itrian[:,0]]).T])
    bcitri = (citri!=0).sum(1)
    valp = citri[bcitri==2]
    fig = plt.figure(figsize=(15, 15))
    fig.suptitle('region ' + str(int(ilab)))
    ax = fig.add_subplot(111, projection='3d') 
    plt.xlabel('x')
    plt.ylabel('y')
    for iv in np.arange(valp.shape[0]):
        ax.plot(vert[valp[iv], 0], vert[valp[iv], 1], vert[valp[iv], 2])
    # old function
    # xitrians = vert[np.hstack((itrian, itrian[:,0][:, newaxis])), 0]
    # yitrians = vert[np.hstack((itrian, itrian[:,0][:, newaxis])), 1]
    # zitrians = vert[np.hstack((itrian, itrian[:,0][:, newaxis])), 2]
    # fig = figure(figsize=(15, 15))
    # fig.suptitle('region ' + int(ilab))
    # ax = fig.add_subplot(111, projection='3d') 
    # for iv in range(xitrians.shape[0]): 
    #     ax.plot(xitrians[iv], yitrians[iv], zitrians[iv], alpha=0.4)
    # ax.scatter(vert[ipos, 0], vert[ipos, 1], vert[ipos, 2], c='b', s=45)
    show()

if __name__ == '__main__':

    rl = sys.argv[1]
    
    vert = np.loadtxt(rl+'_vertices_low.txt')
    trian = np.loadtxt(rl+'_triangles_low.txt')
    texture = np.loadtxt(rl + '_region_mapping_low.txt')

    res = np.array(calculate_connected(texture, vert, trian))
    wrong_labels = res[np.where(res[:,1]>0.),0][0]
    if len(wrong_labels)==0:
        print('evrything is fine, continuing')
    else:
        print("WARNING, some region have several components")
        for iwrong in wrong_labels:
            # TODO: handle more than two components
            (V1, V2) = find_both_components(texture, vert, trian, iwrong)
            if CHECK =="yes" and len(DISPLAY)>0:
                print("checking")
                check_region_mapping(texture, vert, trian, iwrong)
                i=0
                while True and i<10:
                    try:
                        choice_user = raw_input("""Do you want to get rid of region with:
                                            1) {0} nodes
                                            2) {1} nodes
                                            3) continue the pipeline anyway
                                            (answer: 1, 2, or 3)? \n""".format(len(V1), len(V2)))
                        print("you chose " + choice_user)

                        choice_user = int(choice_user)
                        if choice_user not in [1, 2, 3]:
                            raise ValueError
                        break 
                    except ValueError:
                        print('please choose 1, 2 or 3')
                        i += 1
                        continue
                else:
                    print('failure total, no check mode')
            else:
                print("no check, selecting automatically the smallest components")
                choice_user = np.argmin((len(V1), len(V2)))+1
            if choice_user==3:
                print("keep that correction")
                np.savetxt(rl + '_region_mapping_low.txt', new_texture)
            elif choice_user==1:
                texture = correct_sub_region(texture, trian, V1)
            elif  choice_user==2:
                texture =  correct_sub_region(texture, trian, V2)
            else: 
                print('failure of the choice')

        np.savetxt(rl + '_region_mapping_low.txt', texture)
```



这段 Python 代码是用来处理神经影像数据，特别是关于大脑皮层区域的连接性分析。它涉及多个步骤，包括加载数据、搜索连接的脑区、进行三维可视化和处理地形纹理映射。下面我将详细解释每个部分的功能和逻辑。

### 代码结构和功能解释

1. **初始化和加载数据**:
   - 从环境变量中获取一些必要的路径和参数，如项目目录 (`PRD`)、被试ID (`SUBJ_ID`) 和检查标志 (`CHECK`)。
   - 更改当前工作目录到指定的脑表面数据所在目录。
   - 加载顶点数据 (`vertices.txt`)、三角形数据 (`triangles.txt`)，这些数据用于构建和分析脑表面。
2. **广度优先搜索 (BFS) 算法**:
   - `breadth_first_search` 函数用于从特定的起始点开始，根据纹理标签查找连接的顶点。
   - 这个函数对于识别和区分大脑各个区域的连通性非常重要。
3. **计算连通组件**:
   - `calculate_connected` 函数遍历所有唯一的纹理标签，并使用 BFS 来确定每个标签对应的区域是否为连通区域。
   - 函数返回每个区域的连通性信息，这对于进一步的分析如修正区域映射非常关键。
4. **三维可视化**:
   - `check_region_mapping` 函数用于可视化特定纹理标签的三维结构。
   - 使用 matplotlib 的 3D 功能来描绘脑区的三维连接图。
5. **自动和交互式错误校正**:
   - 根据命令行参数和环境设置，脚本可能会要求用户交互式地选择如何处理检测到的错误（例如，一个脑区可能被错误地分成了两个独立的部分）。
   - 根据用户的选择，可以采取不同的策略来修正这些问题。
6. **保存修改**:
   - 一旦所有的更改和修正完成，最终的纹理映射将被保存回文件系统，以便进一步的使用或分析。

### 典型用途和应用场景

这种类型的脚本通常用于神经科学研究，尤其是在进行功能性或结构性连接性分析时。通过识别和校正数据集中的问题，研究人员可以确保他们的分析基于准确和一致的数据。此外，能够交互式地检查和修改数据是调试和验证分析流程的一个重要部分。

### 注意事项

- 代码假设所有必要的输入文件都严格遵循特定的格式和命名约定。
- 三维可视化部分依赖于具体的图形显示配置（由环境变量 `DISPLAY` 控制），在某些无头服务器或远程环境中可能需要特别配置或禁用。
- 错误处理和用户交互逻辑需要根据实际情况灵活调整，以适应不同的研究需求和工作流程。

这段代码是一个复杂的神经影像数据处理脚本，展示了如何整合数据处理、算法逻辑、用户交互和可视化等多个方面。





